{"config":{"lang":["en"],"separator":"\\.","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Narwhals","text":"<p>-</p> <p> </p> <p>Extremely lightweight and extensible compatibility layer between dataframe libraries!</p> <ul> <li>Full API support: cuDF, Modin, pandas, Polars, PyArrow.</li> <li>Lazy-only support: Dask, DuckDB, Ibis, PySpark, SQLFrame. Work in progress: Daft.</li> </ul> <p>Seamlessly support all, without depending on any!</p> <ul> <li>\u2705 Just use a subset of the Polars API, no need to learn anything new</li> <li>\u2705 Zero dependencies, Narwhals only uses what   the user passes in so your library can stay lightweight</li> <li>\u2705 Separate lazy and eager APIs, use expressions</li> <li>\u2705 Support pandas' complicated type system and index, without   either getting in the way</li> <li>\u2705 100% branch coverage, tested against pandas and Polars nightly builds</li> <li>\u2705 Negligible overhead, see overhead</li> <li>\u2705 Let your IDE help you thanks to full static typing, see <code>narwhals.typing</code></li> <li>\u2705 Perfect backwards compatibility policy,   see stable api for how to opt-in</li> </ul>"},{"location":"#whos-this-for","title":"Who's this for?","text":"<p>Anyone wishing to write a library/application/service which consumes dataframes, and wishing to make it completely dataframe-agnostic.</p> <p>Let's get started!</p>"},{"location":"#roadmap","title":"Roadmap","text":"<p>See roadmap discussion on GitHub for an up-to-date plan of future work.</p>"},{"location":"backcompat/","title":"Perfect backwards compatibility policy","text":"<p>Narwhals is primarily aimed at library maintainers rather than end users. As such, we need to take stability and backwards compatibility extra-seriously. Our policy is:</p> <ul> <li>If you write code using <code>narwhals.stable.v1</code> or <code>import narwhals.stable.v2</code>, then we promise to   never change or remove any public function you're using.</li> <li>If we need to make a backwards-incompatible change, it will be pushed into   the main <code>narwhals</code> namespace (and eventually <code>narwhals.stable.v3</code>),   leaving <code>narwhals.stable.v1</code> and <code>narwhals.stable.v2</code> unaffected.</li> <li>We will maintain <code>narwhals.stable.v1</code> and <code>narwhals.stable.v2</code> indefinitely,   even as <code>narwhals.stable.v3</code> and other stable APIs come out. For example,   Narwhals version 1.0.0 offers <code>narwhals.stable.v1</code>, whereas Narwhals 2.0.0 offers   both <code>narwhals.stable.v1</code> and <code>narwhals.stable.v2</code>.</li> </ul> <p>Like this, we enable different packages to be on different Narwhals stable APIs, and for end-users to use all of them in the same project without conflicts nor incompatibilities.</p>"},{"location":"backcompat/#background","title":"Background","text":"<p>Ever upgraded a package, only to find that it breaks all your tests because of an intentional API change? Did you end up having to litter your code with statements such as the following?</p> <pre><code>if parse_version(pdx.__version__) &lt; parse_version(\"1.3.0\"):\n    df = df.brewbeer()\nelif parse_version(\"1.3.0\") &lt;= parse_version(pdx.__version__) &lt; parse_version(\"1.5.0\"):\n    df = df.brew_beer()\nelse:\n    df = df.brew_drink(\"beer\")\n</code></pre> <p>Now imagine multiplying that complexity over all the dataframe libraries you want to support...</p> <p>Narwhals offers a simple solution, inspired by Rust editions.</p>"},{"location":"backcompat/#narwhals-stable-api","title":"Narwhals' Stable API","text":"<p>Narwhals implements a subset of the Polars API. What will Narwhals do if/when Polars makes a backwards-incompatible change? Would you need to update your Narwhals code?</p> <p>To understand the solution, let's go through an example. Suppose that, hypothetically, in Polars 2.0, <code>polars.Expr.cum_sum</code> was renamed to <code>polars.Expr.cumulative_sum</code>. In Narwhals, we have <code>narwhals.Expr.cum_sum</code>. Does this mean that Narwhals will also rename its method, and deprecate the old one? The answer is...no!</p> <p>Narwhals offers a <code>stable</code> namespace, which allows you to write your code once and forget about it. That is to say, if you write your code like this:</p> from/to_native@narwhalify <pre><code>import narwhals.stable.v2 as nw\nfrom narwhals.stable.v2.typing import IntoFrameT\n\n\ndef func(df: IntoFrameT) -&gt; IntoFrameT:\n    return nw.from_native(df).with_columns(nw.col(\"a\").cum_sum()).to_native()\n</code></pre> <pre><code>import narwhals.stable.v2 as nw\nfrom narwhals.stable.v2.typing import FrameT\n\n\n@nw.narwhalify\ndef func(df: FrameT) -&gt; FrameT:\n    return df.with_columns(nw.col(\"a\").cum_sum())\n</code></pre> <p>then we, in Narwhals, promise that your code will keep working, even in newer versions of Polars after they have renamed their method.</p> <p>Concretely, we would do the following:</p> <ul> <li><code>narwhals.stable.v2</code>: you can keep using <code>Expr.cum_sum</code></li> <li><code>narwhals.stable.v3</code>: you can only use <code>Expr.cumulative_sum</code>, <code>Expr.cum_sum</code> will have been removed</li> <li><code>narwhals</code>:  you can only use <code>Expr.cumulative_sum</code>, <code>Expr.cum_sum</code> will have been removed</li> </ul> <p>So, although Narwhals' main API (and <code>narwhals.stable.v3</code>) will have introduced a breaking change, users of <code>narwhals.stable.v2</code> will have their code unaffected.</p>"},{"location":"backcompat/#exceptions","title":"Exceptions","text":"<p>Are we really promising perfect backwards compatibility in all cases, without exceptions? Not quite. There are some exceptions, which we'll now list. But we'll never intentionally break your code. Anything currently in <code>narwhals.stable.v1</code> or <code>narwhals.stable.v2</code> will not be changed or removed in future Narwhals versions.</p> <p>Here are exceptions to our backwards compatibility policy:</p> <ul> <li>Unambiguous bugs. If a function contains what is unambiguously a bug, then we'll fix it, without   considering that to be a breaking change.</li> <li>Radical changes in backends. Suppose that Polars was to remove   expressions, or pandas were to remove support for categorical data. At that point, we might   need to rethink Narwhals. However, we expect such radical changes to be exceedingly unlikely.</li> <li>We may consider making some type hints more precise.</li> <li>Anything labelled \"unstable\".</li> <li>We may sometimes need to bump the minimum versions of supported backends.</li> <li>We will drop support for old python versions, roughly in sync with their end of life</li> </ul> <p>In general, decision are driven by use-cases, and we conduct a search of public GitHub repositories before making any change.</p>"},{"location":"backcompat/#import-narwhals-as-nw-import-narwhalsstablev2-as-nw-or-import-narwhalsstablev1-as-nw","title":"<code>import narwhals as nw</code>, <code>import narwhals.stable.v2 as nw</code>, or <code>import narwhals.stable.v1 as nw</code>?","text":"<p>Which should you use? In general we recommend:</p> <ul> <li>When prototyping, use <code>import narwhals as nw</code>, so you can iterate quickly.</li> <li>Once you're happy with what you've got and want to release something production-ready and stable,   then switch out your <code>import narwhals as nw</code> usage for <code>import narwhals.stable.v2 as nw</code>.</li> <li>If you're starting a new project, use either the main Narwhals namespace or <code>narwhals.stable.v2</code>.</li> <li>If your project is already using <code>narwhals.stable.v1</code>, and you don't need any of the newer Narwhals   features, there's probably no need to switch to <code>narwhals.stable.v2</code>, as that would require you to   raise the minimum version of Narwhals you support. If you'd like to use <code>narwhals.stable.v2</code>, make   sure to require at least <code>narwhals&gt;=2.0</code>.</li> </ul>"},{"location":"backcompat/#main-vs-stablev2-differences","title":"<code>main</code> vs <code>stable.v2</code> differences","text":"<p>So far, nothing, everything non-unstable from the main namespace should be available in <code>narwhals.stable.v2</code>.</p>"},{"location":"backcompat/#main-vs-stablev1-differences","title":"<code>main</code> vs <code>stable.v1</code> differences","text":"<ul> <li> <p>Since Narwhals 1.49:</p> <ul> <li><code>nw.Expr.arg_max</code> and <code>nw.Expr.arg_min</code> are deprecated from the main Narwhals namespace.   Note that the <code>Series</code> methods (<code>Series.arg_max</code>, <code>Series.arg_min</code>) will remain available.</li> </ul> </li> <li> <p>Since Narwhals 1.45:</p> <ul> <li><code>nw.any_horizontal</code> and <code>nw.all_horizontal</code> have a <code>ignore_nulls</code> keyword. In <code>narwhals.stable.v1</code>,   it defaults to <code>False</code>, but in Narwhals 2.0 it will become a required argument in the main namespace.</li> <li><code>LazyFrame.with_row_index</code> requires <code>order_by</code> to be specified as it is an order-dependent operation, in the main Narwhals namespace.</li> </ul> </li> <li> <p>Since Narwhals 1.43:</p> <ul> <li><code>nw.get_level</code> is deprecated in the main Narwhals namespace.</li> </ul> </li> <li> <p>Since Narwhals 1.35:</p> <ul> <li>pandas' ordered categoricals get mapped to <code>nw.Enum</code> instead of <code>nw.Categorical</code>.</li> <li><code>nw.Enum</code> must be provided <code>categories</code> at instantiation.</li> </ul> </li> <li> <p>Since Narwhals 1.29.0, <code>LazyFrame.gather_every</code> has been deprecated from the main namespace.</p> </li> <li> <p>Since Narwhals 1.25.0, <code>native_namespace</code> is generally deprecated across the API. Please   use <code>backend</code> instead.</p> </li> <li> <p>Since Narwhals 1.24.1, an empty or all-null object-dtype pandas Series is inferred to   be of dtype <code>String</code>. Previously, it would have been inferred as <code>Object</code>.</p> </li> <li> <p>Since Narwhals 1.23:</p> <ul> <li>Passing an <code>ibis.Table</code> to <code>from_native</code> returns a <code>LazyFrame</code>. In   <code>narwhals.stable.v1</code>, it returns a <code>DataFrame</code> with <code>level='interchange'</code>.</li> <li><code>eager_or_interchange_only</code> has been removed from <code>from_native</code> and <code>narwhalify</code>.</li> <li>Order-dependent expressions can no longer be used with <code>narwhals.LazyFrame</code>.</li> <li>The following expressions have been deprecated from the main namespace: <code>Expr.head</code>,   <code>Expr.tail</code>, <code>Expr.gather_every</code>, <code>Expr.sample</code>, <code>Expr.arg_true</code>, <code>Expr.sort</code>.</li> </ul> </li> <li> <p>Since Narwhals 1.21, passing a <code>DuckDBPyRelation</code> to <code>from_native</code> returns a <code>LazyFrame</code>. In   <code>narwhals.stable.v1</code>, it returns a <code>DataFrame</code> with <code>level='interchange'</code>.</p> </li> <li> <p>Since Narwhals 1.15, <code>Series</code> is generic in the native Series, meaning that you can   write:   <pre><code>import narwhals as nw\nimport polars as pl\n\ns_pl = pl.Series([1, 2, 3])\ns = nw.from_native(s, series_only=True)\n# mypy infers `s.to_native()` to be `polars.Series`\nreveal_type(s.to_native())\n</code></pre>   Previously, <code>Series</code> was not generic, so in the above example   <code>s.to_native()</code> would have been inferred as <code>Any</code>.</p> </li> <li> <p>Since Narwhals 1.13.0, the <code>strict</code> parameter in <code>from_native</code>, <code>to_native</code>, and <code>narwhalify</code>     has been deprecated in favour of <code>pass_through</code>. This is because several users expressed     confusion/surprise over what <code>strict=False</code> did.     <pre><code># v1 syntax:\nnw.from_native(df, strict=False)\n\n# main namespace (and, when we get there, v2) syntax:\nnw.from_native(df, pass_through=True)\n</code></pre>     If you are using Narwhals&gt;=1.13.0, then we recommend using <code>pass_through</code>, as that     works consistently across namespaces.</p> <p>In the future:</p> <ul> <li>in the main Narwhals namespace, <code>strict</code> will be removed in favour of <code>pass_through</code></li> <li>in <code>stable.v1</code>, we will keep both <code>strict</code> and <code>pass_through</code></li> </ul> </li> <li> <p>Since Narwhals 1.9.0, <code>Datetime</code> and <code>Duration</code> dtypes hash using both <code>time_unit</code> and     <code>time_zone</code>.     The effect of this can be seen when placing these dtypes in sets:</p> <pre><code>import narwhals.stable.v1 as nw_v1\nimport narwhals as nw\n\n# v1 behaviour:\nassert nw_v1.Datetime(\"us\") in {nw_v1.Datetime}\n\n# main namespace (and, when we get there, v2) behaviour:\nassert nw.Datetime(\"us\") not in {nw.Datetime}\nassert nw.Datetime(\"us\") in {nw.Datetime(\"us\")}\n</code></pre> <p>To check if a dtype is a datetime (regardless of <code>time_unit</code> or <code>time_zone</code>) we recommend using <code>==</code> instead, as that works consistently across namespaces:</p> <pre><code># Recommended\nassert nw.Datetime(\"us\") == nw.Datetime\nassert nw_v1.Datetime(\"us\") == nw_v1.Datetime\n</code></pre> </li> </ul>"},{"location":"ecosystem/","title":"Ecosystem","text":""},{"location":"ecosystem/#used-by","title":"Used by","text":"<p>The following is a non-exhaustive list of libraries and tools that choose to use Narwhals for their dataframe interoperability needs:</p> <ul> <li>altair</li> <li>bokeh</li> <li>darts</li> <li>fairlearn</li> <li>formulaic</li> <li>gt-extras</li> <li>hierarchicalforecast</li> <li>marimo</li> <li>metalearners</li> <li>mosaic</li> <li>panel-graphic-walker</li> <li>plotly</li> <li>pointblank</li> <li>pymarginaleffects</li> <li>pyreadstat</li> <li>py-shiny</li> <li>rio</li> <li>scikit-lego</li> <li>scikit-playtime</li> <li>tabmat</li> <li>tea-tasting</li> <li>timebasedcv</li> <li>tubular</li> <li>Validoopsie</li> <li>vegafusion</li> <li>wimsey</li> </ul> <p>If your project is missing from the list, feel free to open a PR to add it.</p> <p>If you would like to chat with us, or if you need any support, please join our Discord server.</p>"},{"location":"ecosystem/#related-projects","title":"Related projects","text":""},{"location":"ecosystem/#array-api","title":"Array API","text":"<p>Array counterpart to the DataFrame API, see here.</p>"},{"location":"ecosystem/#pycapsule-interface","title":"PyCapsule Interface","text":"<p>Allows C extension modules to safely share pointers to C data structures with Python code and other C modules, encapsulating the pointer with a name and optional destructor to manage resources and ensure safe access, see here for details.</p> <p>Narwhals supports exporting a DataFrame via the Arrow PyCapsule Interface. See Universal dataframe support with the Arrow PyCapsule Interface + Narwhals for how you can use them together.</p>"},{"location":"ecosystem/#ibis","title":"Ibis","text":"<p>Pitched as \"The portable Dataframe library\", Ibis provides a Pythonic frontend to various SQL (as well as Polars LazyFrame) engines. Some differences with Narwhals are:</p> <ul> <li>Narwhals allows you to write \"Dataframe X in, Dataframe X out\" functions.   Ibis allows materialising to pandas, Polars (eager), and PyArrow, but has   no way to get back to the input type exactly (e.g. <code>Enum</code>s don't round-trip in Ibis)</li> <li>Narwhals respects input data types as much as possible, Ibis doesn't   support Categorical / Enum.</li> <li>Narwhals separates between lazy and eager APIs, with the eager API   providing very fine control over dataframe operations (slicing rows and   columns, iterating over rows, getting values out of the dataframe as   Python scalars). Ibis is more focused on lazy execution.</li> <li>Narwhals is extremely lightweight and comes with zero required dependencies,   Ibis requires pandas and PyArrow for all backends.</li> <li>Narwhals uses a subset of the Polars API, Ibis uses its own   pandas/dplyr-inspired API.</li> <li>Ibis currently supports more backends than Narwhals</li> <li>Narwhals supports pandas and Dask, which Ibis has deprecated support for.</li> </ul> <p>Although people often ask about the two tools, we consider them to be very different and not in competition. In particular, Narwhals supports ibis Tables, meaning that dataframe-agnostic code written using Narwhals' lazy API also supports Ibis.</p>"},{"location":"extending/","title":"Extending Narwhals","text":"<p>Warning</p> <p>The extension mechanism in Narwhals is experimental and under development.</p> <p>If you want your own library to be recognised too, you're welcome open a PR (with tests)!. Alternatively, if you can't do that (for example, if you library is closed-source), see the next sections for what else you can do.</p>"},{"location":"extending/#creating-an-extension","title":"Creating an Extension","text":"<p>We love open source, but we're not \"open source absolutists\". If you're unable to open source your library, then this is how you can make your library compatible with Narwhals.</p> <p>Make sure that you define:</p> <ul> <li><code>DataFrame.__narwhals_dataframe__</code>: return an object which implements methods from the     <code>CompliantDataFrame</code> protocol in  <code>narwhals/typing.py</code>.</li> <li><code>DataFrame.__narwhals_namespace__</code>: return an object which implements methods from the     <code>CompliantNamespace</code> protocol in <code>narwhals/typing.py</code>.</li> <li><code>DataFrame.__native_namespace__</code>: return the object's native namespace.</li> <li><code>LazyFrame.__narwhals_lazyframe__</code>: return an object which implements methods from the     <code>CompliantLazyFrame</code> protocol in  <code>narwhals/typing.py</code>.</li> <li><code>LazyFrame.__narwhals_namespace__</code>: return an object which implements methods from the     <code>CompliantNamespace</code> protocol in <code>narwhals/typing.py</code>.</li> <li><code>LazyFrame.__native_namespace__</code>: return the object's native namespace.</li> <li><code>Series.__narwhals_series__</code>: return an object which implements methods from the     <code>CompliantSeries</code> protocol in <code>narwhals/typing.py</code>.</li> </ul> <p>If your library doesn't distinguish between lazy and eager, then it's OK for your dataframe   object to implement both <code>__narwhals_dataframe__</code> and <code>__narwhals_lazyframe__</code>. In fact,   that's currently what <code>narwhals._pandas_like.dataframe.PandasLikeDataFrame</code> does. So, if you're stuck,   take a look at the source code to see how it's done!</p> <p>Note that this \"extension\" mechanism is still experimental. If anything is not clear, or doesn't work, please do raise an issue or contact us on Discord (see the link on the README).</p>"},{"location":"extending/#creating-a-plugin","title":"Creating a Plugin","text":"<p>If it's not possible to add extra functions like <code>__narwhals_namespace__</code> and others to a dataframe object  itself, then another option is to write a plugin. Narwhals itself has the necessary utilities to detect and  handle plugins. For this integration to work, any plugin architecture must contain the following:</p> <ol> <li> <p>an entrypoint defined in a <code>pyproject.toml</code> file:</p> <p><pre><code>[project.entry-points.'narwhals.plugins']\nnarwhals-&lt;library name&gt; = 'narwhals_&lt;library name&gt;'\n</code></pre> The section name needs to be the same for all plugins; inside it, plugin creators can replace their own library name, for example <code>narwhals-grizzlies = 'narwhals_grizzlies'</code></p> </li> <li> <p>a top-level <code>__init__.py</code>\u00a0file containing the following: </p> <ul> <li><code>is_native</code> and <code>__narwhals_namespace__</code> functions</li> <li>a string constant <code>NATIVE_PACKAGE</code> which holds the name of the library for which the plugin is made</li> </ul> <p><code>is_native</code> accepts a native object and returns a boolean indicating whether the native object is  a dataframe of the library the plugin was written for.</p> <p><code>__narwhals_namespace__</code> takes the Narwhals version and returns a compliant namespace for the library, i.e. one that complies with the\u00a0CompliantNamespace\u00a0protocol. This protocol specifies a <code>from_native</code>  function, whose input parameter is the Narwhals version and which returns a compliant Narwhals LazyFrame which wraps the native dataframe. </p> </li> </ol> <p>If you want to see an example of a plugin, we have implemented a bare-bones version for the <code>daft</code> library that allows users to pass daft dataframes to Narwhals:  narwhals-daft. </p>"},{"location":"generating_sql/","title":"Generating SQL","text":"<p>Suppose you want to write Polars syntax and translate it to SQL. For example, what's the SQL equivalent to:</p> <pre><code>import narwhals as nw\nfrom narwhals.typing import IntoFrameT\n\n\ndef avg_monthly_price(df_native: IntoFrameT) -&gt; IntoFrameT:\n    return (\n        nw.from_native(df_native)\n        .group_by(nw.col(\"date\").dt.truncate(\"1mo\"))\n        .agg(nw.col(\"price\").mean())\n        .sort(\"date\")\n        .to_native()\n    )\n</code></pre> <p>?</p> <p>There are several ways to find out.</p>"},{"location":"generating_sql/#via-duckdb","title":"Via DuckDB","text":"<p>You can generate SQL directly from DuckDB.</p> <pre><code>import duckdb\n\nconn = duckdb.connect()\nconn.sql(\"\"\"CREATE TABLE prices (date DATE, price DOUBLE);\"\"\")\n\ndf = nw.from_native(conn.table(\"prices\"))\nprint(avg_monthly_price(df).sql_query())\n</code></pre> <pre><code>SELECT * FROM (SELECT _date_tmp AS date, price FROM (SELECT _date_tmp, mean(price) AS price FROM (SELECT date, price, date_trunc('month', date) AS _date_tmp FROM main.prices) AS prices GROUP BY _date_tmp) AS prices) AS prices ORDER BY date NULLS FIRST\n</code></pre> <p>To make it look a bit prettier, or to then transpile it to other SQL dialects, we can pass it to SQLGlot:</p> <pre><code>import sqlglot\n\nprint(sqlglot.transpile(avg_monthly_price(df).sql_query(), pretty=True)[0])\n</code></pre> <pre><code>SELECT\n  *\nFROM (\n  SELECT\n    _date_tmp AS date,\n    price\n  FROM (\n    SELECT\n      _date_tmp,\n      MEAN(price) AS price\n    FROM (\n      SELECT\n        date,\n        price,\n        DATE_TRUNC('MONTH', date) AS _date_tmp\n      FROM main.prices\n    ) AS prices\n    GROUP BY\n      _date_tmp\n  ) AS prices\n) AS prices\nORDER BY\n  date\n</code></pre>"},{"location":"generating_sql/#via-ibis","title":"Via Ibis","text":"<p>We can also use Ibis to generate SQL:</p> <pre><code>import ibis\n\nt = ibis.table({\"date\": \"date\", \"price\": \"double\"}, name=\"prices\")\nprint(ibis.to_sql(avg_monthly_price(t)))\n</code></pre> <pre><code>SELECT\n  \"t2\".\"_date_tmp\" AS \"date\",\n  \"t2\".\"price\"\nFROM (\n  SELECT\n    \"t1\".\"_date_tmp\",\n    AVG(\"t1\".\"price\") AS \"price\"\n  FROM (\n    SELECT\n      \"t0\".\"date\",\n      \"t0\".\"price\",\n      DATE_TRUNC('MONTH', \"t0\".\"date\") AS \"_date_tmp\"\n    FROM \"prices\" AS \"t0\"\n  ) AS \"t1\"\n  GROUP BY\n    1\n) AS \"t2\"\nORDER BY\n  \"t2\".\"_date_tmp\" ASC NULLS FIRST\n</code></pre>"},{"location":"generating_sql/#via-sqlframe","title":"Via SQLFrame","text":"<p>You can also use SQLFrame:</p> <pre><code>from sqlframe.standalone import StandaloneSession\n\nsession = StandaloneSession.builder.getOrCreate()\nsession.catalog.add_table(\"prices\", column_mapping={\"date\": \"date\", \"price\": \"float\"})\ndf = nw.from_native(session.read.table(\"prices\"))\n\nprint(avg_monthly_price(df).sql(dialect=\"duckdb\"))\n</code></pre> <pre><code>WITH \"t20239543\" AS (\n  SELECT\n    CAST(DATE_TRUNC('MONTH', CAST(\"prices\".\"date\" AS TIMESTAMPTZ)) AS TIMESTAMPTZ) AS \"_date_tmp\",\n    AVG(\"prices\".\"price\") AS \"price\"\n  FROM \"prices\" AS \"prices\"\n  GROUP BY\n    CAST(DATE_TRUNC('MONTH', CAST(\"prices\".\"date\" AS TIMESTAMPTZ)) AS TIMESTAMPTZ)\n)\nSELECT\n  \"t20239543\".\"_date_tmp\" AS \"date\",\n  \"t20239543\".\"price\" AS \"price\"\nFROM \"t20239543\" AS \"t20239543\"\nORDER BY\n  \"date\" NULLS FIRST\n</code></pre> <p>Or, to print the SQL code in a different dialect (say, databricks):</p> <pre><code>print(avg_monthly_price(df).sql(dialect=\"databricks\"))\n</code></pre> <pre><code>WITH `t20239543` AS (\n  SELECT\n    CAST(DATE_TRUNC('MONTH', CAST(`prices`.`date` AS TIMESTAMP)) AS TIMESTAMP) AS `_date_tmp`,\n    AVG(`prices`.`price`) AS `price`\n  FROM `prices` AS `prices`\n  GROUP BY\n    CAST(DATE_TRUNC('MONTH', CAST(`prices`.`date` AS TIMESTAMP)) AS TIMESTAMP)\n)\nSELECT\n  `t20239543`.`_date_tmp` AS `date`,\n  `t20239543`.`price` AS `price`\nFROM `t20239543` AS `t20239543`\nORDER BY\n  `date`\n</code></pre>"},{"location":"how_it_works/","title":"How it works","text":""},{"location":"how_it_works/#theory","title":"Theory","text":"<p>You might think that Narwhals runs on underwater unicorn magic. However, this section exists to reassure you that there's no such thing. There's only one rule you need to understand in order to make sense of Narwhals:</p> <p>An expression is a function from a DataFrame to a sequence of Series.</p> <p>For example, <code>nw.col('a')</code> means \"given a dataframe <code>df</code>, give me the Series <code>'a'</code> from <code>df</code>\". Translating this to pandas syntax, we get:</p> <pre><code>def col_a(df):\n    return [df.loc[:, \"a\"]]\n</code></pre> <p>Let's step up the complexity. How about <code>nw.col('a')+1</code>? We already know what the <code>nw.col('a')</code> part looks like, so we just need to add <code>1</code> to each of its outputs:</p> <pre><code>def col_a(df):\n    return [df.loc[:, \"a\"]]\n\n\ndef col_a_plus_1(df):\n    return [x + 1 for x in col_a(df)]\n</code></pre> <p>Expressions can return multiple Series - for example, <code>nw.col('a', 'b')</code> translates to:</p> <pre><code>def col_a_b(df):\n    return [df.loc[:, \"a\"], df.loc[:, \"b\"]]\n</code></pre> <p>Expressions can also take multiple columns as input - for example, <code>nw.sum_horizontal('a', 'b')</code> translates to:</p> <pre><code>def sum_horizontal_a_b(df):\n    return [df.loc[:, \"a\"] + df.loc[:, \"b\"]]\n</code></pre> <p>Note that although an expression may have multiple columns as input, those columns must all have been derived from the same dataframe. This last sentence was quite important, you might want to re-read it to make sure it sunk in.</p> <p>By itself, an expression doesn't produce a value. It only produces a value once you give it to a DataFrame context. What happens to the value(s) it produces depends on which context you hand it to:</p> <ul> <li><code>DataFrame.select</code>: produce a DataFrame with only the result of the given expression</li> <li><code>DataFrame.with_columns</code>: produce a DataFrame like the current one, but also with the result of   the given expression</li> <li><code>DataFrame.filter</code>: evaluate the given expression, and if it only returns a single Series, then   only keep rows where the result is <code>True</code>.</li> </ul> <p>Now let's turn our attention to the implementation.</p>"},{"location":"how_it_works/#pandas-implementation","title":"pandas implementation","text":"<p>The pandas namespace (<code>pd</code>) isn't Narwhals-compliant, as the pandas API is very different from Polars'. So...Narwhals implements a <code>PandasLikeNamespace</code>, which includes the top-level Polars functions included in the Narwhals API:</p> <pre><code>import pandas as pd\nimport narwhals as nw\nfrom narwhals._pandas_like.namespace import PandasLikeNamespace\nfrom narwhals._pandas_like.utils import Implementation\nfrom narwhals._utils import parse_version, Version\n\npn = PandasLikeNamespace(\n    implementation=Implementation.PANDAS,\n    version=Version.MAIN,\n)\nprint(nw.col(\"a\")._to_compliant_expr(pn))\n</code></pre> <pre><code>&lt;narwhals._pandas_like.expr.PandasLikeExpr object at 0x7fdde7d0b0e0&gt;\n</code></pre> <p>The result from the last line above is the same as we'd get from <code>pn.col('a')</code>, and it's a <code>narwhals._pandas_like.expr.PandasLikeExpr</code> object, which we'll call <code>PandasLikeExpr</code> for short.</p> <p><code>PandasLikeExpr</code> has a <code>_call</code> method which expects a <code>PandasLikeDataFrame</code> as input. Recall from above that an expression is a function from a dataframe to a sequence of series. The <code>_call</code> method gives us that function! Let's see it in action.</p> <p>Note: the following examples use <code>PandasLikeDataFrame</code> and <code>PandasLikeSeries</code>. These are backed by actual <code>pandas.DataFrame</code>s and <code>pandas.Series</code> respectively and are Narwhals-compliant. We can access the  underlying pandas objects via <code>PandasLikeDataFrame._native_frame</code> and <code>PandasLikeSeries._native_series</code>.</p> <pre><code>import narwhals as nw\nfrom narwhals._pandas_like.namespace import PandasLikeNamespace\nfrom narwhals._pandas_like.utils import Implementation\nfrom narwhals._pandas_like.dataframe import PandasLikeDataFrame\nfrom narwhals._utils import parse_version, Version\nimport pandas as pd\n\npn = PandasLikeNamespace(\n    implementation=Implementation.PANDAS,\n    version=Version.MAIN,\n)\n\ndf_pd = pd.DataFrame({\"a\": [1, 2, 3], \"b\": [4, 5, 6]})\ndf = PandasLikeDataFrame(\n    df_pd,\n    implementation=Implementation.PANDAS,\n    version=Version.MAIN,\n    validate_column_names=True,\n)\nexpression = pn.col(\"a\") + 1\nresult = expression._call(df)\nprint(f\"length of result: {len(result)}\\n\")\nprint(\"native series of first value of result: \")\nprint([x._native_series for x in result][0])\n</code></pre> <pre><code>length of result: 1\n\nnative series of first value of result: \n0    2\n1    3\n2    4\nName: a, dtype: int64\n</code></pre> <p>So indeed, our expression did what it said on the tin - it took some dataframe, took column 'a', and added 1 to it.</p> <p>If you search for <code>def reuse_series_implementation</code>, you'll see that that's all expressions do in Narwhals - they just keep rigorously applying the definition of expression.</p> <p>It may look like there should be significant overhead to doing it this way - but really, it's just a few Python calls which get unwinded. From timing tests I've done, there's no detectable difference - in fact, because the Narwhals API guards against misusing the pandas API, it's likely that running pandas via Narwhals will in general be more efficient than running pandas directly.</p> <p>Further attempts at demistifying Narwhals, refactoring code so it's clearer, and explaining this section better are 110% welcome.</p>"},{"location":"how_it_works/#polars-and-other-implementations","title":"Polars and other implementations","text":"<p>Other implementations are similar to the above: they define their own Narwhals-compliant objects. So, all-in-all, there are a couple of layers here:</p> <ul> <li><code>nw.DataFrame</code> is backed by a Narwhals-compliant Dataframe, such as:<ul> <li><code>narwhals._pandas_like.dataframe.PandasLikeDataFrame</code></li> <li><code>narwhals._arrow.dataframe.ArrowDataFrame</code></li> <li><code>narwhals._polars.dataframe.PolarsDataFrame</code></li> </ul> </li> <li>each Narwhals-compliant DataFrame is backed by a native Dataframe, for example:<ul> <li><code>narwhals._pandas_like.dataframe.PandasLikeDataFrame</code> is backed by a pandas DataFrame</li> <li><code>narwhals._arrow.dataframe.ArrowDataFrame</code> is backed by a PyArrow Table</li> <li><code>narwhals._polars.dataframe.PolarsDataFrame</code> is backed by a Polars DataFrame</li> </ul> </li> </ul> <p>Each implementation defines its own objects in subfolders such as <code>narwhals._pandas_like</code>, <code>narwhals._arrow</code>, <code>narwhals._polars</code>, whereas the top-level modules such as <code>narwhals.dataframe</code> and <code>narwhals.series</code> coordinate how to dispatch the Narwhals API to each backend.</p>"},{"location":"how_it_works/#mapping-from-api-to-implementations","title":"Mapping from API to implementations","text":"<p>If an end user executes some Narwhals code, such as</p> <p><pre><code>df.select(nw.col(\"a\") + 1)\n</code></pre> then how does that get mapped to the underlying dataframe's native API? Let's walk through this example to see.</p> <p>Things generally go through a couple of layers:</p> <ul> <li>The user calls some top-level Narwhals API.</li> <li>The Narwhals API forwards the call to a Narwhals-compliant dataframe wrapper, such as<ul> <li><code>PandasLikeDataFrame</code> / <code>ArrowDataFrame</code> / <code>PolarsDataFrame</code> / ...</li> <li><code>PandasLikeSeries</code> / <code>ArrowSeries</code> / <code>PolarsSeries</code> / ...</li> <li><code>PandasLikeExpr</code> / <code>ArrowExpr</code> / <code>PolarsExpr</code> / ...</li> </ul> </li> <li>The dataframe wrapper forwards the call to the underlying library, e.g.:<ul> <li><code>PandasLikeDataFrame</code> forwards the call to the underlying pandas/Modin/cuDF dataframe.</li> <li><code>ArrowDataFrame</code> forwards the call to the underlying PyArrow table.</li> <li><code>PolarsDataFrame</code> forwards the call to the underlying Polars DataFrame.</li> </ul> </li> </ul> <p>The way you access the Narwhals-compliant wrapper depends on the object:</p> <ul> <li><code>narwhals.DataFrame</code> and <code>narwhals.LazyFrame</code>: use the <code>._compliant_frame</code> attribute.</li> <li><code>narwhals.Series</code>: use the <code>._compliant_series</code> attribute.</li> <li><code>narwhals.Expr</code>: call the <code>._to_compliant_expr</code> method, and pass to it the Narwhals-compliant namespace associated with   the given backend.</li> </ul> <p>\ud83d\uded1 BUT WAIT! What's a Narwhals-compliant namespace?</p> <p>Each backend is expected to implement a Narwhals-compliant namespace (<code>PandasLikeNamespace</code>, <code>ArrowNamespace</code>, <code>PolarsNamespace</code>). These can be used to interact with the Narwhals-compliant Dataframe and Series objects described above - let's work through the motivating example to see how.</p> <pre><code>import narwhals as nw\nfrom narwhals._pandas_like.namespace import PandasLikeNamespace\nfrom narwhals._pandas_like.utils import Implementation\nfrom narwhals._pandas_like.dataframe import PandasLikeDataFrame\nfrom narwhals._utils import parse_version, Version\nimport pandas as pd\n\npn = PandasLikeNamespace(\n    implementation=Implementation.PANDAS,\n    version=Version.MAIN,\n)\n\ndf_pd = pd.DataFrame({\"a\": [1, 2, 3], \"b\": [4, 5, 6]})\ndf = nw.from_native(df_pd)\ndf.select(nw.col(\"a\") + 1)\n</code></pre> <p>The first thing <code>narwhals.DataFrame.select</code> does is to parse each input expression to end up with a compliant expression for the given backend, and it does so by passing a Narwhals-compliant namespace to <code>nw.Expr._to_compliant_expr</code>:</p> <pre><code>pn = PandasLikeNamespace(\n    implementation=Implementation.PANDAS,\n    version=Version.MAIN,\n)\nexpr = (nw.col(\"a\") + 1)._to_compliant_expr(pn)\nprint(expr)\n</code></pre> <pre><code>&lt;narwhals._pandas_like.expr.PandasLikeExpr object at 0x7fdde7dae3f0&gt;\n</code></pre> <p>If we then extract a Narwhals-compliant dataframe from <code>df</code> by calling <code>._compliant_frame</code>, we get a <code>PandasLikeDataFrame</code> - and that's an object which we can pass <code>expr</code> to!</p> <pre><code>df_compliant = df._compliant_frame\nresult = df_compliant.select(expr)\n</code></pre> <p>We can then view the underlying pandas Dataframe which was produced by calling <code>._native_frame</code>:</p> <pre><code>print(result._native_frame)\n</code></pre> <pre><code>   a\n0  2\n1  3\n2  4\n</code></pre> <p>which is the same as we'd have obtained by just using the Narwhals API directly:</p> <pre><code>print(nw.to_native(df.select(nw.col(\"a\") + 1)))\n</code></pre> <pre><code>   a\n0  2\n1  3\n2  4\n</code></pre>"},{"location":"how_it_works/#group-by","title":"Group-by","text":"<p>Group-by is probably one of Polars' most significant innovations (on the syntax side) with respect to pandas. We can write something like</p> <pre><code>df: pl.DataFrame\ndf.group_by(\"a\").agg((pl.col(\"c\") &gt; pl.col(\"b\").mean()).max())\n</code></pre> <p>To do this in pandas, we need to either use <code>GroupBy.apply</code> (sloooow), or do some crazy manual optimisations to get it to work.</p> <p>In Narwhals, here's what we do:</p> <ul> <li> <p>if somebody uses a simple group-by aggregation (e.g. <code>df.group_by('a').agg(nw.col('b').mean())</code>),   then on the pandas side we translate it to</p> <pre><code>df: pd.DataFrame\ndf.groupby(\"a\").agg({\"b\": [\"mean\"]})\n</code></pre> </li> <li> <p>if somebody passes a complex group-by aggregation, then we use <code>apply</code> and raise a <code>UserWarning</code>, warning   users of the performance penalty and advising them to refactor their code so that the aggregation they perform   ends up being a simple one.</p> </li> </ul>"},{"location":"how_it_works/#nodes","title":"Nodes","text":"<p>If we have a Narwhals expression, we can look at the operations which make it up by accessing <code>_nodes</code>:</p> <pre><code>import narwhals as nw\n\nexpr = nw.col(\"a\").abs().std(ddof=1) + nw.col(\"b\")\nprint(expr._nodes)\n</code></pre> <pre><code>(col(a), abs(), std(ddof=1), __add__(col(b)))\n</code></pre> <p>Each node represents an operation. Here, we have 4 operations:</p> <ol> <li>Given some dataframe, select column <code>'a'</code>.</li> <li>Take its absolute value.</li> <li>Take its standard deviation, with <code>ddof=1</code>.</li> <li>Sum column <code>'b'</code>.</li> </ol> <p>Let's take a look at a couple of these nodes. Let's start with the third one:</p> <pre><code>print(expr._nodes[2].as_dict())\n</code></pre> <pre><code>{'kind': &lt;ExprKind.AGGREGATION: 2&gt;, 'name': 'std', 'exprs': (), 'kwargs': {'ddof': 1}, 'str_as_lit': False, 'allow_multi_output': False}\n</code></pre> <p>This tells us a few things:</p> <ul> <li>We're performing an aggregation.</li> <li>The name of the function is <code>'std'</code>. This will be looked up in the compliant object.</li> <li>It takes keyword arguments <code>ddof=1</code>.</li> <li>We'll look at <code>exprs</code>, <code>str_as_lit</code>, and <code>allow_multi_output</code> later.</li> </ul> <p>In order for the evaluation to succeed, then <code>PandasLikeExpr</code> must have a <code>std</code> method defined on it, which takes a <code>ddof</code> argument. And this is what the <code>CompliantExpr</code> Protocol is for: so long as a backend's implementation complies with the protocol, then Narwhals will be able to unpack a <code>ExprNode</code> and turn it into a valid call.</p> <p>Let's take a look at the fourth node:</p> <pre><code>print(expr._nodes[3].as_dict())\n</code></pre> <pre><code>{'kind': &lt;ExprKind.ELEMENTWISE: 4&gt;, 'name': '__add__', 'exprs': (col(b),), 'kwargs': {}, 'str_as_lit': True, 'allow_multi_output': False}\n</code></pre> <p>Note how now, the <code>exprs</code> attribute is populated. Indeed, we are summing another expression: <code>col('b')</code>. The <code>exprs</code> parameter holds arguments which are either expressions, or should be interpreted as expressions. The <code>str_as_lit</code> parameter tells us whether string literals should be interpreted as literals (e.g. <code>lit('foo')</code>) or columns (e.g. <code>col('foo')</code>). Finally <code>allow_multi_output</code> tells us whether multi-output expressions (more on this in the next section) are allowed to appear in <code>exprs</code>.</p> <p>Note that the expression in <code>exprs</code> also has its own nodes:</p> <pre><code>print(expr._nodes[3].exprs[0]._nodes)\n</code></pre> <pre><code>(col(b),)\n</code></pre> <p>It's nodes all the way down!</p>"},{"location":"how_it_works/#expression-metadata","title":"Expression Metadata","text":"<p>Let's try printing out some compliant expressions' metadata to see what it shows us:</p> <pre><code>import narwhals as nw\n\nprint(nw.col(\"a\")._to_compliant_expr(pn)._metadata)\nprint(nw.col(\"a\").mean()._to_compliant_expr(pn)._metadata)\nprint(nw.col(\"a\").mean().over(\"b\")._to_compliant_expr(pn)._metadata)\n</code></pre> <pre><code>ExprMetadata(\n  expansion_kind: ExpansionKind.SINGLE,\n  has_windows: False,\n  n_orderable_ops: 0,\n  is_elementwise: True,\n  preserves_length: True,\n  is_scalar_like: False,\n  is_literal: False,\n  nodes: (col(a),),\n)\nExprMetadata(\n  expansion_kind: ExpansionKind.SINGLE,\n  has_windows: False,\n  n_orderable_ops: 0,\n  is_elementwise: False,\n  preserves_length: False,\n  is_scalar_like: True,\n  is_literal: False,\n  nodes: (col(a), mean()),\n)\nExprMetadata(\n  expansion_kind: ExpansionKind.SINGLE,\n  has_windows: True,\n  n_orderable_ops: 0,\n  is_elementwise: False,\n  preserves_length: True,\n  is_scalar_like: False,\n  is_literal: False,\n  nodes: (col(a), mean(), over(partition_by=['b'], order_by=[])),\n)\n</code></pre> <p>This section is all about making sense of what that all means, what the rules are, and what it enables.</p> <p>Here's a brief description of each piece of metadata:</p> <ul> <li> <p><code>expansion_kind</code>: How and whether the expression expands to multiple outputs.   This can be one of:</p> <ul> <li><code>ExpansionKind.SINGLE</code>: Only produces a single output. For example, <code>nw.col('a')</code>.</li> <li><code>ExpansionKind.MULTI_NAMED</code>: Produces multiple outputs whose names can be   determined statically, for example <code>nw.col('a', 'b')</code>.</li> <li><code>ExpansionKind.MULTI_UNNAMED</code>: Produces multiple outputs whose names depend   on the input dataframe. For example, <code>nw.nth(0, 1)</code> or <code>nw.selectors.numeric()</code>.</li> </ul> </li> <li> <p><code>has_windows</code>: Whether the expression already contains an <code>over(...)</code> statement.</p> </li> <li> <p><code>n_orderable_ops</code>: How many order-dependent operations the expression contains.</p> <p>Examples:</p> <ul> <li><code>nw.col('a')</code> contains 0 orderable operations.</li> <li><code>nw.col('a').diff()</code> contains 1 orderable operation.</li> <li><code>nw.col('a').diff().shift()</code> contains 2 orderable operation.</li> </ul> </li> <li> <p><code>is_elementwise</code>: Whether it preserves length and operates on each row independently   of the rows around it (e.g. <code>abs</code>, <code>is_null</code>, <code>round</code>, ...).</p> </li> <li><code>preserves_length</code>: Whether the output of the expression is the same length as   the dataframe it gets evaluated on.</li> <li><code>is_scalar_like</code>: Whether the output of the expression is always length-1.</li> <li><code>is_literal</code>: Whether the expression doesn't depend on any column but instead   only on literal values, like <code>nw.lit(1)</code>.</li> <li><code>nodes</code>: List of operations which this expression applies when evaluated.</li> </ul>"},{"location":"how_it_works/#chaining","title":"Chaining","text":"<p>Say we have <code>expr.expr_method()</code>. How does <code>expr</code>'s <code>ExprMetadata</code> change? This depends on <code>expr_method</code>. Details can be found in <code>narwhals/_expression_parsing</code>, in the <code>ExprMetadata.with_*</code> methods.</p>"},{"location":"how_it_works/#binary-operations-eg-nwcola-nwcolb","title":"Binary operations (e.g. <code>nw.col('a') + nw.col('b')</code>)","text":"<p>How do expression kinds change under binary operations? For example, if we do <code>expr1 + expr2</code>, then what can we say about the output kind? The rules are:</p> <ul> <li> <p>If one changes the input length (e.g. <code>Expr.drop_nulls</code>), then:</p> <ul> <li>if the other is scalar-like, then the output also changes length.</li> <li>else, we raise an error.</li> </ul> </li> <li> <p>If one preserves length and the other is scalar-like, then the output   preserves length (because of broadcasting).</p> </li> <li>If one is scalar-like but not literal and the other is scalar-like,   the output is scalar-like but not literal.</li> </ul> <p>For n-ary operations such as <code>nw.sum_horizontal</code>, the above logic is extended across inputs. For example, <code>nw.sum_horizontal(expr1, expr2, expr3)</code> is <code>LITERAL</code> if all of <code>expr1</code>, <code>expr2</code>, and <code>expr3</code> are.</p>"},{"location":"how_it_works/#you-open-a-window-to-another-window-to-another-window-to-another-window","title":"\"You open a window to another window to another window to another window\"","text":"<p>When working with <code>DataFrame</code>s, row order is well-defined, as the dataframes are assumed to be eager and in-memory. Therefore, <code>n_orderable_ops</code> is disregarded.</p> <p>When working with <code>LazyFrame</code>s, on the other hand, row order is undefined. Therefore, when evaluating an expression, <code>n_orderable_ops</code> must be exactly zero - if it's not, it means that the expression depends on physical row order, which is not allowed for <code>LazyFrame</code>s. The way that <code>n_orderable_ops</code> can change is:</p> <ul> <li>Orderable window functions like <code>diff</code> and <code>rolling_mean</code> increase <code>n_orderable_ops</code>   by 1.</li> <li>If an orderable window function is immediately followed by <code>over(order_by=...)</code>,   then <code>n_orderable_ops</code> is decreased by 1. This is the only way that   <code>n_orderable_ops</code> can decrease.</li> </ul>"},{"location":"how_it_works/#broadcasting","title":"Broadcasting","text":"<p>When performing comparisons between columns and aggregations or scalars, we operate as if the aggregation or scalar was broadcasted to the length of the whole column. For example, if we have a dataframe with values <code>{'a': [1, 2, 3]}</code> and do <code>nw.col('a') - nw.col('a').mean()</code>, then each value from column <code>'a'</code> will have its mean subtracted from it, and we will end up with values <code>[-1, 0, 1]</code>.</p> <p>Different libraries do broadcasting differently. SQL-like libraries require an empty window function for expressions (e.g. <code>a - sum(a) over ()</code>), Polars does its own broadcasting of length-1 Series, and pandas does its own broadcasting of scalars.</p> <p>Narwhals triggers a broadcast in these situations:</p> <ul> <li>In <code>select</code> when some values preserve length and others don't, e.g.   <code>df.select('a', nw.col('b').mean())</code>.</li> <li>In <code>with_columns</code>, all new columns get broadcasted to the length of the dataframe.</li> <li>In n-ary operations between expressions, such as <code>nw.col('a') + nw.col('a').mean()</code>.</li> </ul> <p>Each backend is then responsible for doing its own broadcasting, as defined in each <code>CompliantExpr.broadcast</code> method.</p>"},{"location":"how_it_works/#elementwise-push-down","title":"Elementwise push-down","text":"<p>SQL is picky about <code>over</code> operations. For example:</p> <ul> <li><code>sum(a) over (partition by b)</code> is valid.</li> <li><code>sum(abs(a)) over (partition by b)</code> is valid.</li> <li><code>abs(sum(a)) over (partition by b)</code> is not valid.</li> </ul> <p>In Polars, however, all three of</p> <ul> <li><code>pl.col('a').sum().over('b')</code> is valid.</li> <li><code>pl.col('a').abs().sum().over('b')</code> is valid.</li> <li><code>pl.col('a').sum().abs().over('b')</code> is valid.</li> </ul> <p>How can we retain Polars' level of flexibility when translating to SQL engines?</p> <p>The answer is: by rewriting expressions. Specifically, we push down <code>over</code> nodes past elementwise ones. To see this, let's try printing the Narwhals equivalent of the last expression above (the one that SQL rejects):</p> <pre><code>import narwhals as nw\n\nprint(nw.col(\"a\").sum().abs().over(\"b\"))\n</code></pre> <pre><code>col(a).sum().over(partition_by=['b'], order_by=[]).abs()\n</code></pre> <p>Note how Narwhals automatically inserted the <code>over</code> operation before the <code>abs</code> one. In other words, instead of doing</p> <ul> <li><code>sum</code> -&gt; <code>abs</code> -&gt; <code>over</code></li> </ul> <p>it did</p> <ul> <li><code>sum</code> -&gt; <code>over</code> -&gt; <code>abs</code></li> </ul> <p>thus allowing the expression to be valid for SQL engines!</p> <p>This is what we refer to as \"pushing down <code>over</code> nodes\". The idea is:</p> <ul> <li>Elementwise operations operate row-by-row and don't depend on the rows around them.</li> <li>An <code>over</code> node partitions or orders a computation.</li> <li>Therefore, an elementwise operation followed by an <code>over</code> operation is the same   as doing the <code>over</code> operation followed by that same elementwise operation!</li> </ul> <p>Note that the pushdown also applies to any arguments to the elementwise operation. For example, if we have</p> <pre><code>(nw.col(\"a\").sum() + nw.col(\"b\").sum()).over(\"c\")\n</code></pre> <p>then <code>+</code> is an elementwise operation and so can be swapped with <code>over</code>. We just need to take care to apply the <code>over</code> operation to all the arguments of <code>+</code>, so that we end up with</p> <pre><code>nw.col(\"a\").sum().over(\"c\") + nw.col(\"b\").sum().over(\"c\")\n</code></pre> <p>Info</p> <p>In general, query optimisation is out-of-scope for Narwhals. We consider this expression rewrite acceptable because:   - It's simple.   - It allows us to evaluate operations which otherwise wouldn't be allowed for certain backends.</p>"},{"location":"installation/","title":"Installation and quick start","text":""},{"location":"installation/#installation","title":"Installation","text":"UVPython's venv <p>First, ensure you have installed UV, and make sure you have created and activated a Python 3.8+ virtual environment.</p> <p>If you haven't, you can follow our setting up your environment guide. Then, run:</p> <pre><code>uv pip install narwhals\n</code></pre> <p>First, ensure you have created and activated a Python 3.8+ virtual environment.</p> <p>Then, run:</p> <pre><code>python -m pip install narwhals\n</code></pre>"},{"location":"installation/#verifying-the-installation","title":"Verifying the Installation","text":"<p>To verify the installation, start the Python REPL and execute:</p> <pre><code>import narwhals\n\nprint(narwhals.__version__)\n</code></pre> <pre><code>2.10.1\n</code></pre> <p>If you see the version number, then the installation was successful!</p>"},{"location":"installation/#quick-start","title":"Quick start","text":""},{"location":"installation/#prerequisites","title":"Prerequisites","text":"<p>Please start by following the installation instructions.</p> <p>To follow along with the examples which follow, please install the following (though note that they are not required dependencies - Narwhals only ever uses what the user passes in):</p> <ul> <li>pandas</li> <li>Polars</li> <li>PyArrow</li> </ul>"},{"location":"installation/#simple-example","title":"Simple example","text":"<p>Create a Python file <code>t.py</code> with the following content:</p> <pre><code>from __future__ import annotations\n\nimport pandas as pd\nimport polars as pl\nimport pyarrow as pa\nimport narwhals as nw\nfrom narwhals.typing import IntoFrame\n\n\ndef agnostic_get_columns(df_native: IntoFrame) -&gt; list[str]:\n    df = nw.from_native(df_native)\n    column_names = df.columns\n    return column_names\n\n\ndata = {\"a\": [1, 2, 3], \"b\": [4, 5, 6]}\ndf_pandas = pd.DataFrame(data)\ndf_polars = pl.DataFrame(data)\ntable_pa = pa.table(data)\n\nprint(\"pandas output\")\nprint(agnostic_get_columns(df_pandas))\n\nprint(\"Polars output\")\nprint(agnostic_get_columns(df_polars))\n\nprint(\"PyArrow output\")\nprint(agnostic_get_columns(table_pa))\n</code></pre> <pre><code>pandas output\n['a', 'b']\nPolars output\n['a', 'b']\nPyArrow output\n['a', 'b']\n</code></pre> <p>If you run <code>python t.py</code> then your output should look like the above. This is the simplest possible example of a dataframe-agnostic function - as we'll soon see, we can do much more advanced things.</p> <p>Let's learn about what you just did, and what Narwhals can do for you!</p> <p>Info</p> <p>These examples are using pandas, Polars, and PyArrow, however Narwhals supports other dataframe libraries (See the home page for supported libraries).</p>"},{"location":"overhead/","title":"Overhead","text":"<p>Narwhals converts Polars syntax to non-Polars dataframes.</p> <p>So, what's the overhead of running \"pandas\" vs \"pandas via Narwhals\"?</p> <p>Based on experiments we've done, the answer is: it's negligible. Sometimes it's even negative, because of how careful we are in Narwhals to avoid unnecessary copies and index resets. Here are timings from the TPC-H queries, comparing running pandas directly vs running pandas via Narwhals:</p> <p>Complete code to reproduce.</p>"},{"location":"overhead/#plotlys-story","title":"Plotly's story","text":"<p>One big difference between Plotly v5 and Plotly v6 is the handling of non-pandas inputs:</p> <ul> <li>In v5, Plotly would convert non-pandas inputs to pandas.</li> <li>In v6, Plotly operates on non-pandas inputs natively (via Narwhals).</li> </ul> <p>We expected that this would bring a noticeable performance benefit for non-pandas inputs, but that there may be some slight overhead for pandas.</p> <p>Instead, we observed that things got noticeably faster for both non-pandas inputs and for pandas ones!</p> <ul> <li>Polars plots got 3x, and sometimes even more than 10x, faster.</li> <li>pandas plots were typically no slower, but sometimes ~20% faster.</li> </ul> <p>Full details on Plotly's write-up.</p>"},{"location":"overhead/#overhead-for-duckdb-pyspark-and-other-lazy-backends","title":"Overhead for DuckDB, PySpark, and other lazy backends","text":"<p>For lazy backends, Narwhals respects the backends' laziness and always keeps everything lazy. Narwhals never evaluates a full query unless you ask it to (with <code>.collect()</code>).</p> <p>In order to mimic Polars' behaviour, there are some places where Narwhals does need to inspect dataframes' schemas, such as:</p> <ul> <li>joins</li> <li>selectors</li> <li><code>nth</code></li> <li><code>concat</code> with <code>how='vertical'</code></li> <li><code>unique</code></li> </ul> <p>This is typically cheap (as it does not require reading a full dataset into memory and can often just be done from metadata alone) but it's not free, especially if your data lives on the cloud. To minimise the overhead, when Narwhals needs to evaluate schemas or column names, it makes sure to cache them.</p>"},{"location":"resources/","title":"Resources","text":""},{"location":"resources/#sponsors-and-institutional-partners","title":"Sponsors and institutional partners","text":"<p>Narwhals is 100% independent, community-driven, and community-owned. We are extremely grateful to the following organisations for having provided some funding / development time:</p> <ul> <li>Quansight Labs</li> <li>Quansight Futures</li> <li>OpenTeams</li> <li>POSSEE initiative</li> <li>BYU-Idaho</li> </ul> <p>If you contribute to Narwhals on your organization's time, please let us know. We'd be happy to add your employer to this list!</p>"},{"location":"resources/#appears-on","title":"Appears on","text":"<p>Narwhals has been featured in several talks, podcasts, and blog posts:</p> <ul> <li> <p>Talk Python to me Podcast   Ahoy, Narwhals are bridging the data science APIs</p> </li> <li> <p>Python Bytes Podcast   Episode 402, topic #2</p> </li> <li> <p>Super Data Science: ML &amp; AI Podcast   Narwhals: For Pandas-to-Polars DataFrame Compatibility</p> </li> <li> <p>Sample Space Podcast | probabl   How Narwhals has many end users ... that never use it directly. - Marco Gorelli</p> </li> <li> <p>The Real Python Podcast   Narwhals: Expanding DataFrame Compatibility Between Libraries</p> </li> <li> <p>Pycon Lithuania   Marco Gorelli - DataFrame interoperatiblity - what's been achieved, and what comes next?</p> </li> <li> <p>Pycon Italy   How you can write a dataframe-agnostic library - Marco Gorelli</p> </li> <li> <p>Polars Blog Post   Polars has a new lightweight plotting backend</p> </li> <li> <p>Quansight Labs blog post (w/ Scikit-Lego)   How Narwhals and scikit-lego came together to achieve dataframe-agnosticism</p> </li> </ul>"},{"location":"security/","title":"Security","text":"<p>Given that Narwhals can only work if people trust it, we recognise the importance of following good security practices. Here are some practices we follow:</p> <ul> <li>We publish to PyPI via trusted publishing and are PEP740-compliant.</li> <li>We don't use <code>pull_request_target</code> in any CI job.</li> <li>The release CI job can only be triggered for tag pushes, and only   Narwhals members with release permissions (see below) can push tags.</li> <li>All members of <code>narwhals-dev</code> are required to have two-factor authentication   enabled.</li> <li>There are no binary or opaque files in the Narwhals repository.</li> <li> <p>Release permissions are only given to people who satisfy all of the following:</p> <ul> <li>Have met the original author in real life on multiple days.</li> <li>Have made significant contributions to Narwhals.</li> <li>Give off good vibes. This is hard to rigorously define, but it's there so we     can refuse anyone who, despite satisfying the above two criteria, we don't     feel like we can trust.</li> <li>There are fewer than 5 active people with release permissions. That is     to say, even if someone satisfies all of the above, if there are already 5     people with release permissions, then we will not be adding any more (though     you may still be added to <code>narwhals-dev</code> and get permission to merge pull     requests which you believe are ready). Note that we already meet that limit.</li> </ul> </li> </ul>"},{"location":"this/","title":"The Zen of Narwhals","text":"<p>The well famous Python easter egg <code>import this</code> will reveal The Zen of Python (PEP 20).</p> <p>Narwhals took inspiration from this and created its own Zen.</p> <pre><code>import narwhals.this\n</code></pre> <pre><code>\u28ff\u28ff\u28ff\u28ff\u28ff\u2818\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff THE ZEN OF NARWHALS\n\u28ff\u28ff\u28ff\u28ff\u28ff\u2820\u28b9\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff Keep it simple\n\u28ff\u28ff\u28ff\u28ff\u28ff\u2840\u2844\u28bf\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff Move slowly and keep things working\n\u28ff\u28ff\u28ff\u28ff\u28ff\u2847\u287c\u2858\u281b\u283f\u283f\u283f\u28bf\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff A good API is an honest one\n\u28ff\u28ff\u28ff\u287f\u28eb\u2844\u283e\u28e3\u2839\u28ff\u28ff\u28ff\u28f6\u28ee\u28d9\u283b\u28bf\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff Yes, that needs documenting\n\u28ff\u28ff\u288b\u28f4\u28ff\u28f7\u28ec\u28ed\u28fe\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28e6\u2859\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff People learn better from examples\n\u28ff\u2883\u28fe\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28f7\u284c\u28bf\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff   than from explanations\u2800\n\u284f\u2800\u28b0\u2804\u28bb\u28ff\u28ff\u28ff\u28ff\u287f\u280b\u2889\u283b\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u285c\u28ff\u28ff\u287f\u2881\u28bb\u28ff\u28ff\u28ff\u28ff\u28ff If in doubt, better to say 'no'\n\u2847\u28cc\u28c0\u28e0\u28fe\u28ff\u28ff\u28ff\u28ff\u28c7\u2836\u2809\u2881\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28e7\u2879\u28ff\u2847\u28ff\u28e7\u283b\u283f\u283f\u283f\u283f   than to risk causing a commotion\u2800\n\u2867\u28b9\u28ff\u28ff\u28ff\u28dc\u28df\u28f8\u28ff\u28ff\u28f7\u28f6\u28ff\u287f\u28ff\u28ff\u28dd\u28bf\u28ff\u28ff\u28f7\u28ec\u28e5\u28ff\u28ff\u28ff\u28ff\u28ff\u285f\u28f0 Yes, we need a test for that\n\u28a1\u28c6\u28bb\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28e7\u2859\u28ff\u28ff\u2847\u28ff\u28ff\u28ff\u28ff\u281f\u28cb\u28ed\u28db\u283b\u28cb\u28f4\u28ff If you want users  \n\u28f6\u28e4\u28e4\u28d9\u283b\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28f7\u28e6\u28cd\u28e1\u28ff\u287f\u288b\u28f4\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff   you need good docs\u2800\n\u28ff\u28ff\u28ff\u28ff\u28ff\u28f6\u28ec\u28d9\u28db\u283b\u283f\u283f\u283f\u283f\u283f\u281f\u28db\u28e9\u28e5\u28f6\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff Our code is not irreplaceable\n</code></pre>"},{"location":"why/","title":"Why?","text":"<p>You may think that pandas, Polars, and all dataframe libraries are quite similar. But are they really?</p> <p>For example, do the following produce the same output?</p> <pre><code>import pandas as pd\nimport polars as pl\n\nprint(3 in pd.Series([1, 2, 3]))\nprint(3 in pl.Series([1, 2, 3]))\n</code></pre> <p>Try it out and see \ud83d\ude09</p> <p>Spoiler alert: they don't. pandas checks if <code>3</code> is in the index, Polars checks if it's in the values.</p> <p>For another example, try running the code below - note how the outputs have different column names after the join!</p> <pre><code>pd_df_left = pd.DataFrame({\"a\": [1, 2, 3], \"b\": [4, 5, 6]})\npd_df_right = pd.DataFrame({\"a\": [1, 2, 3], \"c\": [4, 5, 6]})\npd_left_merge = pd_df_left.merge(pd_df_right, left_on=\"b\", right_on=\"c\", how=\"left\")\n\npl_df_left = pl.DataFrame({\"a\": [1, 2, 3], \"b\": [4, 5, 6]})\npl_df_right = pl.DataFrame({\"a\": [1, 2, 3], \"c\": [4, 5, 6]})\npl_left_merge = pl_df_left.join(pl_df_right, left_on=\"b\", right_on=\"c\", how=\"left\")\n\nprint(pd_left_merge.columns)\nprint(pl_left_merge.columns)\n</code></pre> <p>There are several such subtle difference between the libraries. Writing dataframe-agnostic code is hard!</p> <p>But by having a unified, simple, and predictable API, you can focus on behaviour rather than on subtle implementation differences.</p> <p>Furthermore, both pandas and Polars frequently deprecate behaviour. Narwhals handles this for you by testing against nightly builds of both libraries and handling backwards compatibility internally (so you don't have to!).</p>"},{"location":"api-reference/","title":"API Reference","text":"<ul> <li>Top-level functions</li> <li>narwhals.DataFrame</li> <li>narwhals.Expr</li> <li>narwhals.Expr.cat</li> <li>narwhals.Expr.dt</li> <li>narwhals.Expr.list</li> <li>narwhals.Expr.name</li> <li>narwhals.Expr.str</li> <li>narwhals.Expr.struct</li> <li>narwhals.GroupBy</li> <li>narwhals.LazyGroupBy</li> <li>narwhals.LazyFrame</li> <li>narwhals.Schema</li> <li>narwhals.Series</li> <li>narwhals.Series.cat</li> <li>narwhals.Series.dt</li> <li>narwhals.Series.list</li> <li>narwhals.Series.str</li> <li>narwhals.Series.struct</li> <li>narwhals.dependencies</li> <li>narwhals.Implementation</li> <li>narwhals.dtypes</li> <li>narwhals.exceptions</li> <li>narwhals.selectors</li> <li>narwhals.typing</li> <li>narwhals.utils</li> </ul>"},{"location":"api-reference/dataframe/","title":"<code>narwhals.DataFrame</code>","text":"<p>Narwhals DataFrame, backed by a native eager dataframe.</p> Warning <p>This class is not meant to be instantiated directly - instead:</p> <ul> <li> <p>If the native object is a eager dataframe from one of the supported     backend (e.g. pandas.DataFrame, polars.DataFrame, pyarrow.Table),     you can use <code>narwhals.from_native</code>:     <pre><code>narwhals.from_native(native_dataframe)\nnarwhals.from_native(native_dataframe, eager_only=True)\n</code></pre></p> </li> <li> <p>If the object is a dictionary of column names and generic sequences mapping     (e.g. <code>dict[str, list]</code>), you can create a DataFrame via     <code>narwhals.from_dict</code>:     <pre><code>narwhals.from_dict(\n    data={\"a\": [1, 2, 3]},\n    backend=narwhals.get_native_namespace(another_object),\n)\n</code></pre></p> </li> </ul>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.columns","title":"columns  <code>property</code>","text":"<pre><code>columns: list[str]\n</code></pre> <p>Get column names.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pa.table({\"foo\": [1, 2], \"bar\": [6.0, 7.0]})\n&gt;&gt;&gt; nw.from_native(df_native).columns\n['foo', 'bar']\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.implementation","title":"implementation  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>implementation: _Implementation = _Implementation()\n</code></pre> <p>Return <code>narwhals.Implementation</code> of native frame.</p> <p>This can be useful when you need to use special-casing for features outside of Narwhals' scope - for example, when dealing with pandas' Period Dtype.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [1, 2, 3]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.implementation\n&lt;Implementation.PANDAS: 'pandas'&gt;\n&gt;&gt;&gt; df.implementation.is_pandas()\nTrue\n&gt;&gt;&gt; df.implementation.is_pandas_like()\nTrue\n&gt;&gt;&gt; df.implementation.is_polars()\nFalse\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.schema","title":"schema  <code>property</code>","text":"<pre><code>schema: Schema\n</code></pre> <p>Get an ordered mapping of column names to their data type.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pa.table({\"foo\": [1, 2], \"bar\": [6.0, 7.0]})\n&gt;&gt;&gt; nw.from_native(df_native).schema\nSchema({'foo': Int64, 'bar': Float64})\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.shape","title":"shape  <code>property</code>","text":"<pre><code>shape: tuple[int, int]\n</code></pre> <p>Get the shape of the DataFrame.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"foo\": [1, 2]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.shape\n(2, 1)\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.__arrow_c_stream__","title":"__arrow_c_stream__","text":"<pre><code>__arrow_c_stream__(\n    requested_schema: object | None = None,\n) -&gt; object\n</code></pre> <p>Export a DataFrame via the Arrow PyCapsule Interface.</p> <ul> <li>if the underlying dataframe implements the interface, it'll return that</li> <li>else, it'll call <code>to_arrow</code> and then defer to PyArrow's implementation</li> </ul> <p>See PyCapsule Interface for more.</p>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(\n    item: tuple[SingleIndexSelector, SingleColSelector],\n) -&gt; Any\n</code></pre><pre><code>__getitem__(\n    item: (\n        str | tuple[MultiIndexSelector, SingleColSelector]\n    ),\n) -&gt; Series[Any]\n</code></pre><pre><code>__getitem__(\n    item: (\n        SingleIndexSelector\n        | MultiIndexSelector\n        | MultiColSelector\n        | tuple[SingleIndexSelector, MultiColSelector]\n        | tuple[MultiIndexSelector, MultiColSelector]\n    ),\n) -&gt; Self\n</code></pre> <pre><code>__getitem__(\n    item: (\n        SingleIndexSelector\n        | SingleColSelector\n        | MultiColSelector\n        | MultiIndexSelector\n        | tuple[SingleIndexSelector, SingleColSelector]\n        | tuple[SingleIndexSelector, MultiColSelector]\n        | tuple[MultiIndexSelector, SingleColSelector]\n        | tuple[MultiIndexSelector, MultiColSelector]\n    ),\n) -&gt; Series[Any] | Self | Any\n</code></pre> <p>Extract column or slice of DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>SingleIndexSelector | SingleColSelector | MultiColSelector | MultiIndexSelector | tuple[SingleIndexSelector, SingleColSelector] | tuple[SingleIndexSelector, MultiColSelector] | tuple[MultiIndexSelector, SingleColSelector] | tuple[MultiIndexSelector, MultiColSelector]</code> <p>How to slice dataframe. What happens depends on what is passed. It's easiest to explain by example. Suppose we have a Dataframe <code>df</code></p> <ul> <li><code>df['a']</code> extracts column <code>'a'</code> and returns a <code>Series</code>.</li> <li><code>df[0:2]</code> extracts the first two rows and returns a <code>DataFrame</code>.</li> <li><code>df[0:2, 'a']</code> extracts the first two rows from column <code>'a'</code> and returns     a <code>Series</code>.</li> <li><code>df[0:2, 0]</code> extracts the first two rows from the first column and returns     a <code>Series</code>.</li> <li><code>df[[0, 1], [0, 1, 2]]</code> extracts the first two rows and the first three columns     and returns a <code>DataFrame</code></li> <li><code>df[:, [0, 1, 2]]</code> extracts all rows from the first three columns and returns a   <code>DataFrame</code>.</li> <li><code>df[:, ['a', 'c']]</code> extracts all rows and columns <code>'a'</code> and <code>'c'</code> and returns a   <code>DataFrame</code>.</li> <li><code>df[['a', 'c']]</code> extracts all rows and columns <code>'a'</code> and <code>'c'</code> and returns a   <code>DataFrame</code>.</li> <li><code>df[0: 2, ['a', 'c']]</code> extracts the first two rows and columns <code>'a'</code> and <code>'c'</code> and     returns a <code>DataFrame</code></li> <li><code>df[:, 0: 2]</code> extracts all rows from the first two columns and returns a <code>DataFrame</code></li> <li><code>df[:, 'a': 'c']</code> extracts all rows and all columns positioned between <code>'a'</code> and <code>'c'</code> inclusive and returns a <code>DataFrame</code>. For example, if the columns are     <code>'a', 'd', 'c', 'b'</code>, then that would extract columns <code>'a'</code>, <code>'d'</code>, and <code>'c'</code>.</li> </ul> required Notes <ul> <li>Integers are always interpreted as positions</li> <li>Strings are always interpreted as column names.</li> </ul> <p>In contrast with Polars, pandas allows non-string column names. If you don't know whether the column name you're trying to extract is definitely a string (e.g. <code>df[df.columns[0]]</code>) then you should use <code>DataFrame.get_column</code> instead.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [1, 2]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df[\"a\"].to_native()\n0    1\n1    2\nName: a, dtype: int64\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.clone","title":"clone","text":"<pre><code>clone() -&gt; Self\n</code></pre> <p>Create a copy of this DataFrame.</p>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.collect_schema","title":"collect_schema","text":"<pre><code>collect_schema() -&gt; Schema\n</code></pre> <p>Get an ordered mapping of column names to their data type.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pa.table({\"foo\": [1, 2], \"bar\": [6.0, 7.0]})\n&gt;&gt;&gt; nw.from_native(df_native).collect_schema()\nSchema({'foo': Int64, 'bar': Float64})\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.drop","title":"drop","text":"<pre><code>drop(\n    *columns: str | Iterable[str], strict: bool = True\n) -&gt; Self\n</code></pre> <p>Remove columns from the dataframe.</p> <p>Parameters:</p> Name Type Description Default <code>*columns</code> <code>str | Iterable[str]</code> <p>Names of the columns that should be removed from the dataframe.</p> <code>()</code> <code>strict</code> <code>bool</code> <p>Validate that all column names exist in the schema and throw an exception if a column name does not exist in the schema.</p> <code>True</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame(\n...     {\"foo\": [1, 2], \"bar\": [6.0, 7.0], \"ham\": [\"a\", \"b\"]}\n... )\n&gt;&gt;&gt; nw.from_native(df_native).drop(\"ham\").to_native()\n   foo  bar\n0    1  6.0\n1    2  7.0\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.drop_nulls","title":"drop_nulls","text":"<pre><code>drop_nulls(subset: str | list[str] | None = None) -&gt; Self\n</code></pre> <p>Drop rows that contain null values.</p> <p>Parameters:</p> Name Type Description Default <code>subset</code> <code>str | list[str] | None</code> <p>Column name(s) for which null values are considered. If set to None (default), use all columns.</p> <code>None</code> Notes <p>pandas handles null values differently from Polars and PyArrow. See null_handling for reference.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pa.table({\"a\": [1.0, None], \"ba\": [1.0, 2.0]})\n&gt;&gt;&gt; nw.from_native(df_native).drop_nulls().to_native()\npyarrow.Table\na: double\nba: double\n----\na: [[1]]\nba: [[1]]\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.estimated_size","title":"estimated_size","text":"<pre><code>estimated_size(unit: SizeUnit = 'b') -&gt; int | float\n</code></pre> <p>Return an estimation of the total (heap) allocated size of the <code>DataFrame</code>.</p> <p>Estimated size is given in the specified unit (bytes by default).</p> <p>Parameters:</p> Name Type Description Default <code>unit</code> <code>SizeUnit</code> <p>'b', 'kb', 'mb', 'gb', 'tb', 'bytes', 'kilobytes', 'megabytes', 'gigabytes', or 'terabytes'.</p> <code>'b'</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pa.table({\"foo\": [1, 2], \"bar\": [6.0, 7.0]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.estimated_size()\n32\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.explode","title":"explode","text":"<pre><code>explode(\n    columns: str | Sequence[str], *more_columns: str\n) -&gt; Self\n</code></pre> <p>Explode the dataframe to long format by exploding the given columns.</p> Notes <p>It is possible to explode multiple columns only if these columns must have matching element counts.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>str | Sequence[str]</code> <p>Column names. The underlying columns being exploded must be of the <code>List</code> data type.</p> required <code>*more_columns</code> <code>str</code> <p>Additional names of columns to explode, specified as positional arguments.</p> <code>()</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = {\"a\": [\"x\", \"y\"], \"b\": [[1, 2], [3]]}\n&gt;&gt;&gt; df_native = pl.DataFrame(data)\n&gt;&gt;&gt; nw.from_native(df_native).explode(\"b\").to_native()\nshape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 str \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 x   \u2506 1   \u2502\n\u2502 x   \u2506 2   \u2502\n\u2502 y   \u2506 3   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.filter","title":"filter","text":"<pre><code>filter(\n    *predicates: IntoExpr | Iterable[IntoExpr] | list[bool],\n    **constraints: Any\n) -&gt; Self\n</code></pre> <p>Filter the rows in the DataFrame based on one or more predicate expressions.</p> <p>The original order of the remaining rows is preserved.</p> <p>Parameters:</p> Name Type Description Default <code>*predicates</code> <code>IntoExpr | Iterable[IntoExpr] | list[bool]</code> <p>Expression(s) that evaluates to a boolean Series. Can also be a boolean list(s).</p> <code>()</code> <code>**constraints</code> <code>Any</code> <p>Column filters; use <code>name = value</code> to filter columns by the supplied value. Each constraint will behave the same as <code>nw.col(name).eq(value)</code>, and will be implicitly joined with the other filter conditions using &amp;.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame(\n...     {\"foo\": [1, 2, 3], \"bar\": [6, 7, 8], \"ham\": [\"a\", \"b\", \"c\"]}\n... )\n</code></pre> <p>Filter on one condition</p> <pre><code>&gt;&gt;&gt; nw.from_native(df_native).filter(nw.col(\"foo\") &gt; 1).to_native()\n   foo  bar ham\n1    2    7   b\n2    3    8   c\n</code></pre> <p>Filter on multiple conditions with implicit <code>&amp;</code></p> <pre><code>&gt;&gt;&gt; nw.from_native(df_native).filter(\n...     nw.col(\"foo\") &lt; 3, nw.col(\"ham\") == \"a\"\n... ).to_native()\n   foo  bar ham\n0    1    6   a\n</code></pre> <p>Filter on multiple conditions with <code>|</code></p> <pre><code>&gt;&gt;&gt; nw.from_native(df_native).filter(\n...     (nw.col(\"foo\") == 1) | (nw.col(\"ham\") == \"c\")\n... ).to_native()\n   foo  bar ham\n0    1    6   a\n2    3    8   c\n</code></pre> <p>Filter using <code>**kwargs</code> syntax</p> <pre><code>&gt;&gt;&gt; nw.from_native(df_native).filter(foo=2, ham=\"b\").to_native()\n   foo  bar ham\n1    2    7   b\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.from_arrow","title":"from_arrow  <code>classmethod</code>","text":"<pre><code>from_arrow(\n    native_frame: IntoArrowTable,\n    *,\n    backend: IntoBackend[EagerAllowed]\n) -&gt; DataFrame[Any]\n</code></pre> <p>Construct a DataFrame from an object which supports the PyCapsule Interface.</p> <p>Parameters:</p> Name Type Description Default <code>native_frame</code> <code>IntoArrowTable</code> <p>Object which implements <code>__arrow_c_stream__</code>.</p> required <code>backend</code> <code>IntoBackend[EagerAllowed]</code> <p>specifies which eager backend instantiate to.</p> <p><code>backend</code> can be specified in various ways</p> <ul> <li>As <code>Implementation.&lt;BACKEND&gt;</code> with <code>BACKEND</code> being <code>PANDAS</code>, <code>PYARROW</code>,     <code>POLARS</code>, <code>MODIN</code> or <code>CUDF</code>.</li> <li>As a string: <code>\"pandas\"</code>, <code>\"pyarrow\"</code>, <code>\"polars\"</code>, <code>\"modin\"</code> or <code>\"cudf\"</code>.</li> <li>Directly as a module <code>pandas</code>, <code>pyarrow</code>, <code>polars</code>, <code>modin</code> or <code>cudf</code>.</li> </ul> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [1, 2], \"b\": [4.2, 5.1]})\n&gt;&gt;&gt; nw.DataFrame.from_arrow(df_native, backend=\"polars\")\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|  shape: (2, 2)   |\n|  \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510   |\n|  \u2502 a   \u2506 b   \u2502   |\n|  \u2502 --- \u2506 --- \u2502   |\n|  \u2502 i64 \u2506 f64 \u2502   |\n|  \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561   |\n|  \u2502 1   \u2506 4.2 \u2502   |\n|  \u2502 2   \u2506 5.1 \u2502   |\n|  \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518   |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(\n    data: Mapping[str, Any],\n    schema: (\n        IntoSchema | Mapping[str, DType | None] | None\n    ) = None,\n    *,\n    backend: IntoBackend[EagerAllowed] | None = None\n) -&gt; DataFrame[Any]\n</code></pre> <p>Instantiate DataFrame from dictionary.</p> <p>Indexes (if present, for pandas-like backends) are aligned following the left-hand-rule.</p> Notes <p>For pandas-like dataframes, conversion to schema is applied after dataframe creation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Mapping[str, Any]</code> <p>Dictionary to create DataFrame from.</p> required <code>schema</code> <code>IntoSchema | Mapping[str, DType | None] | None</code> <p>The DataFrame schema as Schema or dict of {name: type}. If not specified, the schema will be inferred by the native library. If any <code>dtype</code> is <code>None</code>, the data type for that column will be inferred by the native library.</p> <code>None</code> <code>backend</code> <code>IntoBackend[EagerAllowed] | None</code> <p>specifies which eager backend instantiate to. Only necessary if inputs are not Narwhals Series.</p> <p><code>backend</code> can be specified in various ways</p> <ul> <li>As <code>Implementation.&lt;BACKEND&gt;</code> with <code>BACKEND</code> being <code>PANDAS</code>, <code>PYARROW</code>,     <code>POLARS</code>, <code>MODIN</code> or <code>CUDF</code>.</li> <li>As a string: <code>\"pandas\"</code>, <code>\"pyarrow\"</code>, <code>\"polars\"</code>, <code>\"modin\"</code> or <code>\"cudf\"</code>.</li> <li>Directly as a module <code>pandas</code>, <code>pyarrow</code>, <code>polars</code>, <code>modin</code> or <code>cudf</code>.</li> </ul> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = {\"c\": [5, 2], \"d\": [1, 4]}\n&gt;&gt;&gt; nw.DataFrame.from_dict(data, backend=\"pandas\")\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|        c  d      |\n|     0  5  1      |\n|     1  2  4      |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.from_dicts","title":"from_dicts  <code>classmethod</code>","text":"<pre><code>from_dicts(\n    data: Sequence[Mapping[str, Any]],\n    schema: (\n        IntoSchema | Mapping[str, DType | None] | None\n    ) = None,\n    *,\n    backend: IntoBackend[EagerAllowed]\n) -&gt; DataFrame[Any]\n</code></pre> <p>Instantiate DataFrame from a sequence of dictionaries representing rows.</p> Notes <p>For pandas-like dataframes, conversion to schema is applied after dataframe creation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Sequence[Mapping[str, Any]]</code> <p>Sequence with dictionaries mapping column name to value.</p> required <code>schema</code> <code>IntoSchema | Mapping[str, DType | None] | None</code> <p>The DataFrame schema as Schema or dict of {name: type}. If not specified, the schema will be inferred by the native library. If any <code>dtype</code> is <code>None</code>, the data type for that column will be inferred by the native library.</p> <code>None</code> <code>backend</code> <code>IntoBackend[EagerAllowed]</code> <p>Specifies which eager backend instantiate to.</p> <p><code>backend</code> can be specified in various ways</p> <ul> <li>As <code>Implementation.&lt;BACKEND&gt;</code> with <code>BACKEND</code> being <code>PANDAS</code>, <code>PYARROW</code>,     <code>POLARS</code>, <code>MODIN</code> or <code>CUDF</code>.</li> <li>As a string: <code>\"pandas\"</code>, <code>\"pyarrow\"</code>, <code>\"polars\"</code>, <code>\"modin\"</code> or <code>\"cudf\"</code>.</li> <li>Directly as a module <code>pandas</code>, <code>pyarrow</code>, <code>polars</code>, <code>modin</code> or <code>cudf</code>.</li> </ul> required Tip <p>If you expect non-uniform keys in <code>data</code>, consider passing <code>schema</code> for more consistent results, as inference varies between backends:</p> <ul> <li>pandas uses all rows</li> <li>polars uses the first 100 rows</li> <li>pyarrow uses only the first row</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = [\n...     {\"item\": \"apple\", \"weight\": 80, \"price\": 0.60},\n...     {\"item\": \"egg\", \"weight\": 55, \"price\": 0.40},\n... ]\n&gt;&gt;&gt; nw.DataFrame.from_dicts(data, backend=\"polars\")\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|    Narwhals DataFrame    |\n|--------------------------|\n|shape: (2, 3)             |\n|\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510|\n|\u2502 item  \u2506 weight \u2506 price \u2502|\n|\u2502 ---   \u2506 ---    \u2506 ---   \u2502|\n|\u2502 str   \u2506 i64    \u2506 f64   \u2502|\n|\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561|\n|\u2502 apple \u2506 80     \u2506 0.6   \u2502|\n|\u2502 egg   \u2506 55     \u2506 0.4   \u2502|\n|\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.from_numpy","title":"from_numpy  <code>classmethod</code>","text":"<pre><code>from_numpy(\n    data: _2DArray,\n    schema: IntoSchema | Sequence[str] | None = None,\n    *,\n    backend: IntoBackend[EagerAllowed]\n) -&gt; DataFrame[Any]\n</code></pre> <p>Construct a DataFrame from a NumPy ndarray.</p> Notes <p>Only row orientation is currently supported.</p> <p>For pandas-like dataframes, conversion to schema is applied after dataframe creation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>_2DArray</code> <p>Two-dimensional data represented as a NumPy ndarray.</p> required <code>schema</code> <code>IntoSchema | Sequence[str] | None</code> <p>The DataFrame schema as Schema, dict of {name: type}, or a sequence of str.</p> <code>None</code> <code>backend</code> <code>IntoBackend[EagerAllowed]</code> <p>specifies which eager backend instantiate to.</p> <p><code>backend</code> can be specified in various ways</p> <ul> <li>As <code>Implementation.&lt;BACKEND&gt;</code> with <code>BACKEND</code> being <code>PANDAS</code>, <code>PYARROW</code>,     <code>POLARS</code>, <code>MODIN</code> or <code>CUDF</code>.</li> <li>As a string: <code>\"pandas\"</code>, <code>\"pyarrow\"</code>, <code>\"polars\"</code>, <code>\"modin\"</code> or <code>\"cudf\"</code>.</li> <li>Directly as a module <code>pandas</code>, <code>pyarrow</code>, <code>polars</code>, <code>modin</code> or <code>cudf</code>.</li> </ul> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; arr = np.array([[5, 2, 1], [1, 4, 3]])\n&gt;&gt;&gt; schema = {\"c\": nw.Int16(), \"d\": nw.Float32(), \"e\": nw.Int8()}\n&gt;&gt;&gt; nw.DataFrame.from_numpy(arr, schema=schema, backend=\"polars\")\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame |\n|-------------------|\n|shape: (2, 3)      |\n|\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510|\n|\u2502 c   \u2506 d   \u2506 e   \u2502|\n|\u2502 --- \u2506 --- \u2506 --- \u2502|\n|\u2502 i16 \u2506 f32 \u2506 i8  \u2502|\n|\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561|\n|\u2502 5   \u2506 2.0 \u2506 1   \u2502|\n|\u2502 1   \u2506 4.0 \u2506 3   \u2502|\n|\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.gather_every","title":"gather_every","text":"<pre><code>gather_every(n: int, offset: int = 0) -&gt; Self\n</code></pre> <p>Take every nth row in the DataFrame and return as a new DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Gather every n-th row.</p> required <code>offset</code> <code>int</code> <p>Starting index.</p> <code>0</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pa.table({\"foo\": [1, None, 2, 3]})\n&gt;&gt;&gt; nw.from_native(df_native).gather_every(2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|  pyarrow.Table   |\n|  foo: int64      |\n|  ----            |\n|  foo: [[1,2]]    |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.get_column","title":"get_column","text":"<pre><code>get_column(name: str) -&gt; Series[Any]\n</code></pre> <p>Get a single column by name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The column name as a string.</p> required Notes <p>Although <code>name</code> is typed as <code>str</code>, pandas does allow non-string column names, and they will work when passed to this function if the <code>narwhals.DataFrame</code> is backed by a pandas dataframe with non-string columns. This function can only be used to extract a column by name, so there is no risk of ambiguity.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [1, 2]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.get_column(\"a\").to_native()\n0    1\n1    2\nName: a, dtype: int64\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.group_by","title":"group_by","text":"<pre><code>group_by(\n    *keys: IntoExpr | Iterable[IntoExpr],\n    drop_null_keys: Literal[False] = ...\n) -&gt; GroupBy[Self]\n</code></pre><pre><code>group_by(\n    *keys: str | Iterable[str],\n    drop_null_keys: Literal[True]\n) -&gt; GroupBy[Self]\n</code></pre> <pre><code>group_by(\n    *keys: IntoExpr | Iterable[IntoExpr],\n    drop_null_keys: bool = False\n) -&gt; GroupBy[Self]\n</code></pre> <p>Start a group by operation.</p> <p>Parameters:</p> Name Type Description Default <code>*keys</code> <code>IntoExpr | Iterable[IntoExpr]</code> <p>Column(s) to group by. Accepts expression input. Strings are parsed as column names.</p> <code>()</code> <code>drop_null_keys</code> <code>bool</code> <p>if True, then groups where any key is null won't be included in the result.</p> <code>False</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame(\n...     {\n...         \"a\": [\"a\", \"b\", \"a\", \"b\", \"c\"],\n...         \"b\": [1, 2, 1, 3, 3],\n...         \"c\": [5, 4, 3, 2, 1],\n...     }\n... )\n</code></pre> <p>Group by one column and compute the sum of another column</p> <pre><code>&gt;&gt;&gt; nw.from_native(df_native, eager_only=True).group_by(\"a\").agg(\n...     nw.col(\"b\").sum()\n... ).sort(\"a\").to_native()\n   a  b\n0  a  2\n1  b  5\n2  c  3\n</code></pre> <p>Group by multiple columns and compute the max of another column</p> <pre><code>&gt;&gt;&gt; (\n...     nw.from_native(df_native, eager_only=True)\n...     .group_by([\"a\", \"b\"])\n...     .agg(nw.max(\"c\"))\n...     .sort(\"a\", \"b\")\n...     .to_native()\n... )\n   a  b  c\n0  a  1  5\n1  b  2  4\n2  b  3  2\n3  c  3  1\n</code></pre> <p>Expressions are also accepted.</p> <pre><code>&gt;&gt;&gt; nw.from_native(df_native, eager_only=True).group_by(\n...     \"a\", nw.col(\"b\") // 2\n... ).agg(nw.col(\"c\").mean()).to_native()\n   a  b    c\n0  a  0  4.0\n1  b  1  3.0\n2  c  1  1.0\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.head","title":"head","text":"<pre><code>head(n: int = 5) -&gt; Self\n</code></pre> <p>Get the first <code>n</code> rows.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Number of rows to return. If a negative value is passed, return all rows except the last <code>abs(n)</code>.</p> <code>5</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [1, 2], \"b\": [0.5, 4.0]})\n&gt;&gt;&gt; nw.from_native(df_native).head(1).to_native()\n   a    b\n0  1  0.5\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.is_duplicated","title":"is_duplicated","text":"<pre><code>is_duplicated() -&gt; Series[Any]\n</code></pre> <p>Get a mask of all duplicated rows in this DataFrame.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"foo\": [2, 2, 2], \"bar\": [6.0, 6.0, 7.0]})\n&gt;&gt;&gt; nw.from_native(df_native).is_duplicated()\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals Series|\n|---------------|\n|  0     True   |\n|  1     True   |\n|  2    False   |\n|  dtype: bool  |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.is_empty","title":"is_empty","text":"<pre><code>is_empty() -&gt; bool\n</code></pre> <p>Check if the dataframe is empty.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"foo\": [2, 2, 2], \"bar\": [6.0, 6.0, 7.0]})\n&gt;&gt;&gt; nw.from_native(df_native).is_empty()\nFalse\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.is_unique","title":"is_unique","text":"<pre><code>is_unique() -&gt; Series[Any]\n</code></pre> <p>Get a mask of all unique rows in this DataFrame.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"foo\": [2, 2, 2], \"bar\": [6.0, 6.0, 7.0]})\n&gt;&gt;&gt; nw.from_native(df_native).is_unique()\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals Series|\n|---------------|\n|  0    False   |\n|  1    False   |\n|  2     True   |\n|  dtype: bool  |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.item","title":"item","text":"<pre><code>item(\n    row: int | None = None, column: int | str | None = None\n) -&gt; Any\n</code></pre> <p>Return the DataFrame as a scalar, or return the element at the given row/column.</p> <p>Parameters:</p> Name Type Description Default <code>row</code> <code>int | None</code> <p>The n-th row.</p> <code>None</code> <code>column</code> <code>int | str | None</code> <p>The column selected via an integer or a string (column name).</p> <code>None</code> Notes <p>If row/col not provided, this is equivalent to df[0,0], with a check that the shape is (1,1). With row/col, this is equivalent to df[row,col].</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pa.table({\"foo\": [1, None], \"bar\": [2, 3]})\n&gt;&gt;&gt; nw.from_native(df_native).item(0, 1)\n2\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.iter_columns","title":"iter_columns","text":"<pre><code>iter_columns() -&gt; Iterator[Series[Any]]\n</code></pre> <p>Returns an iterator over the columns of this DataFrame.</p> <p>Yields:</p> Type Description <code>Series[Any]</code> <p>A Narwhals Series, backed by a native series.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"foo\": [1, 2], \"bar\": [6.0, 7.0]})\n&gt;&gt;&gt; iter_columns = nw.from_native(df_native).iter_columns()\n&gt;&gt;&gt; next(iter_columns)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|    Narwhals Series    |\n|-----------------------|\n|0    1                 |\n|1    2                 |\n|Name: foo, dtype: int64|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; next(iter_columns)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|     Narwhals Series     |\n|-------------------------|\n|0    6.0                 |\n|1    7.0                 |\n|Name: bar, dtype: float64|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.iter_rows","title":"iter_rows","text":"<pre><code>iter_rows(\n    *, named: Literal[False] = ..., buffer_size: int = ...\n) -&gt; Iterator[tuple[Any, ...]]\n</code></pre><pre><code>iter_rows(\n    *, named: Literal[True], buffer_size: int = ...\n) -&gt; Iterator[dict[str, Any]]\n</code></pre><pre><code>iter_rows(\n    *, named: bool, buffer_size: int = ...\n) -&gt; Iterator[tuple[Any, ...]] | Iterator[dict[str, Any]]\n</code></pre> <pre><code>iter_rows(\n    *, named: bool = False, buffer_size: int = 512\n) -&gt; Iterator[tuple[Any, ...]] | Iterator[dict[str, Any]]\n</code></pre> <p>Returns an iterator over the DataFrame of rows of python-native values.</p> <p>Parameters:</p> Name Type Description Default <code>named</code> <code>bool</code> <p>By default, each row is returned as a tuple of values given in the same order as the frame columns. Setting named=True will return rows of dictionaries instead.</p> <code>False</code> <code>buffer_size</code> <code>int</code> <p>Determines the number of rows that are buffered internally while iterating over the data. See https://docs.pola.rs/api/python/stable/reference/dataframe/api/polars.DataFrame.iter_rows.html</p> <code>512</code> Notes <p>cuDF doesn't support this method.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pa.table({\"foo\": [1, 2], \"bar\": [6.0, 7.0]})\n&gt;&gt;&gt; iter_rows = nw.from_native(df_native).iter_rows()\n&gt;&gt;&gt; next(iter_rows)\n(1, 6.0)\n&gt;&gt;&gt; next(iter_rows)\n(2, 7.0)\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.join","title":"join","text":"<pre><code>join(\n    other: Self,\n    on: str | list[str] | None = None,\n    how: JoinStrategy = \"inner\",\n    *,\n    left_on: str | list[str] | None = None,\n    right_on: str | list[str] | None = None,\n    suffix: str = \"_right\"\n) -&gt; Self\n</code></pre> <p>Join in SQL-like fashion.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Self</code> <p>DataFrame to join with.</p> required <code>on</code> <code>str | list[str] | None</code> <p>Name(s) of the join columns in both DataFrames. If set, <code>left_on</code> and <code>right_on</code> should be None.</p> <code>None</code> <code>how</code> <code>JoinStrategy</code> <p>Join strategy.</p> <ul> <li>inner: Returns rows that have matching values in both tables.</li> <li>left: Returns all rows from the left table, and the matched rows from the right table.</li> <li>full: Returns all rows in both dataframes, with the suffix appended to the right join keys.</li> <li>cross: Returns the Cartesian product of rows from both tables.</li> <li>semi: Filter rows that have a match in the right table.</li> <li>anti: Filter rows that do not have a match in the right table.</li> </ul> <code>'inner'</code> <code>left_on</code> <code>str | list[str] | None</code> <p>Join column of the left DataFrame.</p> <code>None</code> <code>right_on</code> <code>str | list[str] | None</code> <p>Join column of the right DataFrame.</p> <code>None</code> <code>suffix</code> <code>str</code> <p>Suffix to append to columns with a duplicate name.</p> <code>'_right'</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_1_native = pd.DataFrame({\"id\": [\"a\", \"b\"], \"price\": [6.0, 7.0]})\n&gt;&gt;&gt; df_2_native = pd.DataFrame({\"id\": [\"a\", \"b\", \"c\"], \"qty\": [1, 2, 3]})\n&gt;&gt;&gt; nw.from_native(df_1_native).join(nw.from_native(df_2_native), on=\"id\")\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|   id  price  qty |\n| 0  a    6.0    1 |\n| 1  b    7.0    2 |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.join_asof","title":"join_asof","text":"<pre><code>join_asof(\n    other: Self,\n    *,\n    left_on: str | None = None,\n    right_on: str | None = None,\n    on: str | None = None,\n    by_left: str | list[str] | None = None,\n    by_right: str | list[str] | None = None,\n    by: str | list[str] | None = None,\n    strategy: AsofJoinStrategy = \"backward\",\n    suffix: str = \"_right\"\n) -&gt; Self\n</code></pre> <p>Perform an asof join.</p> <p>This is similar to a left-join except that we match on nearest key rather than equal keys.</p> <p>For Polars, both DataFrames must be sorted by the <code>on</code> key (within each <code>by</code> group if specified).</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Self</code> <p>DataFrame to join with.</p> required <code>left_on</code> <code>str | None</code> <p>Name(s) of the left join column(s).</p> <code>None</code> <code>right_on</code> <code>str | None</code> <p>Name(s) of the right join column(s).</p> <code>None</code> <code>on</code> <code>str | None</code> <p>Join column of both DataFrames. If set, left_on and right_on should be None.</p> <code>None</code> <code>by_left</code> <code>str | list[str] | None</code> <p>join on these columns before doing asof join.</p> <code>None</code> <code>by_right</code> <code>str | list[str] | None</code> <p>join on these columns before doing asof join.</p> <code>None</code> <code>by</code> <code>str | list[str] | None</code> <p>join on these columns before doing asof join.</p> <code>None</code> <code>strategy</code> <code>AsofJoinStrategy</code> <p>Join strategy. The default is \"backward\".</p> <code>'backward'</code> <code>suffix</code> <code>str</code> <p>Suffix to append to columns with a duplicate name.</p> <ul> <li>backward: selects the last row in the right DataFrame whose \"on\" key is less than or equal to the left's key.</li> <li>forward: selects the first row in the right DataFrame whose \"on\" key is greater than or equal to the left's key.</li> <li>nearest: search selects the last row in the right DataFrame whose value is nearest to the left's key.</li> </ul> <code>'_right'</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data_gdp = {\n...     \"datetime\": [\n...         datetime(2016, 1, 1),\n...         datetime(2017, 1, 1),\n...         datetime(2018, 1, 1),\n...         datetime(2019, 1, 1),\n...         datetime(2020, 1, 1),\n...     ],\n...     \"gdp\": [4164, 4411, 4566, 4696, 4827],\n... }\n&gt;&gt;&gt; data_population = {\n...     \"datetime\": [\n...         datetime(2016, 3, 1),\n...         datetime(2018, 8, 1),\n...         datetime(2019, 1, 1),\n...     ],\n...     \"population\": [82.19, 82.66, 83.12],\n... }\n&gt;&gt;&gt; gdp_native = pd.DataFrame(data_gdp)\n&gt;&gt;&gt; population_native = pd.DataFrame(data_population)\n&gt;&gt;&gt; gdp = nw.from_native(gdp_native)\n&gt;&gt;&gt; population = nw.from_native(population_native)\n&gt;&gt;&gt; population.join_asof(gdp, on=\"datetime\", strategy=\"backward\")\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|      Narwhals DataFrame      |\n|------------------------------|\n|    datetime  population   gdp|\n|0 2016-03-01       82.19  4164|\n|1 2018-08-01       82.66  4566|\n|2 2019-01-01       83.12  4696|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.lazy","title":"lazy","text":"<pre><code>lazy(\n    backend: IntoBackend[LazyAllowed] | None = None,\n    *,\n    session: Any | None = None\n) -&gt; LazyFrame[Any]\n</code></pre> <p>Restrict available API methods to lazy-only ones.</p> <p>If <code>backend</code> is specified, then a conversion between different backends might be triggered.</p> <p>If a library does not support lazy execution and <code>backend</code> is not specified, then this is will only restrict the API to lazy-only operations. This is useful if you want to ensure that you write dataframe-agnostic code which all has the possibility of running entirely lazily.</p> Note <p>If <code>backend</code> is spark-like, then a valid <code>session</code> is required.</p> <p>For instance:</p> <pre><code>import narwhals as nw\nfrom sqlframe.duckdb import DuckDBSession\n\ndf.lazy(backend=nw.Implementation.SQLFRAME, session=DuckDBSession())\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>backend</code> <code>IntoBackend[LazyAllowed] | None</code> <p>Which lazy backend collect to. This will be the underlying backend for the resulting Narwhals LazyFrame. If not specified, and the given library does not support lazy execution, then this will restrict the API to lazy-only operations.</p> <p><code>backend</code> can be specified in various ways</p> <ul> <li>As <code>Implementation.&lt;BACKEND&gt;</code> with <code>BACKEND</code> being <code>DASK</code>, <code>DUCKDB</code>,     <code>IBIS</code> or <code>POLARS</code>.</li> <li>As a string: <code>\"dask\"</code>, <code>\"duckdb\"</code>, <code>\"ibis\"</code> or <code>\"polars\"</code></li> <li>Directly as a module <code>dask.dataframe</code>, <code>duckdb</code>, <code>ibis</code> or <code>polars</code>.</li> </ul> <code>None</code> <code>session</code> <code>Any | None</code> <p>Session to be used if backend is spark-like.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pl.DataFrame({\"a\": [1, 2], \"b\": [4, 6]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n</code></pre> <p>If we call <code>df.lazy</code>, we get a <code>narwhals.LazyFrame</code> backed by a Polars LazyFrame.</p> <pre><code>&gt;&gt;&gt; df.lazy()\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|     Narwhals LazyFrame      |\n|-----------------------------|\n|&lt;LazyFrame at 0x7F52B9937230&gt;|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>We can also pass DuckDB as the backend, and then we'll get a <code>narwhals.LazyFrame</code> backed by a <code>duckdb.DuckDBPyRelation</code>.</p> <pre><code>&gt;&gt;&gt; df.lazy(backend=nw.Implementation.DUCKDB)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals LazyFrame|\n|------------------|\n|\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 |\n|\u2502   a   \u2502   b   \u2502 |\n|\u2502 int64 \u2502 int64 \u2502 |\n|\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 |\n|\u2502     1 \u2502     4 \u2502 |\n|\u2502     2 \u2502     6 \u2502 |\n|\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.null_count","title":"null_count","text":"<pre><code>null_count() -&gt; Self\n</code></pre> <p>Create a new DataFrame that shows the null counts per column.</p> Notes <p>pandas handles null values differently from Polars and PyArrow. See null_handling for reference.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pa.table({\"foo\": [1, None], \"bar\": [2, 3]})\n&gt;&gt;&gt; nw.from_native(df_native).null_count()\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|  pyarrow.Table   |\n|  foo: int64      |\n|  bar: int64      |\n|  ----            |\n|  foo: [[1]]      |\n|  bar: [[0]]      |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.pipe","title":"pipe","text":"<pre><code>pipe(\n    function: Callable[Concatenate[Self, PS], R],\n    *args: args,\n    **kwargs: kwargs\n) -&gt; R\n</code></pre> <p>Pipe function call.</p> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>Callable[Concatenate[Self, PS], R]</code> <p>Function to apply.</p> required <code>args</code> <code>args</code> <p>Positional arguments to pass to function.</p> <code>()</code> <code>kwargs</code> <code>kwargs</code> <p>Keyword arguments to pass to function.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [1, 2], \"ba\": [4, 5]})\n&gt;&gt;&gt; nw.from_native(df_native).pipe(\n...     lambda _df: _df.select(\n...         [x for x in _df.columns if len(x) == 1]\n...     ).to_native()\n... )\n   a\n0  1\n1  2\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.pivot","title":"pivot","text":"<pre><code>pivot(\n    on: str | list[str],\n    *,\n    index: str | list[str] | None = None,\n    values: str | list[str] | None = None,\n    aggregate_function: PivotAgg | None = None,\n    maintain_order: bool | None = None,\n    sort_columns: bool = False,\n    separator: str = \"_\"\n) -&gt; Self\n</code></pre> <p>Create a spreadsheet-style pivot table as a DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>on</code> <code>str | list[str]</code> <p>Name of the column(s) whose values will be used as the header of the output DataFrame.</p> required <code>index</code> <code>str | list[str] | None</code> <p>One or multiple keys to group by. If None, all remaining columns not specified on <code>on</code> and <code>values</code> will be used. At least one of <code>index</code> and <code>values</code> must be specified.</p> <code>None</code> <code>values</code> <code>str | list[str] | None</code> <p>One or multiple keys to group by. If None, all remaining columns not specified on <code>on</code> and <code>index</code> will be used. At least one of <code>index</code> and <code>values</code> must be specified.</p> <code>None</code> <code>aggregate_function</code> <code>PivotAgg | None</code> <p>Choose from</p> <ul> <li>None: no aggregation takes place, will raise error if multiple values     are in group.</li> <li>A predefined aggregate function string, one of     {'min', 'max', 'first', 'last', 'sum', 'mean', 'median', 'len'}</li> </ul> <code>None</code> <code>maintain_order</code> <code>bool | None</code> <p>Has no effect and is kept around only for backwards-compatibility.</p> <code>None</code> <code>sort_columns</code> <code>bool</code> <p>Sort the transposed columns by name. Default is by order of discovery.</p> <code>False</code> <code>separator</code> <code>str</code> <p>Used as separator/delimiter in generated column names in case of multiple <code>values</code> columns.</p> <code>'_'</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = {\n...     \"ix\": [1, 1, 2, 2, 1, 2],\n...     \"col\": [\"a\", \"a\", \"a\", \"a\", \"b\", \"b\"],\n...     \"foo\": [0, 1, 2, 2, 7, 1],\n...     \"bar\": [0, 2, 0, 0, 9, 4],\n... }\n&gt;&gt;&gt; df_native = pd.DataFrame(data)\n&gt;&gt;&gt; nw.from_native(df_native).pivot(\n...     \"col\", index=\"ix\", aggregate_function=\"sum\"\n... )\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|       Narwhals DataFrame        |\n|---------------------------------|\n|   ix  foo_a  foo_b  bar_a  bar_b|\n|0   1      1      7      2      9|\n|1   2      4      1      0      4|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.rename","title":"rename","text":"<pre><code>rename(mapping: dict[str, str]) -&gt; Self\n</code></pre> <p>Rename column names.</p> <p>Parameters:</p> Name Type Description Default <code>mapping</code> <code>dict[str, str]</code> <p>Key value pairs that map from old name to new name.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pa.table({\"foo\": [1, 2], \"bar\": [6, 7]})\n&gt;&gt;&gt; nw.from_native(df_native).rename({\"foo\": \"apple\"}).to_native()\npyarrow.Table\napple: int64\nbar: int64\n----\napple: [[1,2]]\nbar: [[6,7]]\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.row","title":"row","text":"<pre><code>row(index: int) -&gt; tuple[Any, ...]\n</code></pre> <p>Get values at given row.</p> Warning <p>You should NEVER use this method to iterate over a DataFrame; if you require row-iteration you should strongly prefer use of iter_rows() instead.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Row number.</p> required Notes <p>cuDF doesn't support this method.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pa.table({\"a\": [1, 2], \"b\": [4, 5]})\n&gt;&gt;&gt; nw.from_native(df_native).row(1)\n(&lt;pyarrow.Int64Scalar: 2&gt;, &lt;pyarrow.Int64Scalar: 5&gt;)\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.rows","title":"rows","text":"<pre><code>rows(\n    *, named: Literal[False] = False\n) -&gt; list[tuple[Any, ...]]\n</code></pre><pre><code>rows(*, named: Literal[True]) -&gt; list[dict[str, Any]]\n</code></pre><pre><code>rows(\n    *, named: bool\n) -&gt; list[tuple[Any, ...]] | list[dict[str, Any]]\n</code></pre> <pre><code>rows(\n    *, named: bool = False\n) -&gt; list[tuple[Any, ...]] | list[dict[str, Any]]\n</code></pre> <p>Returns all data in the DataFrame as a list of rows of python-native values.</p> <p>Parameters:</p> Name Type Description Default <code>named</code> <code>bool</code> <p>By default, each row is returned as a tuple of values given in the same order as the frame columns. Setting named=True will return rows of dictionaries instead.</p> <code>False</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pa.table({\"foo\": [1, 2], \"bar\": [6.0, 7.0]})\n&gt;&gt;&gt; nw.from_native(df_native).rows()\n[(1, 6.0), (2, 7.0)]\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.sample","title":"sample","text":"<pre><code>sample(\n    n: int | None = None,\n    *,\n    fraction: float | None = None,\n    with_replacement: bool = False,\n    seed: int | None = None\n) -&gt; Self\n</code></pre> <p>Sample from this DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int | None</code> <p>Number of items to return. Cannot be used with fraction.</p> <code>None</code> <code>fraction</code> <code>float | None</code> <p>Fraction of items to return. Cannot be used with n.</p> <code>None</code> <code>with_replacement</code> <code>bool</code> <p>Allow values to be sampled more than once.</p> <code>False</code> <code>seed</code> <code>int | None</code> <p>Seed for the random number generator. If set to None (default), a random seed is generated for each sample operation.</p> <code>None</code> Notes <p>The results may not be consistent across libraries.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"foo\": [1, 2, 3], \"bar\": [19, 32, 4]})\n&gt;&gt;&gt; nw.from_native(df_native).sample(n=2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|      foo  bar    |\n|   2    3    4    |\n|   1    2   32    |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.select","title":"select","text":"<pre><code>select(\n    *exprs: IntoExpr | Iterable[IntoExpr],\n    **named_exprs: IntoExpr\n) -&gt; Self\n</code></pre> <p>Select columns from this DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>*exprs</code> <code>IntoExpr | Iterable[IntoExpr]</code> <p>Column(s) to select, specified as positional arguments.      Accepts expression input. Strings are parsed as column names,      other non-expression inputs are parsed as literals.</p> <code>()</code> <code>**named_exprs</code> <code>IntoExpr</code> <p>Additional columns to select, specified as keyword arguments.             The columns will be renamed to the keyword used.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pa.table({\"a\": [1, 2], \"b\": [3, 4]})\n&gt;&gt;&gt; nw.from_native(df_native).select(\"a\", a_plus_1=nw.col(\"a\") + 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|pyarrow.Table     |\n|a: int64          |\n|a_plus_1: int64   |\n|----              |\n|a: [[1,2]]        |\n|a_plus_1: [[2,3]] |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.sort","title":"sort","text":"<pre><code>sort(\n    by: str | Iterable[str],\n    *more_by: str,\n    descending: bool | Sequence[bool] = False,\n    nulls_last: bool = False\n) -&gt; Self\n</code></pre> <p>Sort the dataframe by the given columns.</p> <p>Parameters:</p> Name Type Description Default <code>by</code> <code>str | Iterable[str]</code> <p>Column(s) names to sort by.</p> required <code>*more_by</code> <code>str</code> <p>Additional columns to sort by, specified as positional arguments.</p> <code>()</code> <code>descending</code> <code>bool | Sequence[bool]</code> <p>Sort in descending order. When sorting by multiple columns, can be specified per column by passing a sequence of booleans.</p> <code>False</code> <code>nulls_last</code> <code>bool</code> <p>Place null values last.</p> <code>False</code> Note <p>Unlike Polars, it is not possible to specify a sequence of booleans for <code>nulls_last</code> in order to control per-column behaviour. Instead a single boolean is applied for all <code>by</code> columns.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame(\n...     {\"foo\": [2, 1], \"bar\": [6.0, 7.0], \"ham\": [\"a\", \"b\"]}\n... )\n&gt;&gt;&gt; nw.from_native(df_native).sort(\"foo\")\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|    foo  bar ham  |\n| 1    1  7.0   b  |\n| 0    2  6.0   a  |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.tail","title":"tail","text":"<pre><code>tail(n: int = 5) -&gt; Self\n</code></pre> <p>Get the last <code>n</code> rows.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Number of rows to return. If a negative value is passed, return all rows except the first <code>abs(n)</code>.</p> <code>5</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [1, 2], \"b\": [0.5, 4.0]})\n&gt;&gt;&gt; nw.from_native(df_native).tail(1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|       a    b     |\n|    1  2  4.0     |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.to_arrow","title":"to_arrow","text":"<pre><code>to_arrow() -&gt; pa.Table\n</code></pre> <p>Convert to arrow table.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"foo\": [1, None], \"bar\": [2, 3]})\n&gt;&gt;&gt; nw.from_native(df_native).to_arrow()\npyarrow.Table\nfoo: double\nbar: int64\n----\nfoo: [[1,null]]\nbar: [[2,3]]\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.to_dict","title":"to_dict","text":"<pre><code>to_dict(\n    *, as_series: Literal[True] = ...\n) -&gt; dict[str, Series[Any]]\n</code></pre><pre><code>to_dict(\n    *, as_series: Literal[False]\n) -&gt; dict[str, list[Any]]\n</code></pre><pre><code>to_dict(\n    *, as_series: bool = True\n) -&gt; dict[str, Series[Any]] | dict[str, list[Any]]\n</code></pre> <pre><code>to_dict(\n    *, as_series: bool = True\n) -&gt; dict[str, Series[Any]] | dict[str, list[Any]]\n</code></pre> <p>Convert DataFrame to a dictionary mapping column name to values.</p> <p>Parameters:</p> Name Type Description Default <code>as_series</code> <code>bool</code> <p>If set to true <code>True</code>, then the values are Narwhals Series,     otherwise the values are Any.</p> <code>True</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pa.table({\"A\": [1, 2], \"fruits\": [\"banana\", \"apple\"]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.to_dict(as_series=False)\n{'A': [1, 2], 'fruits': ['banana', 'apple']}\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.to_native","title":"to_native","text":"<pre><code>to_native() -&gt; DataFrameT\n</code></pre> <p>Convert Narwhals DataFrame to native one.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame(\n...     {\"foo\": [1, 2, 3], \"bar\": [6.0, 7.0, 8.0], \"ham\": [\"a\", \"b\", \"c\"]}\n... )\n</code></pre> <p>Calling <code>to_native</code> on a Narwhals DataFrame returns the native object:</p> <pre><code>&gt;&gt;&gt; nw.from_native(df_native).to_native()\n   foo  bar ham\n0    1  6.0   a\n1    2  7.0   b\n2    3  8.0   c\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.to_numpy","title":"to_numpy","text":"<pre><code>to_numpy() -&gt; _2DArray\n</code></pre> <p>Convert this DataFrame to a NumPy ndarray.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"foo\": [1, 2], \"bar\": [6.5, 7.0]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.to_numpy()\narray([[1. , 6.5],\n       [2. , 7. ]])\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.to_pandas","title":"to_pandas","text":"<pre><code>to_pandas() -&gt; pd.DataFrame\n</code></pre> <p>Convert this DataFrame to a pandas DataFrame.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pl.DataFrame(\n...     {\"foo\": [1, 2, 3], \"bar\": [6.0, 7.0, 8.0], \"ham\": [\"a\", \"b\", \"c\"]}\n... )\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.to_pandas()\n   foo  bar ham\n0    1  6.0   a\n1    2  7.0   b\n2    3  8.0   c\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.to_polars","title":"to_polars","text":"<pre><code>to_polars() -&gt; pl.DataFrame\n</code></pre> <p>Convert this DataFrame to a polars DataFrame.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pa.table({\"foo\": [1, 2], \"bar\": [6.0, 7.0]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.to_polars()\nshape: (2, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 foo \u2506 bar \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 i64 \u2506 f64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 6.0 \u2502\n\u2502 2   \u2506 7.0 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.top_k","title":"top_k","text":"<pre><code>top_k(\n    k: int,\n    *,\n    by: str | Iterable[str],\n    reverse: bool | Sequence[bool] = False\n) -&gt; Self\n</code></pre> <p>Return the <code>k</code> largest rows.</p> <p>Non-null elements are always preferred over null elements, regardless of the value of reverse. The output is not guaranteed to be in any particular order, sort the outputs afterwards if you wish the output to be sorted.</p> <p>Parameters:</p> Name Type Description Default <code>k</code> <code>int</code> <p>Number of rows to return.</p> required <code>by</code> <code>str | Iterable[str]</code> <p>Column(s) used to determine the top rows. Accepts expression input. Strings are parsed as column names.</p> required <code>reverse</code> <code>bool | Sequence[bool]</code> <p>Consider the k smallest elements of the by column(s) (instead of the k largest). This can be specified per column by passing a sequence of booleans.</p> <code>False</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame(\n...     {\"a\": [\"a\", \"b\", \"a\", \"b\", None, \"c\"], \"b\": [2, 1, 1, 3, 2, 1]}\n... )\n&gt;&gt;&gt; nw.from_native(df_native).top_k(4, by=[\"b\", \"a\"])\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|          a  b    |\n|    3     b  3    |\n|    0     a  2    |\n|    4  None  2    |\n|    5     c  1    |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.unique","title":"unique","text":"<pre><code>unique(\n    subset: str | list[str] | None = None,\n    *,\n    keep: UniqueKeepStrategy = \"any\",\n    maintain_order: bool = False,\n    order_by: str | Sequence[str] | None = None\n) -&gt; Self\n</code></pre> <p>Drop duplicate rows from this dataframe.</p> <p>Parameters:</p> Name Type Description Default <code>subset</code> <code>str | list[str] | None</code> <p>Column name(s) to consider when identifying duplicate rows.</p> <code>None</code> <code>keep</code> <code>UniqueKeepStrategy</code> <p>{'first', 'last', 'any', 'none'} Which of the duplicate rows to keep.</p> <ul> <li>'any': Does not give any guarantee of which row is kept.         This allows more optimizations.</li> <li>'none': Don't keep duplicate rows.</li> <li>'first': Keep first unique row.</li> <li>'last': Keep last unique row.</li> </ul> <code>'any'</code> <code>maintain_order</code> <code>bool</code> <p>Keep the same order as the original DataFrame. This may be more expensive to compute.</p> <code>False</code> <code>order_by</code> <code>str | Sequence[str] | None</code> <p>Column(s) to order by when computing the row index.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame(\n...     {\"foo\": [1, 2], \"bar\": [\"a\", \"a\"], \"ham\": [\"b\", \"b\"]}\n... )\n&gt;&gt;&gt; nw.from_native(df_native).unique([\"bar\", \"ham\"]).to_native()\n   foo bar ham\n0    1   a   b\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.unpivot","title":"unpivot","text":"<pre><code>unpivot(\n    on: str | list[str] | None = None,\n    *,\n    index: str | list[str] | None = None,\n    variable_name: str = \"variable\",\n    value_name: str = \"value\"\n) -&gt; Self\n</code></pre> <p>Unpivot a DataFrame from wide to long format.</p> <p>Optionally leaves identifiers set.</p> <p>This function is useful to massage a DataFrame into a format where one or more columns are identifier variables (index) while all other columns, considered measured variables (on), are \"unpivoted\" to the row axis leaving just two non-identifier columns, 'variable' and 'value'.</p> <p>Parameters:</p> Name Type Description Default <code>on</code> <code>str | list[str] | None</code> <p>Column(s) to use as values variables; if <code>on</code> is empty all columns that are not in <code>index</code> will be used.</p> <code>None</code> <code>index</code> <code>str | list[str] | None</code> <p>Column(s) to use as identifier variables.</p> <code>None</code> <code>variable_name</code> <code>str</code> <p>Name to give to the <code>variable</code> column. Defaults to \"variable\".</p> <code>'variable'</code> <code>value_name</code> <code>str</code> <p>Name to give to the <code>value</code> column. Defaults to \"value\".</p> <code>'value'</code> Notes <p>If you're coming from pandas, this is similar to <code>pandas.DataFrame.melt</code>, but with <code>index</code> replacing <code>id_vars</code> and <code>on</code> replacing <code>value_vars</code>. In other frameworks, you might know this operation as <code>pivot_longer</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = {\"a\": [\"x\", \"y\", \"z\"], \"b\": [1, 3, 5], \"c\": [2, 4, 6]}\n&gt;&gt;&gt; df_native = pd.DataFrame(data)\n&gt;&gt;&gt; nw.from_native(df_native).unpivot([\"b\", \"c\"], index=\"a\")\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n| Narwhals DataFrame |\n|--------------------|\n|   a variable  value|\n|0  x        b      1|\n|1  y        b      3|\n|2  z        b      5|\n|3  x        c      2|\n|4  y        c      4|\n|5  z        c      6|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.with_columns","title":"with_columns","text":"<pre><code>with_columns(\n    *exprs: IntoExpr | Iterable[IntoExpr],\n    **named_exprs: IntoExpr\n) -&gt; Self\n</code></pre> <p>Add columns to this DataFrame.</p> <p>Added columns will replace existing columns with the same name.</p> <p>Parameters:</p> Name Type Description Default <code>*exprs</code> <code>IntoExpr | Iterable[IntoExpr]</code> <p>Column(s) to add, specified as positional arguments.      Accepts expression input. Strings are parsed as column names, other      non-expression inputs are parsed as literals.</p> <code>()</code> <code>**named_exprs</code> <code>IntoExpr</code> <p>Additional columns to add, specified as keyword arguments.             The columns will be renamed to the keyword used.</p> <code>{}</code> Note <p>Creating a new DataFrame using this method does not create a new copy of existing data.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [1, 2], \"b\": [0.5, 4.0]})\n&gt;&gt;&gt; (\n...     nw.from_native(df_native)\n...     .with_columns((nw.col(\"a\") * 2).alias(\"a*2\"))\n...     .to_native()\n... )\n   a    b  a*2\n0  1  0.5    2\n1  2  4.0    4\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.with_row_index","title":"with_row_index","text":"<pre><code>with_row_index(\n    name: str = \"index\",\n    *,\n    order_by: str | Sequence[str] | None = None\n) -&gt; Self\n</code></pre> <p>Insert column which enumerates rows.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the column as a string. The default is \"index\".</p> <code>'index'</code> <code>order_by</code> <code>str | Sequence[str] | None</code> <p>Column(s) to order by when computing the row index.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pa.table({\"a\": [1, 2], \"b\": [4, 5]})\n&gt;&gt;&gt; nw.from_native(df_native).with_row_index().to_native()\npyarrow.Table\nindex: int64\na: int64\nb: int64\n----\nindex: [[0,1]]\na: [[1,2]]\nb: [[4,5]]\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.write_csv","title":"write_csv","text":"<pre><code>write_csv(file: None = None) -&gt; str\n</code></pre><pre><code>write_csv(file: str | Path | BytesIO) -&gt; None\n</code></pre> <pre><code>write_csv(\n    file: str | Path | BytesIO | None = None,\n) -&gt; str | None\n</code></pre> <p>Write dataframe to comma-separated values (CSV) file.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>str | Path | BytesIO | None</code> <p>String, path object or file-like object to which the dataframe will be written. If None, the resulting csv format is returned as a string.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame(\n...     {\"foo\": [1, 2, 3], \"bar\": [6.0, 7.0, 8.0], \"ham\": [\"a\", \"b\", \"c\"]}\n... )\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.write_csv()\n'foo,bar,ham\\n1,6.0,a\\n2,7.0,b\\n3,8.0,c\\n'\n</code></pre> <p>If we had passed a file name to <code>write_csv</code>, it would have been written to that file.</p>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.write_parquet","title":"write_parquet","text":"<pre><code>write_parquet(file: str | Path | BytesIO) -&gt; None\n</code></pre> <p>Write dataframe to parquet file.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>str | Path | BytesIO</code> <p>String, path object or file-like object to which the dataframe will be written.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pa.table({\"foo\": [1, 2], \"bar\": [6.0, 7.0]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.write_parquet(\"out.parquet\")\n</code></pre>"},{"location":"api-reference/dependencies/","title":"<code>narwhals.dependencies</code>","text":""},{"location":"api-reference/dependencies/#narwhals.dependencies.get_cudf","title":"get_cudf","text":"<pre><code>get_cudf() -&gt; Any\n</code></pre> <p>Get cudf module (if already imported - else return None).</p>"},{"location":"api-reference/dependencies/#narwhals.dependencies.get_ibis","title":"get_ibis","text":"<pre><code>get_ibis() -&gt; Any\n</code></pre> <p>Get ibis module (if already imported - else return None).</p>"},{"location":"api-reference/dependencies/#narwhals.dependencies.get_modin","title":"get_modin","text":"<pre><code>get_modin() -&gt; Any\n</code></pre> <p>Get modin.pandas module (if already imported - else return None).</p>"},{"location":"api-reference/dependencies/#narwhals.dependencies.get_pandas","title":"get_pandas","text":"<pre><code>get_pandas() -&gt; Any\n</code></pre> <p>Get pandas module (if already imported - else return None).</p>"},{"location":"api-reference/dependencies/#narwhals.dependencies.get_polars","title":"get_polars","text":"<pre><code>get_polars() -&gt; Any\n</code></pre> <p>Get Polars module (if already imported - else return None).</p>"},{"location":"api-reference/dependencies/#narwhals.dependencies.get_pyarrow","title":"get_pyarrow","text":"<pre><code>get_pyarrow() -&gt; Any\n</code></pre> <p>Get pyarrow module (if already imported - else return None).</p>"},{"location":"api-reference/dependencies/#narwhals.dependencies.is_cudf_dataframe","title":"is_cudf_dataframe","text":"<pre><code>is_cudf_dataframe(df: Any) -&gt; TypeIs[cudf.DataFrame]\n</code></pre> <p>Check whether <code>df</code> is a cudf DataFrame without importing cudf.</p> Warning <p>This method cannot be called on a Narwhals DataFrame/LazyFrame.</p>"},{"location":"api-reference/dependencies/#narwhals.dependencies.is_cudf_index","title":"is_cudf_index","text":"<pre><code>is_cudf_index(index: Any) -&gt; TypeIs[cudf.Index]\n</code></pre> <p>Check whether <code>index</code> is a cudf Index without importing cudf.</p>"},{"location":"api-reference/dependencies/#narwhals.dependencies.is_cudf_series","title":"is_cudf_series","text":"<pre><code>is_cudf_series(ser: Any) -&gt; TypeIs[cudf.Series[Any]]\n</code></pre> <p>Check whether <code>ser</code> is a cudf Series without importing cudf.</p> Warning <p>This method cannot be called on Narwhals Series.</p>"},{"location":"api-reference/dependencies/#narwhals.dependencies.is_dask_dataframe","title":"is_dask_dataframe","text":"<pre><code>is_dask_dataframe(df: Any) -&gt; TypeIs[dd.DataFrame]\n</code></pre> <p>Check whether <code>df</code> is a Dask DataFrame without importing Dask.</p> Warning <p>This method cannot be called on a Narwhals DataFrame/LazyFrame.</p>"},{"location":"api-reference/dependencies/#narwhals.dependencies.is_ibis_table","title":"is_ibis_table","text":"<pre><code>is_ibis_table(df: Any) -&gt; TypeIs[ibis.Table]\n</code></pre> <p>Check whether <code>df</code> is a Ibis Table without importing Ibis.</p> Warning <p>This method cannot be called on Narwhals DataFrame/LazyFrame.</p>"},{"location":"api-reference/dependencies/#narwhals.dependencies.is_into_dataframe","title":"is_into_dataframe","text":"<pre><code>is_into_dataframe(\n    native_dataframe: Any | IntoDataFrameT,\n) -&gt; TypeIs[IntoDataFrameT]\n</code></pre> <p>Check whether <code>native_dataframe</code> can be converted to a Narwhals DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>native_dataframe</code> <code>Any | IntoDataFrameT</code> <p>The object to check.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from narwhals.dependencies import is_into_dataframe\n</code></pre> <pre><code>&gt;&gt;&gt; df_pd = pd.DataFrame({\"a\": [1, 2, 3], \"b\": [4, 5, 6]})\n&gt;&gt;&gt; df_pl = pl.DataFrame({\"a\": [1, 2, 3], \"b\": [4, 5, 6]})\n&gt;&gt;&gt; np_arr = np.array([[1, 4], [2, 5], [3, 6]])\n</code></pre> <pre><code>&gt;&gt;&gt; is_into_dataframe(df_pd)\nTrue\n&gt;&gt;&gt; is_into_dataframe(df_pl)\nTrue\n&gt;&gt;&gt; is_into_dataframe(np_arr)\nFalse\n</code></pre>"},{"location":"api-reference/dependencies/#narwhals.dependencies.is_into_series","title":"is_into_series","text":"<pre><code>is_into_series(\n    native_series: Any | IntoSeriesT,\n) -&gt; TypeIs[IntoSeriesT]\n</code></pre> <p>Check whether <code>native_series</code> can be converted to a Narwhals Series.</p> <p>Parameters:</p> Name Type Description Default <code>native_series</code> <code>Any | IntoSeriesT</code> <p>The object to check.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import narwhals as nw\n</code></pre> <pre><code>&gt;&gt;&gt; s_pd = pd.Series([1, 2, 3])\n&gt;&gt;&gt; s_pl = pl.Series([1, 2, 3])\n&gt;&gt;&gt; np_arr = np.array([1, 2, 3])\n</code></pre> <pre><code>&gt;&gt;&gt; nw.dependencies.is_into_series(s_pd)\nTrue\n&gt;&gt;&gt; nw.dependencies.is_into_series(s_pl)\nTrue\n&gt;&gt;&gt; nw.dependencies.is_into_series(np_arr)\nFalse\n</code></pre>"},{"location":"api-reference/dependencies/#narwhals.dependencies.is_modin_dataframe","title":"is_modin_dataframe","text":"<pre><code>is_modin_dataframe(df: Any) -&gt; TypeIs[mpd.DataFrame]\n</code></pre> <p>Check whether <code>df</code> is a modin DataFrame without importing modin.</p> Warning <p>This method cannot be called on a Narwhals DataFrame/LazyFrame.</p>"},{"location":"api-reference/dependencies/#narwhals.dependencies.is_modin_index","title":"is_modin_index","text":"<pre><code>is_modin_index(index: Any) -&gt; TypeIs[mpd.Index[Any]]\n</code></pre> <p>Check whether <code>index</code> is a modin Index without importing modin.</p>"},{"location":"api-reference/dependencies/#narwhals.dependencies.is_modin_series","title":"is_modin_series","text":"<pre><code>is_modin_series(ser: Any) -&gt; TypeIs[mpd.Series]\n</code></pre> <p>Check whether <code>ser</code> is a modin Series without importing modin.</p> Warning <p>This method cannot be called on Narwhals Series.</p>"},{"location":"api-reference/dependencies/#narwhals.dependencies.is_numpy_array","title":"is_numpy_array","text":"<pre><code>is_numpy_array(\n    arr: Any | _NDArray[_ShapeT],\n) -&gt; TypeIs[_NDArray[_ShapeT]]\n</code></pre> <p>Check whether <code>arr</code> is a NumPy Array without importing NumPy.</p>"},{"location":"api-reference/dependencies/#narwhals.dependencies.is_pandas_dataframe","title":"is_pandas_dataframe","text":"<pre><code>is_pandas_dataframe(df: Any) -&gt; TypeIs[pd.DataFrame]\n</code></pre> <p>Check whether <code>df</code> is a pandas DataFrame without importing pandas.</p> Warning <p>This method cannot be called on a Narwhals DataFrame/LazyFrame.</p>"},{"location":"api-reference/dependencies/#narwhals.dependencies.is_pandas_index","title":"is_pandas_index","text":"<pre><code>is_pandas_index(index: Any) -&gt; TypeIs[pd.Index[Any]]\n</code></pre> <p>Check whether <code>index</code> is a pandas Index without importing pandas.</p>"},{"location":"api-reference/dependencies/#narwhals.dependencies.is_pandas_like_dataframe","title":"is_pandas_like_dataframe","text":"<pre><code>is_pandas_like_dataframe(df: Any) -&gt; bool\n</code></pre> <p>Check whether <code>df</code> is a pandas-like DataFrame without doing any imports.</p> <p>By \"pandas-like\", we mean: pandas, Modin, cuDF.</p> Warning <p>This method cannot be called on a Narwhals DataFrame/LazyFrame.</p>"},{"location":"api-reference/dependencies/#narwhals.dependencies.is_pandas_like_index","title":"is_pandas_like_index","text":"<pre><code>is_pandas_like_index(index: Any) -&gt; bool\n</code></pre> <p>Check whether <code>index</code> is a pandas-like Index without doing any imports.</p> <p>By \"pandas-like\", we mean: pandas, Modin, cuDF.</p>"},{"location":"api-reference/dependencies/#narwhals.dependencies.is_pandas_like_series","title":"is_pandas_like_series","text":"<pre><code>is_pandas_like_series(ser: Any) -&gt; bool\n</code></pre> <p>Check whether <code>ser</code> is a pandas-like Series without doing any imports.</p> <p>By \"pandas-like\", we mean: pandas, Modin, cuDF.</p> Warning <p>This method cannot be called on Narwhals Series.</p>"},{"location":"api-reference/dependencies/#narwhals.dependencies.is_pandas_series","title":"is_pandas_series","text":"<pre><code>is_pandas_series(ser: Any) -&gt; TypeIs[pd.Series[Any]]\n</code></pre> <p>Check whether <code>ser</code> is a pandas Series without importing pandas.</p> Warning <p>This method cannot be called on Narwhals Series.</p>"},{"location":"api-reference/dependencies/#narwhals.dependencies.is_polars_dataframe","title":"is_polars_dataframe","text":"<pre><code>is_polars_dataframe(df: Any) -&gt; TypeIs[pl.DataFrame]\n</code></pre> <p>Check whether <code>df</code> is a Polars DataFrame without importing Polars.</p> Warning <p>This method cannot be called on a Narwhals DataFrame/LazyFrame.</p>"},{"location":"api-reference/dependencies/#narwhals.dependencies.is_polars_lazyframe","title":"is_polars_lazyframe","text":"<pre><code>is_polars_lazyframe(df: Any) -&gt; TypeIs[pl.LazyFrame]\n</code></pre> <p>Check whether <code>df</code> is a Polars LazyFrame without importing Polars.</p> Warning <p>This method cannot be called on Narwhals DataFrame/LazyFrame.</p>"},{"location":"api-reference/dependencies/#narwhals.dependencies.is_polars_series","title":"is_polars_series","text":"<pre><code>is_polars_series(ser: Any) -&gt; TypeIs[pl.Series]\n</code></pre> <p>Check whether <code>ser</code> is a Polars Series without importing Polars.</p> Warning <p>This method cannot be called on Narwhals Series.</p>"},{"location":"api-reference/dependencies/#narwhals.dependencies.is_pyarrow_chunked_array","title":"is_pyarrow_chunked_array","text":"<pre><code>is_pyarrow_chunked_array(\n    ser: Any,\n) -&gt; TypeIs[pa.ChunkedArray[Any]]\n</code></pre> <p>Check whether <code>ser</code> is a PyArrow ChunkedArray without importing PyArrow.</p> Warning <p>This method cannot be called on Narwhals Series.</p>"},{"location":"api-reference/dependencies/#narwhals.dependencies.is_pyarrow_table","title":"is_pyarrow_table","text":"<pre><code>is_pyarrow_table(df: Any) -&gt; TypeIs[pa.Table]\n</code></pre> <p>Check whether <code>df</code> is a PyArrow Table without importing PyArrow.</p> Warning <p>This method cannot be called on Narwhals DataFrame/LazyFrame.</p>"},{"location":"api-reference/dtypes/","title":"<code>narwhals.dtypes</code>","text":""},{"location":"api-reference/dtypes/#narwhals.dtypes.DType","title":"DType","text":"<p>Base class for all Narwhals data types.</p>"},{"location":"api-reference/dtypes/#narwhals.dtypes.DType.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: DType | type[DType]) -&gt; bool\n</code></pre> <p>Check if this DType is equivalent to another DType.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; nw.String() == nw.String()\nTrue\n&gt;&gt;&gt; nw.String() == nw.String\nTrue\n&gt;&gt;&gt; nw.Int16() == nw.Int32\nFalse\n&gt;&gt;&gt; nw.Boolean() == nw.Int8\nFalse\n&gt;&gt;&gt; nw.Date() == nw.Datetime\nFalse\n</code></pre>"},{"location":"api-reference/dtypes/#narwhals.dtypes.DType.base_type","title":"base_type  <code>classmethod</code>","text":"<pre><code>base_type() -&gt; type[Self]\n</code></pre> <p>Return this DType's fundamental/root type class.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; nw.Datetime(\"us\").base_type()\nDatetime\n&gt;&gt;&gt; nw.String.base_type()\nString\n&gt;&gt;&gt; nw.List(nw.Int64).base_type()\nList\n</code></pre>"},{"location":"api-reference/dtypes/#narwhals.dtypes.DType.is_boolean","title":"is_boolean  <code>classmethod</code>","text":"<pre><code>is_boolean() -&gt; bool\n</code></pre> <p>Check whether the data type is a boolean type.</p>"},{"location":"api-reference/dtypes/#narwhals.dtypes.DType.is_decimal","title":"is_decimal  <code>classmethod</code>","text":"<pre><code>is_decimal() -&gt; bool\n</code></pre> <p>Check whether the data type is a decimal type.</p>"},{"location":"api-reference/dtypes/#narwhals.dtypes.DType.is_float","title":"is_float  <code>classmethod</code>","text":"<pre><code>is_float() -&gt; bool\n</code></pre> <p>Check whether the data type is a floating point type.</p>"},{"location":"api-reference/dtypes/#narwhals.dtypes.DType.is_integer","title":"is_integer  <code>classmethod</code>","text":"<pre><code>is_integer() -&gt; bool\n</code></pre> <p>Check whether the data type is an integer type.</p>"},{"location":"api-reference/dtypes/#narwhals.dtypes.DType.is_nested","title":"is_nested  <code>classmethod</code>","text":"<pre><code>is_nested() -&gt; bool\n</code></pre> <p>Check whether the data type is a nested type.</p>"},{"location":"api-reference/dtypes/#narwhals.dtypes.DType.is_numeric","title":"is_numeric  <code>classmethod</code>","text":"<pre><code>is_numeric() -&gt; bool\n</code></pre> <p>Check whether the data type is a numeric type.</p>"},{"location":"api-reference/dtypes/#narwhals.dtypes.DType.is_signed_integer","title":"is_signed_integer  <code>classmethod</code>","text":"<pre><code>is_signed_integer() -&gt; bool\n</code></pre> <p>Check whether the data type is a signed integer type.</p>"},{"location":"api-reference/dtypes/#narwhals.dtypes.DType.is_temporal","title":"is_temporal  <code>classmethod</code>","text":"<pre><code>is_temporal() -&gt; bool\n</code></pre> <p>Check whether the data type is a temporal type.</p>"},{"location":"api-reference/dtypes/#narwhals.dtypes.DType.is_unsigned_integer","title":"is_unsigned_integer  <code>classmethod</code>","text":"<pre><code>is_unsigned_integer() -&gt; bool\n</code></pre> <p>Check whether the data type is an unsigned integer type.</p>"},{"location":"api-reference/dtypes/#narwhals.dtypes.NumericType","title":"NumericType","text":"<p>               Bases: <code>DType</code></p> <p>Base class for numeric data types.</p>"},{"location":"api-reference/dtypes/#narwhals.dtypes.Decimal","title":"Decimal","text":"<p>               Bases: <code>NumericType</code></p> <p>Decimal type.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s = pl.Series([\"1.5\"], dtype=pl.Decimal)\n&gt;&gt;&gt; nw.from_native(s, series_only=True).dtype\nDecimal\n</code></pre>"},{"location":"api-reference/dtypes/#narwhals.dtypes.FloatType","title":"FloatType","text":"<p>               Bases: <code>NumericType</code></p> <p>Base class for float data types.</p>"},{"location":"api-reference/dtypes/#narwhals.dtypes.Float32","title":"Float32","text":"<p>               Bases: <code>FloatType</code></p> <p>32-bit floating point type.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pl.Series([0.001, 0.1, 0.01, 0.1])\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.cast(nw.Float32).dtype\nFloat32\n</code></pre>"},{"location":"api-reference/dtypes/#narwhals.dtypes.Float64","title":"Float64","text":"<p>               Bases: <code>FloatType</code></p> <p>64-bit floating point type.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pa.chunked_array([[0.001, 0.1, 0.01, 0.1]])\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.cast(nw.Float64).dtype\nFloat64\n</code></pre>"},{"location":"api-reference/dtypes/#narwhals.dtypes.IntegerType","title":"IntegerType","text":"<p>               Bases: <code>NumericType</code></p> <p>Base class for integer data types.</p>"},{"location":"api-reference/dtypes/#narwhals.dtypes.SignedIntegerType","title":"SignedIntegerType","text":"<p>               Bases: <code>IntegerType</code></p> <p>Base class for signed integer data types.</p>"},{"location":"api-reference/dtypes/#narwhals.dtypes.Int8","title":"Int8","text":"<p>               Bases: <code>SignedIntegerType</code></p> <p>8-bit signed integer type.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pd.Series([2, 1, 3, 7])\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.cast(nw.Int8).dtype\nInt8\n</code></pre>"},{"location":"api-reference/dtypes/#narwhals.dtypes.Int16","title":"Int16","text":"<p>               Bases: <code>SignedIntegerType</code></p> <p>16-bit signed integer type.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pl.Series([2, 1, 3, 7])\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.cast(nw.Int16).dtype\nInt16\n</code></pre>"},{"location":"api-reference/dtypes/#narwhals.dtypes.Int32","title":"Int32","text":"<p>               Bases: <code>SignedIntegerType</code></p> <p>32-bit signed integer type.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pa.chunked_array([[2, 1, 3, 7]])\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.cast(nw.Int32).dtype\nInt32\n</code></pre>"},{"location":"api-reference/dtypes/#narwhals.dtypes.Int64","title":"Int64","text":"<p>               Bases: <code>SignedIntegerType</code></p> <p>64-bit signed integer type.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pl.Series([2, 1, 3, 7])\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.cast(nw.Int64).dtype\nInt64\n</code></pre>"},{"location":"api-reference/dtypes/#narwhals.dtypes.Int128","title":"Int128","text":"<p>               Bases: <code>SignedIntegerType</code></p> <p>128-bit signed integer type.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import duckdb\n&gt;&gt;&gt; s_native = pl.Series([2, 1, 3, 7])\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; df_native = pa.table({\"a\": [2, 1, 3, 7]})\n&gt;&gt;&gt; rel = duckdb.sql(\" SELECT CAST (a AS INT128) AS a FROM df_native \")\n</code></pre> <pre><code>&gt;&gt;&gt; s.cast(nw.Int128).dtype\nInt128\n&gt;&gt;&gt; nw.from_native(rel).collect_schema()[\"a\"]\nInt128\n</code></pre>"},{"location":"api-reference/dtypes/#narwhals.dtypes.UnsignedIntegerType","title":"UnsignedIntegerType","text":"<p>               Bases: <code>IntegerType</code></p> <p>Base class for unsigned integer data types.</p>"},{"location":"api-reference/dtypes/#narwhals.dtypes.UInt8","title":"UInt8","text":"<p>               Bases: <code>UnsignedIntegerType</code></p> <p>8-bit unsigned integer type.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pl.Series([2, 1, 3, 7])\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.cast(nw.UInt8).dtype\nUInt8\n</code></pre>"},{"location":"api-reference/dtypes/#narwhals.dtypes.UInt16","title":"UInt16","text":"<p>               Bases: <code>UnsignedIntegerType</code></p> <p>16-bit unsigned integer type.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pl.Series([2, 1, 3, 7])\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.cast(nw.UInt16).dtype\nUInt16\n</code></pre>"},{"location":"api-reference/dtypes/#narwhals.dtypes.UInt32","title":"UInt32","text":"<p>               Bases: <code>UnsignedIntegerType</code></p> <p>32-bit unsigned integer type.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pl.Series([2, 1, 3, 7])\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.cast(nw.UInt32).dtype\nUInt32\n</code></pre>"},{"location":"api-reference/dtypes/#narwhals.dtypes.UInt64","title":"UInt64","text":"<p>               Bases: <code>UnsignedIntegerType</code></p> <p>64-bit unsigned integer type.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pd.Series([2, 1, 3, 7])\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.cast(nw.UInt64).dtype\nUInt64\n</code></pre>"},{"location":"api-reference/dtypes/#narwhals.dtypes.UInt128","title":"UInt128","text":"<p>               Bases: <code>UnsignedIntegerType</code></p> <p>128-bit unsigned integer type.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import duckdb\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [2, 1, 3, 7]})\n&gt;&gt;&gt; rel = duckdb.sql(\" SELECT CAST (a AS UINT128) AS a FROM df_native \")\n&gt;&gt;&gt; nw.from_native(rel).collect_schema()[\"a\"]\nUInt128\n</code></pre>"},{"location":"api-reference/dtypes/#narwhals.dtypes.TemporalType","title":"TemporalType","text":"<p>               Bases: <code>DType</code></p> <p>Base class for temporal data types.</p>"},{"location":"api-reference/dtypes/#narwhals.dtypes.Date","title":"Date","text":"<p>               Bases: <code>TemporalType</code></p> <p>Data type representing a calendar date.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import date, timedelta\n&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pa.chunked_array(\n...     [[date(2024, 12, 1) + timedelta(days=d) for d in range(4)]]\n... )\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).dtype\nDate\n</code></pre>"},{"location":"api-reference/dtypes/#narwhals.dtypes.Datetime","title":"Datetime","text":"<p>               Bases: <code>TemporalType</code></p> <p>Data type representing a calendar date and time of day.</p> <p>Parameters:</p> Name Type Description Default <code>time_unit</code> <code>TimeUnit</code> <p>Unit of time. Defaults to <code>'us'</code> (microseconds).</p> <code>'us'</code> <code>time_zone</code> <code>str | timezone | None</code> <p>Time zone string, as defined in zoneinfo (to see valid strings run <code>import zoneinfo; zoneinfo.available_timezones()</code> for a full list).</p> <code>None</code> Notes <p>Adapted from Polars implementation</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime, timedelta\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = (\n...     pl.Series([datetime(2024, 12, 9) + timedelta(days=n) for n in range(5)])\n...     .cast(pl.Datetime(\"ms\"))\n...     .dt.replace_time_zone(\"Africa/Accra\")\n... )\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).dtype\nDatetime(time_unit='ms', time_zone='Africa/Accra')\n</code></pre>"},{"location":"api-reference/dtypes/#narwhals.dtypes.Datetime.time_unit","title":"time_unit  <code>instance-attribute</code>","text":"<pre><code>time_unit: TimeUnit = time_unit\n</code></pre> <p>Unit of time.</p>"},{"location":"api-reference/dtypes/#narwhals.dtypes.Datetime.time_zone","title":"time_zone  <code>instance-attribute</code>","text":"<pre><code>time_zone: str | None = time_zone\n</code></pre> <p>Time zone string, as defined in zoneinfo.</p> Notes <p>To see valid strings run <code>import zoneinfo; zoneinfo.available_timezones()</code> for a full list.</p>"},{"location":"api-reference/dtypes/#narwhals.dtypes.Datetime.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: DType | type[DType]) -&gt; bool\n</code></pre> <p>Check if this Datetime is equivalent to another DType.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; nw.Datetime(\"s\") == nw.Datetime(\"s\")\nTrue\n&gt;&gt;&gt; nw.Datetime() == nw.Datetime(\"us\")\nTrue\n&gt;&gt;&gt; nw.Datetime(\"us\") == nw.Datetime(\"ns\")\nFalse\n&gt;&gt;&gt; nw.Datetime(\"us\", \"UTC\") == nw.Datetime(time_unit=\"us\", time_zone=\"UTC\")\nTrue\n&gt;&gt;&gt; nw.Datetime(time_zone=\"UTC\") == nw.Datetime(time_zone=\"EST\")\nFalse\n&gt;&gt;&gt; nw.Datetime() == nw.Duration()\nFalse\n&gt;&gt;&gt; nw.Datetime(\"ms\") == nw.Datetime\nTrue\n</code></pre>"},{"location":"api-reference/dtypes/#narwhals.dtypes.Duration","title":"Duration","text":"<p>               Bases: <code>TemporalType</code></p> <p>Data type representing a time duration.</p> <p>Parameters:</p> Name Type Description Default <code>time_unit</code> <code>TimeUnit</code> <p>Unit of time. Defaults to <code>'us'</code> (microseconds).</p> <code>'us'</code> Notes <p>Adapted from Polars implementation</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import timedelta\n&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pa.chunked_array(\n...     [[timedelta(seconds=d) for d in range(1, 4)]], type=pa.duration(\"ms\")\n... )\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).dtype\nDuration(time_unit='ms')\n</code></pre>"},{"location":"api-reference/dtypes/#narwhals.dtypes.Duration.time_unit","title":"time_unit  <code>instance-attribute</code>","text":"<pre><code>time_unit: TimeUnit = time_unit\n</code></pre> <p>Unit of time.</p>"},{"location":"api-reference/dtypes/#narwhals.dtypes.Duration.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: DType | type[DType]) -&gt; bool\n</code></pre> <p>Check if this Duration is equivalent to another DType.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; nw.Duration(\"us\") == nw.Duration(\"us\")\nTrue\n&gt;&gt;&gt; nw.Duration() == nw.Duration(\"us\")\nTrue\n&gt;&gt;&gt; nw.Duration(\"us\") == nw.Duration(\"ns\")\nFalse\n&gt;&gt;&gt; nw.Duration() == nw.Datetime()\nFalse\n&gt;&gt;&gt; nw.Duration(\"ms\") == nw.Duration\nTrue\n</code></pre>"},{"location":"api-reference/dtypes/#narwhals.dtypes.Time","title":"Time","text":"<p>               Bases: <code>TemporalType</code></p> <p>Data type representing the time of day.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import duckdb\n&gt;&gt;&gt; from datetime import time\n&gt;&gt;&gt; data = [time(9, 0), time(9, 1, 10), time(9, 2)]\n&gt;&gt;&gt; ser_pl = pl.Series(data)\n&gt;&gt;&gt; ser_pa = pa.chunked_array([pa.array(data, type=pa.time64(\"ns\"))])\n&gt;&gt;&gt; rel = duckdb.sql(\n...     \" SELECT * FROM (VALUES (TIME '12:00:00'), (TIME '14:30:15')) df(t)\"\n... )\n</code></pre> <pre><code>&gt;&gt;&gt; nw.from_native(ser_pl, series_only=True).dtype\nTime\n&gt;&gt;&gt; nw.from_native(ser_pa, series_only=True).dtype\nTime\n&gt;&gt;&gt; nw.from_native(rel).collect_schema()[\"t\"]\nTime\n</code></pre>"},{"location":"api-reference/dtypes/#narwhals.dtypes.NestedType","title":"NestedType","text":"<p>               Bases: <code>DType</code></p> <p>Base class for nested data types.</p>"},{"location":"api-reference/dtypes/#narwhals.dtypes.Array","title":"Array","text":"<p>               Bases: <code>NestedType</code></p> <p>Fixed length list type.</p> <p>Parameters:</p> Name Type Description Default <code>inner</code> <code>IntoDType</code> <p>The datatype of the values within each array.</p> required <code>shape</code> <code>int | tuple[int, ...]</code> <p>The shape of the arrays.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pl.Series([[1, 2], [3, 4], [5, 6]], dtype=pl.Array(pl.Int32, 2))\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).dtype\nArray(Int32, shape=(2,))\n</code></pre>"},{"location":"api-reference/dtypes/#narwhals.dtypes.Array.inner","title":"inner  <code>instance-attribute</code>","text":"<pre><code>inner: IntoDType\n</code></pre> <p>The DType of the values within each array.</p>"},{"location":"api-reference/dtypes/#narwhals.dtypes.Array.shape","title":"shape  <code>instance-attribute</code>","text":"<pre><code>shape: tuple[int, ...]\n</code></pre> <p>The shape of the arrays.</p>"},{"location":"api-reference/dtypes/#narwhals.dtypes.Array.size","title":"size  <code>instance-attribute</code>","text":"<pre><code>size: int\n</code></pre> <p>The size of the Array.</p>"},{"location":"api-reference/dtypes/#narwhals.dtypes.Array.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: DType | type[DType]) -&gt; bool\n</code></pre> <p>Check if this Array is equivalent to another DType.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; nw.Array(nw.Int64, 2) == nw.Array(nw.Int64, 2)\nTrue\n&gt;&gt;&gt; nw.Array(nw.Int64, 2) == nw.Array(nw.String, 2)\nFalse\n&gt;&gt;&gt; nw.Array(nw.Int64, 2) == nw.Array(nw.Int64, 4)\nFalse\n</code></pre> <p>If a parent type is not specific about its inner type, we infer it as equal</p> <pre><code>&gt;&gt;&gt; nw.Array(nw.Int64, 2) == nw.Array\nTrue\n</code></pre>"},{"location":"api-reference/dtypes/#narwhals.dtypes.List","title":"List","text":"<p>               Bases: <code>NestedType</code></p> <p>Variable length list type.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pd.Series(\n...     [[\"narwhal\", \"orca\"], [\"beluga\", \"vaquita\"]],\n...     dtype=pd.ArrowDtype(pa.large_list(pa.large_string())),\n... )\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).dtype\nList(String)\n</code></pre>"},{"location":"api-reference/dtypes/#narwhals.dtypes.List.inner","title":"inner  <code>instance-attribute</code>","text":"<pre><code>inner: IntoDType = inner\n</code></pre> <p>The DType of the values within each list.</p>"},{"location":"api-reference/dtypes/#narwhals.dtypes.List.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: DType | type[DType]) -&gt; bool\n</code></pre> <p>Check if this List is equivalent to another DType.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; nw.List(nw.Int64) == nw.List(nw.Int64)\nTrue\n&gt;&gt;&gt; nw.List(nw.Int64) == nw.List(nw.Float32)\nFalse\n</code></pre> <p>If a parent type is not specific about its inner type, we infer it as equal</p> <pre><code>&gt;&gt;&gt; nw.List(nw.Int64) == nw.List\nTrue\n</code></pre>"},{"location":"api-reference/dtypes/#narwhals.dtypes.Field","title":"Field","text":"<p>Definition of a single field within a <code>Struct</code> DType.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the field within its parent <code>Struct</code>.</p> required <code>dtype</code> <code>IntoDType</code> <p>The <code>DType</code> of the field's values.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = [{\"a\": 1, \"b\": [\"narwhal\", \"beluga\"]}, {\"a\": 2, \"b\": [\"orca\"]}]\n&gt;&gt;&gt; ser_pa = pa.chunked_array([data])\n&gt;&gt;&gt; nw.from_native(ser_pa, series_only=True).dtype.fields\n[Field('a', Int64), Field('b', List(String))]\n</code></pre>"},{"location":"api-reference/dtypes/#narwhals.dtypes.Field.dtype","title":"dtype  <code>instance-attribute</code>","text":"<pre><code>dtype: IntoDType = dtype\n</code></pre> <p>The <code>DType</code> of the field's values.</p>"},{"location":"api-reference/dtypes/#narwhals.dtypes.Field.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str = name\n</code></pre> <p>The name of the field within its parent <code>Struct</code>.</p>"},{"location":"api-reference/dtypes/#narwhals.dtypes.Field.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: Field) -&gt; bool\n</code></pre> <p>Check if this Field is equivalent to another Field.</p> <p>Two fields are equivalent if they have the same name and the same dtype.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; nw.Field(\"a\", nw.String) == nw.Field(\"a\", nw.String())\nTrue\n&gt;&gt;&gt; nw.Field(\"a\", nw.String) == nw.Field(\"a\", nw.String)\nTrue\n&gt;&gt;&gt; nw.Field(\"a\", nw.String) == nw.Field(\"a\", nw.Datetime)\nFalse\n&gt;&gt;&gt; nw.Field(\"a\", nw.String) == nw.Field(\"b\", nw.String)\nFalse\n&gt;&gt;&gt; nw.Field(\"a\", nw.String) == nw.String\nFalse\n</code></pre>"},{"location":"api-reference/dtypes/#narwhals.dtypes.Struct","title":"Struct","text":"<p>               Bases: <code>NestedType</code></p> <p>Struct composite type.</p> <p>Parameters:</p> Name Type Description Default <code>fields</code> <code>Sequence[Field] | Mapping[str, IntoDType]</code> <p>The fields that make up the struct. Can be either a sequence of Field objects or a mapping of column names to data types.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pa.chunked_array(\n...     [[{\"a\": 1, \"b\": [\"narwhal\", \"beluga\"]}, {\"a\": 2, \"b\": [\"orca\"]}]]\n... )\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).dtype\nStruct({'a': Int64, 'b': List(String)})\n</code></pre>"},{"location":"api-reference/dtypes/#narwhals.dtypes.Struct.fields","title":"fields  <code>instance-attribute</code>","text":"<pre><code>fields: list[Field]\n</code></pre> <p>The fields that make up the struct.</p>"},{"location":"api-reference/dtypes/#narwhals.dtypes.Struct.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: DType | type[DType]) -&gt; bool\n</code></pre> <p>Check if this Struct is equivalent to another DType.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; nw.Struct({\"a\": nw.Int64}) == nw.Struct({\"a\": nw.Int64})\nTrue\n&gt;&gt;&gt; nw.Struct({\"a\": nw.Int64}) == nw.Struct({\"a\": nw.Boolean})\nFalse\n&gt;&gt;&gt; nw.Struct({\"a\": nw.Int64}) == nw.Struct({\"b\": nw.Int64})\nFalse\n&gt;&gt;&gt; nw.Struct({\"a\": nw.Int64}) == nw.Struct([nw.Field(\"a\", nw.Int64)])\nTrue\n</code></pre> <p>If a parent type is not specific about its inner type, we infer it as equal</p> <pre><code>&gt;&gt;&gt; nw.Struct({\"a\": nw.Int64}) == nw.Struct\nTrue\n</code></pre>"},{"location":"api-reference/dtypes/#narwhals.dtypes.Struct.to_schema","title":"to_schema","text":"<pre><code>to_schema() -&gt; OrderedDict[str, IntoDType]\n</code></pre> <p>Return Struct dtype as a schema dict.</p>"},{"location":"api-reference/dtypes/#narwhals.dtypes.String","title":"String","text":"<p>               Bases: <code>DType</code></p> <p>UTF-8 encoded string type.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pd.Series([\"beluga\", \"narwhal\", \"orca\", \"vaquita\"])\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).dtype\nString\n</code></pre>"},{"location":"api-reference/dtypes/#narwhals.dtypes.Categorical","title":"Categorical","text":"<p>               Bases: <code>DType</code></p> <p>A categorical encoding of a set of strings.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pl.Series([\"beluga\", \"narwhal\", \"orca\"])\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).cast(nw.Categorical).dtype\nCategorical\n</code></pre>"},{"location":"api-reference/dtypes/#narwhals.dtypes.Enum","title":"Enum","text":"<p>               Bases: <code>DType</code></p> <p>A fixed categorical encoding of a unique set of strings.</p> <p>Polars has an Enum data type. In pandas, ordered categories get mapped to Enum. PyArrow has no Enum equivalent.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; nw.Enum([\"beluga\", \"narwhal\", \"orca\"])\nEnum(categories=['beluga', 'narwhal', 'orca'])\n</code></pre>"},{"location":"api-reference/dtypes/#narwhals.dtypes.Enum.categories","title":"categories  <code>property</code>","text":"<pre><code>categories: tuple[str, ...]\n</code></pre> <p>The categories in the dataset.</p>"},{"location":"api-reference/dtypes/#narwhals.dtypes.Enum.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: DType | type[DType]) -&gt; bool\n</code></pre> <p>Check if this Enum is equivalent to another DType.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; nw.Enum([\"a\", \"b\", \"c\"]) == nw.Enum([\"a\", \"b\", \"c\"])\nTrue\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; categories = pl.Series([\"a\", \"b\", \"c\"])\n&gt;&gt;&gt; nw.Enum([\"a\", \"b\", \"c\"]) == nw.Enum(categories)\nTrue\n&gt;&gt;&gt; nw.Enum([\"a\", \"b\", \"c\"]) == nw.Enum([\"b\", \"a\", \"c\"])\nFalse\n&gt;&gt;&gt; nw.Enum([\"a\", \"b\", \"c\"]) == nw.Enum([\"a\"])\nFalse\n&gt;&gt;&gt; nw.Enum([\"a\", \"b\", \"c\"]) == nw.Categorical\nFalse\n&gt;&gt;&gt; nw.Enum([\"a\", \"b\", \"c\"]) == nw.Enum\nTrue\n</code></pre>"},{"location":"api-reference/dtypes/#narwhals.dtypes.Binary","title":"Binary","text":"<p>               Bases: <code>DType</code></p> <p>Binary type.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import duckdb\n&gt;&gt;&gt; data = [b\"test1\", b\"test2\"]\n&gt;&gt;&gt; ser_pl = pl.Series(data, dtype=pl.Binary)\n&gt;&gt;&gt; ser_pa = pa.chunked_array([pa.array(data, type=pa.binary())])\n&gt;&gt;&gt; rel = duckdb.sql(\n...     \"SELECT * FROM (VALUES (BLOB 'test1'), (BLOB 'test2')) AS df(t)\"\n... )\n</code></pre> <pre><code>&gt;&gt;&gt; nw.from_native(ser_pl, series_only=True).dtype\nBinary\n&gt;&gt;&gt; nw.from_native(ser_pa, series_only=True).dtype\nBinary\n&gt;&gt;&gt; nw.from_native(rel).collect_schema()[\"t\"]\nBinary\n</code></pre>"},{"location":"api-reference/dtypes/#narwhals.dtypes.Boolean","title":"Boolean","text":"<p>               Bases: <code>DType</code></p> <p>Boolean type.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pa.chunked_array([[True, False, False, True]])\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).dtype\nBoolean\n</code></pre>"},{"location":"api-reference/dtypes/#narwhals.dtypes.Object","title":"Object","text":"<p>               Bases: <code>DType</code></p> <p>Data type for wrapping arbitrary Python objects.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; class Foo: ...\n&gt;&gt;&gt; s_native = pd.Series([Foo(), Foo()])\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).dtype\nObject\n</code></pre>"},{"location":"api-reference/dtypes/#narwhals.dtypes.Unknown","title":"Unknown","text":"<p>               Bases: <code>DType</code></p> <p>Type representing DataType values that could not be determined statically.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pd.Series(pd.period_range(\"2000-01\", periods=4, freq=\"M\"))\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).dtype\nUnknown\n</code></pre>"},{"location":"api-reference/exceptions/","title":"<code>narwhals.exceptions</code>","text":""},{"location":"api-reference/exceptions/#narwhals.exceptions.ColumnNotFoundError","title":"ColumnNotFoundError","text":"<p>Exception raised when column name isn't present.</p>"},{"location":"api-reference/exceptions/#narwhals.exceptions.InvalidIntoExprError","title":"InvalidIntoExprError","text":"<p>Exception raised when object can't be converted to expression.</p>"},{"location":"api-reference/exceptions/#narwhals.exceptions.InvalidOperationError","title":"InvalidOperationError","text":"<p>Exception raised during invalid operations.</p>"},{"location":"api-reference/exceptions/#narwhals.exceptions.NarwhalsUnstableWarning","title":"NarwhalsUnstableWarning","text":"<p>Warning issued when a method or function is considered unstable in the stable api.</p>"},{"location":"api-reference/expr/","title":"<code>narwhals.Expr</code>","text":""},{"location":"api-reference/expr/#narwhals.Expr.abs","title":"abs","text":"<pre><code>abs() -&gt; Self\n</code></pre> <p>Return absolute value of each element.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [1, -2], \"b\": [-3, 4]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(nw.col(\"a\", \"b\").abs().name.suffix(\"_abs\"))\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n| Narwhals DataFrame  |\n|---------------------|\n|   a  b  a_abs  b_abs|\n|0  1 -3      1      3|\n|1 -2  4      2      4|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.alias","title":"alias","text":"<pre><code>alias(name: str) -&gt; Self\n</code></pre> <p>Rename the expression.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The new name.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [1, 2], \"b\": [4, 5]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.select((nw.col(\"b\") + 10).alias(\"c\"))\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|          c       |\n|      0  14       |\n|      1  15       |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.all","title":"all","text":"<pre><code>all() -&gt; Self\n</code></pre> <p>Return whether all values in the column are <code>True</code>.</p> <p>If there are no non-null elements, the result is <code>True</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [True, False], \"b\": [True, True]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.select(nw.col(\"a\", \"b\").all())\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|         a     b  |\n|  0  False  True  |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.any","title":"any","text":"<pre><code>any() -&gt; Self\n</code></pre> <p>Return whether any of the values in the column are <code>True</code>.</p> <p>If there are no non-null elements, the result is <code>False</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [True, False], \"b\": [True, True]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.select(nw.col(\"a\", \"b\").any())\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|        a     b   |\n|  0  True  True   |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.cast","title":"cast","text":"<pre><code>cast(dtype: IntoDType) -&gt; Self\n</code></pre> <p>Redefine an object's data type.</p> <p>Parameters:</p> Name Type Description Default <code>dtype</code> <code>IntoDType</code> <p>Data type that the object will be cast into.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"foo\": [1, 2, 3], \"bar\": [6.0, 7.0, 8.0]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.select(nw.col(\"foo\").cast(nw.Float32), nw.col(\"bar\").cast(nw.UInt8))\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|      foo  bar    |\n|   0  1.0    6    |\n|   1  2.0    7    |\n|   2  3.0    8    |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.ceil","title":"ceil","text":"<pre><code>ceil() -&gt; Self\n</code></pre> <p>Compute the numerical ceiling.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pa.table({\"values\": [1.1, 4.3, -1.3]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; result = df.with_columns(ceil=nw.col(\"values\").ceil())\n&gt;&gt;&gt; result\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|   Narwhals DataFrame   |\n|------------------------|\n|pyarrow.Table           |\n|values: double          |\n|ceil: double            |\n|----                    |\n|values: [[1.1,4.3,-1.3]]|\n|ceil: [[2,5,-1]]        |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.clip","title":"clip","text":"<pre><code>clip(\n    lower_bound: (\n        IntoExpr | NumericLiteral | TemporalLiteral | None\n    ) = None,\n    upper_bound: (\n        IntoExpr | NumericLiteral | TemporalLiteral | None\n    ) = None,\n) -&gt; Self\n</code></pre> <p>Clip values in the Series.</p> <p>Parameters:</p> Name Type Description Default <code>lower_bound</code> <code>IntoExpr | NumericLiteral | TemporalLiteral | None</code> <p>Lower bound value. String literals are treated as column names.</p> <code>None</code> <code>upper_bound</code> <code>IntoExpr | NumericLiteral | TemporalLiteral | None</code> <p>Upper bound value. String literals are treated as column names.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [1, 2, 3]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(a_clipped=nw.col(\"a\").clip(-1, 3))\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|    a  a_clipped  |\n| 0  1          1  |\n| 1  2          2  |\n| 2  3          3  |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.count","title":"count","text":"<pre><code>count() -&gt; Self\n</code></pre> <p>Returns the number of non-null elements in the column.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [1, 2, 3], \"b\": [None, 4, 4]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.select(nw.all().count())\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|        a  b      |\n|     0  3  2      |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.cum_count","title":"cum_count","text":"<pre><code>cum_count(*, reverse: bool = False) -&gt; Self\n</code></pre> <p>Return the cumulative count of the non-null values in the column.</p> Info <p>For lazy backends, this operation must be followed by <code>Expr.over</code> with <code>order_by</code> specified, see order-dependence.</p> <p>Parameters:</p> Name Type Description Default <code>reverse</code> <code>bool</code> <p>reverse the operation</p> <code>False</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [\"x\", \"k\", None, \"d\"]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(\n...     nw.col(\"a\").cum_count().alias(\"a_cum_count\"),\n...     nw.col(\"a\").cum_count(reverse=True).alias(\"a_cum_count_reverse\"),\n... )\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|           Narwhals DataFrame            |\n|-----------------------------------------|\n|      a  a_cum_count  a_cum_count_reverse|\n|0     x            1                    3|\n|1     k            2                    2|\n|2  None            2                    1|\n|3     d            3                    1|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.cum_max","title":"cum_max","text":"<pre><code>cum_max(*, reverse: bool = False) -&gt; Self\n</code></pre> <p>Return the cumulative max of the non-null values in the column.</p> Info <p>For lazy backends, this operation must be followed by <code>Expr.over</code> with <code>order_by</code> specified, see order-dependence.</p> <p>Parameters:</p> Name Type Description Default <code>reverse</code> <code>bool</code> <p>reverse the operation</p> <code>False</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [1, 3, None, 2]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(\n...     nw.col(\"a\").cum_max().alias(\"a_cum_max\"),\n...     nw.col(\"a\").cum_max(reverse=True).alias(\"a_cum_max_reverse\"),\n... )\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|         Narwhals DataFrame         |\n|------------------------------------|\n|     a  a_cum_max  a_cum_max_reverse|\n|0  1.0        1.0                3.0|\n|1  3.0        3.0                3.0|\n|2  NaN        NaN                NaN|\n|3  2.0        3.0                2.0|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.cum_min","title":"cum_min","text":"<pre><code>cum_min(*, reverse: bool = False) -&gt; Self\n</code></pre> <p>Return the cumulative min of the non-null values in the column.</p> Info <p>For lazy backends, this operation must be followed by <code>Expr.over</code> with <code>order_by</code> specified, see order-dependence.</p> <p>Parameters:</p> Name Type Description Default <code>reverse</code> <code>bool</code> <p>reverse the operation</p> <code>False</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [3, 1, None, 2]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(\n...     nw.col(\"a\").cum_min().alias(\"a_cum_min\"),\n...     nw.col(\"a\").cum_min(reverse=True).alias(\"a_cum_min_reverse\"),\n... )\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|         Narwhals DataFrame         |\n|------------------------------------|\n|     a  a_cum_min  a_cum_min_reverse|\n|0  3.0        3.0                1.0|\n|1  1.0        1.0                1.0|\n|2  NaN        NaN                NaN|\n|3  2.0        1.0                2.0|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.cum_prod","title":"cum_prod","text":"<pre><code>cum_prod(*, reverse: bool = False) -&gt; Self\n</code></pre> <p>Return the cumulative product of the non-null values in the column.</p> Info <p>For lazy backends, this operation must be followed by <code>Expr.over</code> with <code>order_by</code> specified, see order-dependence.</p> <p>Parameters:</p> Name Type Description Default <code>reverse</code> <code>bool</code> <p>reverse the operation</p> <code>False</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [1, 3, None, 2]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(\n...     nw.col(\"a\").cum_prod().alias(\"a_cum_prod\"),\n...     nw.col(\"a\").cum_prod(reverse=True).alias(\"a_cum_prod_reverse\"),\n... )\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|          Narwhals DataFrame          |\n|--------------------------------------|\n|     a  a_cum_prod  a_cum_prod_reverse|\n|0  1.0         1.0                 6.0|\n|1  3.0         3.0                 6.0|\n|2  NaN         NaN                 NaN|\n|3  2.0         6.0                 2.0|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.cum_sum","title":"cum_sum","text":"<pre><code>cum_sum(*, reverse: bool = False) -&gt; Self\n</code></pre> <p>Return cumulative sum.</p> Info <p>For lazy backends, this operation must be followed by <code>Expr.over</code> with <code>order_by</code> specified, see order-dependence.</p> <p>Parameters:</p> Name Type Description Default <code>reverse</code> <code>bool</code> <p>reverse the operation</p> <code>False</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [1, 1, 3, 5, 5], \"b\": [2, 4, 4, 6, 6]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(a_cum_sum=nw.col(\"a\").cum_sum())\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|   a  b  a_cum_sum|\n|0  1  2          1|\n|1  1  4          2|\n|2  3  4          5|\n|3  5  6         10|\n|4  5  6         15|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.diff","title":"diff","text":"<pre><code>diff() -&gt; Self\n</code></pre> <p>Returns the difference between each element and the previous one.</p> Info <p>For lazy backends, this operation must be followed by <code>Expr.over</code> with <code>order_by</code> specified, see order-dependence.</p> Notes <p>pandas may change the dtype here, for example when introducing missing values in an integer column. To ensure, that the dtype doesn't change, you may want to use <code>fill_null</code> and <code>cast</code>. For example, to calculate the diff and fill missing values with <code>0</code> in a Int64 column, you could do:</p> <pre><code>nw.col(\"a\").diff().fill_null(0).cast(nw.Int64)\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pl.DataFrame({\"a\": [1, 1, 3, 5, 5]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(a_diff=nw.col(\"a\").diff())\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n| shape: (5, 2)    |\n| \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 |\n| \u2502 a   \u2506 a_diff \u2502 |\n| \u2502 --- \u2506 ---    \u2502 |\n| \u2502 i64 \u2506 i64    \u2502 |\n| \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 |\n| \u2502 1   \u2506 null   \u2502 |\n| \u2502 1   \u2506 0      \u2502 |\n| \u2502 3   \u2506 2      \u2502 |\n| \u2502 5   \u2506 2      \u2502 |\n| \u2502 5   \u2506 0      \u2502 |\n| \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.drop_nulls","title":"drop_nulls","text":"<pre><code>drop_nulls() -&gt; Self\n</code></pre> <p>Drop null values.</p> Notes <p>pandas handles null values differently from Polars and PyArrow. See null_handling for reference.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pl.DataFrame({\"a\": [2.0, 4.0, float(\"nan\"), 3.0, None, 5.0]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.select(nw.col(\"a\").drop_nulls())\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|  shape: (5, 1)   |\n|  \u250c\u2500\u2500\u2500\u2500\u2500\u2510         |\n|  \u2502 a   \u2502         |\n|  \u2502 --- \u2502         |\n|  \u2502 f64 \u2502         |\n|  \u255e\u2550\u2550\u2550\u2550\u2550\u2561         |\n|  \u2502 2.0 \u2502         |\n|  \u2502 4.0 \u2502         |\n|  \u2502 NaN \u2502         |\n|  \u2502 3.0 \u2502         |\n|  \u2502 5.0 \u2502         |\n|  \u2514\u2500\u2500\u2500\u2500\u2500\u2518         |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.ewm_mean","title":"ewm_mean","text":"<pre><code>ewm_mean(\n    *,\n    com: float | None = None,\n    span: float | None = None,\n    half_life: float | None = None,\n    alpha: float | None = None,\n    adjust: bool = True,\n    min_samples: int = 1,\n    ignore_nulls: bool = False\n) -&gt; Self\n</code></pre> <p>Compute exponentially-weighted moving average.</p> <p>Parameters:</p> Name Type Description Default <code>com</code> <code>float | None</code> <p>Specify decay in terms of center of mass, \\(\\gamma\\), with  \\(\\alpha = \\frac{1}{1+\\gamma}\\forall\\gamma\\geq0\\)</p> <code>None</code> <code>span</code> <code>float | None</code> <p>Specify decay in terms of span, \\(\\theta\\), with  \\(\\alpha = \\frac{2}{\\theta + 1} \\forall \\theta \\geq 1\\)</p> <code>None</code> <code>half_life</code> <code>float | None</code> <p>Specify decay in terms of half-life, \\(\\tau\\), with  \\(\\alpha = 1 - \\exp \\left\\{ \\frac{ -\\ln(2) }{ \\tau } \\right\\} \\forall \\tau &gt; 0\\)</p> <code>None</code> <code>alpha</code> <code>float | None</code> <p>Specify smoothing factor alpha directly, \\(0 &lt; \\alpha \\leq 1\\).</p> <code>None</code> <code>adjust</code> <code>bool</code> <p>Divide by decaying adjustment factor in beginning periods to account for imbalance in relative weightings</p> <ul> <li>When <code>adjust=True</code> (the default) the EW function is calculated   using weights \\(w_i = (1 - \\alpha)^i\\)</li> <li>When <code>adjust=False</code> the EW function is calculated recursively by   $$   y_0=x_0   $$   $$   y_t = (1 - \\alpha)y_{t - 1} + \\alpha x_t   $$</li> </ul> <code>True</code> <code>min_samples</code> <code>int</code> <p>Minimum number of observations in window required to have a value, (otherwise result is null).</p> <code>1</code> <code>ignore_nulls</code> <code>bool</code> <p>Ignore missing values when calculating weights.</p> <ul> <li>When <code>ignore_nulls=False</code> (default), weights are based on absolute   positions.   For example, the weights of \\(x_0\\) and \\(x_2\\) used in   calculating the final weighted average of \\([x_0, None, x_2]\\) are   \\((1-\\alpha)^2\\) and \\(1\\) if <code>adjust=True</code>, and   \\((1-\\alpha)^2\\) and \\(\\alpha\\) if <code>adjust=False</code>.</li> <li>When <code>ignore_nulls=True</code>, weights are based   on relative positions. For example, the weights of   \\(x_0\\) and \\(x_2\\) used in calculating the final weighted   average of \\([x_0, None, x_2]\\) are   \\(1-\\alpha\\) and \\(1\\) if <code>adjust=True</code>,   and \\(1-\\alpha\\) and \\(\\alpha\\) if <code>adjust=False</code>.</li> </ul> <code>False</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; from narwhals.typing import IntoFrameT\n&gt;&gt;&gt;\n&gt;&gt;&gt; data = {\"a\": [1, 2, 3]}\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n</code></pre> <p>We define a library agnostic function:</p> <pre><code>&gt;&gt;&gt; def agnostic_ewm_mean(df_native: IntoFrameT) -&gt; IntoFrameT:\n...     df = nw.from_native(df_native)\n...     return df.select(\n...         nw.col(\"a\").ewm_mean(com=1, ignore_nulls=False)\n...     ).to_native()\n</code></pre> <p>We can then pass either pandas or Polars to <code>agnostic_ewm_mean</code>:</p> <pre><code>&gt;&gt;&gt; agnostic_ewm_mean(df_pd)\n          a\n0  1.000000\n1  1.666667\n2  2.428571\n</code></pre> <pre><code>&gt;&gt;&gt; agnostic_ewm_mean(df_pl)\nshape: (3, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a        \u2502\n\u2502 ---      \u2502\n\u2502 f64      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1.0      \u2502\n\u2502 1.666667 \u2502\n\u2502 2.428571 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.exp","title":"exp","text":"<pre><code>exp() -&gt; Self\n</code></pre> <p>Compute the exponent.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pa.table({\"values\": [-1, 0, 1]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; result = df.with_columns(exp=nw.col(\"values\").exp())\n&gt;&gt;&gt; result\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|               Narwhals DataFrame               |\n|------------------------------------------------|\n|pyarrow.Table                                   |\n|values: int64                                   |\n|exp: double                                     |\n|----                                            |\n|values: [[-1,0,1]]                              |\n|exp: [[0.36787944117144233,1,2.718281828459045]]|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.fill_nan","title":"fill_nan","text":"<pre><code>fill_nan(value: float | None) -&gt; Self\n</code></pre> <p>Fill floating point NaN values with given value.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float | None</code> <p>Value used to fill NaN values.</p> required Notes <p>This function only fills <code>'NaN'</code> values, not null ones, except for pandas which doesn't distinguish between them. See null_handling for reference.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import duckdb\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = duckdb.sql(\n...     \"SELECT * FROM VALUES (5.::DOUBLE, 50.::DOUBLE), ('NaN', null) df(a, b)\"\n... )\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(nw.col(\"a\", \"b\").fill_nan(0).name.suffix(\"_nans_filled\"))\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|                Narwhals LazyFrame                 |\n|---------------------------------------------------|\n|\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510|\n|\u2502   a    \u2502   b    \u2502 a_nans_filled \u2502 b_nans_filled \u2502|\n|\u2502 double \u2502 double \u2502    double     \u2502    double     \u2502|\n|\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524|\n|\u2502    5.0 \u2502   50.0 \u2502           5.0 \u2502          50.0 \u2502|\n|\u2502    nan \u2502   NULL \u2502           0.0 \u2502          NULL \u2502|\n|\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.fill_null","title":"fill_null","text":"<pre><code>fill_null(\n    value: Expr | NonNestedLiteral = None,\n    strategy: FillNullStrategy | None = None,\n    limit: int | None = None,\n) -&gt; Self\n</code></pre> <p>Fill null values with given value.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Expr | NonNestedLiteral</code> <p>Value or expression used to fill null values.</p> <code>None</code> <code>strategy</code> <code>FillNullStrategy | None</code> <p>Strategy used to fill null values.</p> <code>None</code> <code>limit</code> <code>int | None</code> <p>Number of consecutive null values to fill when using the 'forward' or 'backward' strategy.</p> <code>None</code> Notes <ul> <li>pandas handles null values differently from other libraries.   See null_handling   for reference.</li> <li>For pandas Series of <code>object</code> dtype, <code>fill_null</code> will not automatically change the   Series' dtype as pandas used to do. Explicitly call <code>cast</code> if you want the dtype to change.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pl.DataFrame(\n...     {\n...         \"a\": [2, None, None, 3],\n...         \"b\": [2.0, float(\"nan\"), float(\"nan\"), 3.0],\n...         \"c\": [1, 2, 3, 4],\n...     }\n... )\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(\n...     nw.col(\"a\", \"b\").fill_null(0).name.suffix(\"_filled\"),\n...     nw.col(\"a\").fill_null(nw.col(\"c\")).name.suffix(\"_filled_with_c\"),\n... )\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|                     Narwhals DataFrame                     |\n|------------------------------------------------------------|\n|shape: (4, 6)                                               |\n|\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510|\n|\u2502 a    \u2506 b   \u2506 c   \u2506 a_filled \u2506 b_filled \u2506 a_filled_with_c \u2502|\n|\u2502 ---  \u2506 --- \u2506 --- \u2506 ---      \u2506 ---      \u2506 ---             \u2502|\n|\u2502 i64  \u2506 f64 \u2506 i64 \u2506 i64      \u2506 f64      \u2506 i64             \u2502|\n|\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561|\n|\u2502 2    \u2506 2.0 \u2506 1   \u2506 2        \u2506 2.0      \u2506 2               \u2502|\n|\u2502 null \u2506 NaN \u2506 2   \u2506 0        \u2506 NaN      \u2506 2               \u2502|\n|\u2502 null \u2506 NaN \u2506 3   \u2506 0        \u2506 NaN      \u2506 3               \u2502|\n|\u2502 3    \u2506 3.0 \u2506 4   \u2506 3        \u2506 3.0      \u2506 3               \u2502|\n|\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Using a strategy:</p> <pre><code>&gt;&gt;&gt; df.select(\n...     nw.col(\"a\", \"b\"),\n...     nw.col(\"a\", \"b\")\n...     .fill_null(strategy=\"forward\", limit=1)\n...     .name.suffix(\"_nulls_forward_filled\"),\n... )\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|                       Narwhals DataFrame                       |\n|----------------------------------------------------------------|\n|shape: (4, 4)                                                   |\n|\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510|\n|\u2502 a    \u2506 b   \u2506 a_nulls_forward_filled \u2506 b_nulls_forward_filled \u2502|\n|\u2502 ---  \u2506 --- \u2506 ---                    \u2506 ---                    \u2502|\n|\u2502 i64  \u2506 f64 \u2506 i64                    \u2506 f64                    \u2502|\n|\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561|\n|\u2502 2    \u2506 2.0 \u2506 2                      \u2506 2.0                    \u2502|\n|\u2502 null \u2506 NaN \u2506 2                      \u2506 NaN                    \u2502|\n|\u2502 null \u2506 NaN \u2506 null                   \u2506 NaN                    \u2502|\n|\u2502 3    \u2506 3.0 \u2506 3                      \u2506 3.0                    \u2502|\n|\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.filter","title":"filter","text":"<pre><code>filter(*predicates: Any) -&gt; Self\n</code></pre> <p>Filters elements based on a condition, returning a new expression.</p> <p>Parameters:</p> Name Type Description Default <code>predicates</code> <code>Any</code> <p>Conditions to filter by (which get AND-ed together).</p> <code>()</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame(\n...     {\"a\": [2, 3, 4, 5, 6, 7], \"b\": [10, 11, 12, 13, 14, 15]}\n... )\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.select(\n...     nw.col(\"a\").filter(nw.col(\"a\") &gt; 4),\n...     nw.col(\"b\").filter(nw.col(\"b\") &lt; 13),\n... )\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|        a   b     |\n|     3  5  10     |\n|     4  6  11     |\n|     5  7  12     |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.first","title":"first","text":"<pre><code>first() -&gt; Self\n</code></pre> <p>Get the first value.</p> Notes <p>For lazy backends, this can only be used with <code>over</code>. We may introduce <code>min_by</code> in the future so it can be used as an aggregation.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = {\"a\": [1, 1, 2, 2], \"b\": [\"foo\", None, None, \"baz\"]}\n&gt;&gt;&gt; df_native = pd.DataFrame(data)\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.select(nw.all().first())\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|       a    b     |\n|    0  1  foo     |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <pre><code>&gt;&gt;&gt; df.group_by(\"a\").agg(nw.col(\"b\").first())\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|       a     b    |\n|    0  1   foo    |\n|    1  2  None    |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.floor","title":"floor","text":"<pre><code>floor() -&gt; Self\n</code></pre> <p>Compute the numerical floor.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pa.table({\"values\": [1.1, 4.3, -1.3]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; result = df.with_columns(floor=nw.col(\"values\").floor())\n&gt;&gt;&gt; result\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|   Narwhals DataFrame   |\n|------------------------|\n|pyarrow.Table           |\n|values: double          |\n|floor: double           |\n|----                    |\n|values: [[1.1,4.3,-1.3]]|\n|floor: [[1,4,-2]]       |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.is_between","title":"is_between","text":"<pre><code>is_between(\n    lower_bound: Any | IntoExpr,\n    upper_bound: Any | IntoExpr,\n    closed: ClosedInterval = \"both\",\n) -&gt; Self\n</code></pre> <p>Check if this expression is between the given lower and upper bounds.</p> <p>Parameters:</p> Name Type Description Default <code>lower_bound</code> <code>Any | IntoExpr</code> <p>Lower bound value. String literals are interpreted as column names.</p> required <code>upper_bound</code> <code>Any | IntoExpr</code> <p>Upper bound value. String literals are interpreted as column names.</p> required <code>closed</code> <code>ClosedInterval</code> <p>Define which sides of the interval are closed (inclusive).</p> <code>'both'</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [1, 2, 3, 4, 5]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(b=nw.col(\"a\").is_between(2, 4, \"right\"))\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|      a      b    |\n|   0  1  False    |\n|   1  2  False    |\n|   2  3   True    |\n|   3  4   True    |\n|   4  5  False    |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.is_close","title":"is_close","text":"<pre><code>is_close(\n    other: Expr | Series[Any] | NumericLiteral,\n    *,\n    abs_tol: float = 0.0,\n    rel_tol: float = 1e-09,\n    nans_equal: bool = False\n) -&gt; Self\n</code></pre> <p>Check if this expression is close, i.e. almost equal, to the other expression.</p> <p>Two values <code>a</code> and <code>b</code> are considered close if the following condition holds:</p> \\[ |a-b| \\le max \\{ \\text{rel\\_tol} \\cdot max \\{ |a|, |b| \\}, \\text{abs\\_tol} \\} \\] <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Expr | Series[Any] | NumericLiteral</code> <p>Values to compare with.</p> required <code>abs_tol</code> <code>float</code> <p>Absolute tolerance. This is the maximum allowed absolute difference between two values. Must be non-negative.</p> <code>0.0</code> <code>rel_tol</code> <code>float</code> <p>Relative tolerance. This is the maximum allowed difference between two values, relative to the larger absolute value. Must be in the range [0, 1).</p> <code>1e-09</code> <code>nans_equal</code> <code>bool</code> <p>Whether NaN values should be considered equal.</p> <code>False</code> Notes <p>The implementation of this method is symmetric and mirrors the behavior of <code>math.isclose</code>. Specifically note that this behavior is different to <code>numpy.isclose</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import duckdb\n&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; data = {\n...     \"x\": [1.0, float(\"inf\"), 1.41, None, float(\"nan\")],\n...     \"y\": [1.2, float(\"inf\"), 1.40, None, float(\"nan\")],\n... }\n&gt;&gt;&gt; _table = pa.table(data)\n&gt;&gt;&gt; df_native = duckdb.table(\"_table\")\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(\n...     is_close=nw.col(\"x\").is_close(\n...         nw.col(\"y\"), abs_tol=0.1, nans_equal=True\n...     )\n... )\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|      Narwhals LazyFrame      |\n|------------------------------|\n|\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510|\n|\u2502   x    \u2502   y    \u2502 is_close \u2502|\n|\u2502 double \u2502 double \u2502 boolean  \u2502|\n|\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524|\n|\u2502    1.0 \u2502    1.2 \u2502 false    \u2502|\n|\u2502    inf \u2502    inf \u2502 true     \u2502|\n|\u2502   1.41 \u2502    1.4 \u2502 true     \u2502|\n|\u2502   NULL \u2502   NULL \u2502 NULL     \u2502|\n|\u2502    nan \u2502    nan \u2502 true     \u2502|\n|\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.is_duplicated","title":"is_duplicated","text":"<pre><code>is_duplicated() -&gt; Self\n</code></pre> <p>Return a boolean mask indicating duplicated values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [1, 2, 3, 1], \"b\": [\"a\", \"a\", \"b\", \"c\"]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(nw.all().is_duplicated().name.suffix(\"_is_duplicated\"))\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|           Narwhals DataFrame            |\n|-----------------------------------------|\n|   a  b  a_is_duplicated  b_is_duplicated|\n|0  1  a             True             True|\n|1  2  a            False             True|\n|2  3  b            False            False|\n|3  1  c             True            False|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.is_finite","title":"is_finite","text":"<pre><code>is_finite() -&gt; Self\n</code></pre> <p>Returns boolean values indicating which original values are finite.</p> Warning <p>pandas handles null values differently from Polars and PyArrow. See null_handling for reference. <code>is_finite</code> will return False for NaN and Null's in the Dask and pandas non-nullable backend, while for Polars, PyArrow and pandas nullable backends null values are kept as such.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pl.DataFrame({\"a\": [float(\"nan\"), float(\"inf\"), 2.0, None]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(a_is_finite=nw.col(\"a\").is_finite())\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|  Narwhals DataFrame  |\n|----------------------|\n|shape: (4, 2)         |\n|\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510|\n|\u2502 a    \u2506 a_is_finite \u2502|\n|\u2502 ---  \u2506 ---         \u2502|\n|\u2502 f64  \u2506 bool        \u2502|\n|\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561|\n|\u2502 NaN  \u2506 false       \u2502|\n|\u2502 inf  \u2506 false       \u2502|\n|\u2502 2.0  \u2506 true        \u2502|\n|\u2502 null \u2506 null        \u2502|\n|\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.is_first_distinct","title":"is_first_distinct","text":"<pre><code>is_first_distinct() -&gt; Self\n</code></pre> <p>Return a boolean mask indicating the first occurrence of each distinct value.</p> Info <p>For lazy backends, this operation must be followed by <code>Expr.over</code> with <code>order_by</code> specified, see order-dependence.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [1, 2, 3, 1], \"b\": [\"a\", \"a\", \"b\", \"c\"]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(\n...     nw.all().is_first_distinct().name.suffix(\"_is_first_distinct\")\n... )\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|               Narwhals DataFrame                |\n|-------------------------------------------------|\n|   a  b  a_is_first_distinct  b_is_first_distinct|\n|0  1  a                 True                 True|\n|1  2  a                 True                False|\n|2  3  b                 True                 True|\n|3  1  c                False                 True|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.is_in","title":"is_in","text":"<pre><code>is_in(other: Any) -&gt; Self\n</code></pre> <p>Check if elements of this expression are present in the other iterable.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>iterable</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [1, 2, 9, 10]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(b=nw.col(\"a\").is_in([1, 2]))\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|       a      b   |\n|   0   1   True   |\n|   1   2   True   |\n|   2   9  False   |\n|   3  10  False   |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.is_last_distinct","title":"is_last_distinct","text":"<pre><code>is_last_distinct() -&gt; Self\n</code></pre> <p>Return a boolean mask indicating the last occurrence of each distinct value.</p> Info <p>For lazy backends, this operation must be followed by <code>Expr.over</code> with <code>order_by</code> specified, see order-dependence.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [1, 2, 3, 1], \"b\": [\"a\", \"a\", \"b\", \"c\"]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(\n...     nw.all().is_last_distinct().name.suffix(\"_is_last_distinct\")\n... )\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|              Narwhals DataFrame               |\n|-----------------------------------------------|\n|   a  b  a_is_last_distinct  b_is_last_distinct|\n|0  1  a               False               False|\n|1  2  a                True                True|\n|2  3  b                True                True|\n|3  1  c                True                True|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.is_nan","title":"is_nan","text":"<pre><code>is_nan() -&gt; Self\n</code></pre> <p>Indicate which values are NaN.</p> Notes <p>pandas handles null values differently from Polars and PyArrow. See null_handling for reference.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import duckdb\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = duckdb.sql(\n...     \"SELECT * FROM VALUES (null, CAST('NaN' AS DOUBLE)), (2, 2.) df(a, b)\"\n... )\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(\n...     a_is_nan=nw.col(\"a\").is_nan(), b_is_nan=nw.col(\"b\").is_nan()\n... )\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|           Narwhals LazyFrame           |\n|----------------------------------------|\n|\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510|\n|\u2502   a   \u2502   b    \u2502 a_is_nan \u2502 b_is_nan \u2502|\n|\u2502 int32 \u2502 double \u2502 boolean  \u2502 boolean  \u2502|\n|\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524|\n|\u2502  NULL \u2502    nan \u2502 NULL     \u2502 true     \u2502|\n|\u2502     2 \u2502    2.0 \u2502 false    \u2502 false    \u2502|\n|\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.is_null","title":"is_null","text":"<pre><code>is_null() -&gt; Self\n</code></pre> <p>Returns a boolean Series indicating which values are null.</p> Notes <p>pandas handles null values differently from Polars and PyArrow. See null_handling for reference.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import duckdb\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = duckdb.sql(\n...     \"SELECT * FROM VALUES (null, CAST('NaN' AS DOUBLE)), (2, 2.) df(a, b)\"\n... )\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(\n...     a_is_null=nw.col(\"a\").is_null(), b_is_null=nw.col(\"b\").is_null()\n... )\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|            Narwhals LazyFrame            |\n|------------------------------------------|\n|\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510|\n|\u2502   a   \u2502   b    \u2502 a_is_null \u2502 b_is_null \u2502|\n|\u2502 int32 \u2502 double \u2502  boolean  \u2502  boolean  \u2502|\n|\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524|\n|\u2502  NULL \u2502    nan \u2502 true      \u2502 false     \u2502|\n|\u2502     2 \u2502    2.0 \u2502 false     \u2502 false     \u2502|\n|\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.is_unique","title":"is_unique","text":"<pre><code>is_unique() -&gt; Self\n</code></pre> <p>Return a boolean mask indicating unique values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [1, 2, 3, 1], \"b\": [\"a\", \"a\", \"b\", \"c\"]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(nw.all().is_unique().name.suffix(\"_is_unique\"))\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|       Narwhals DataFrame        |\n|---------------------------------|\n|   a  b  a_is_unique  b_is_unique|\n|0  1  a        False        False|\n|1  2  a         True        False|\n|2  3  b         True         True|\n|3  1  c        False         True|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.kurtosis","title":"kurtosis","text":"<pre><code>kurtosis() -&gt; Self\n</code></pre> <p>Compute the kurtosis (Fisher's definition) without bias correction.</p> <p>Kurtosis is the fourth central moment divided by the square of the variance. The Fisher's definition is used where 3.0 is subtracted from the result to give 0.0 for a normal distribution.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [1, 2, 3, 4, 5], \"b\": [1, 1, 2, 10, 100]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.select(nw.col(\"a\", \"b\").kurtosis())\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|      a         b |\n| 0 -1.3  0.210657 |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.last","title":"last","text":"<pre><code>last() -&gt; Self\n</code></pre> <p>Get the last value.</p> Notes <p>For lazy backends, this can only be used with <code>over</code>. We may introduce <code>max_by</code> in the future so it can be used as an aggregation.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = {\"a\": [1, 1, 2, 2], \"b\": [\"foo\", None, None, \"baz\"]}\n&gt;&gt;&gt; df_native = pa.table(data)\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.select(nw.all().last())\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|  pyarrow.Table   |\n|  a: int64        |\n|  b: string       |\n|  ----            |\n|  a: [[2]]        |\n|  b: [[\"baz\"]]    |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <pre><code>&gt;&gt;&gt; df.group_by(\"a\").agg(nw.col(\"b\").last())\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|pyarrow.Table     |\n|a: int64          |\n|b: string         |\n|----              |\n|a: [[1,2]]        |\n|b: [[null,\"baz\"]] |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.len","title":"len","text":"<pre><code>len() -&gt; Self\n</code></pre> <p>Return the number of elements in the column.</p> <p>Null values count towards the total.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [\"x\", \"y\", \"z\"], \"b\": [1, 2, 1]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.select(\n...     nw.col(\"a\").filter(nw.col(\"b\") == 1).len().alias(\"a1\"),\n...     nw.col(\"a\").filter(nw.col(\"b\") == 2).len().alias(\"a2\"),\n... )\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|       a1  a2     |\n|    0   2   1     |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.log","title":"log","text":"<pre><code>log(base: float = math.e) -&gt; Self\n</code></pre> <p>Compute the logarithm to a given base.</p> <p>Parameters:</p> Name Type Description Default <code>base</code> <code>float</code> <p>Given base, defaults to <code>e</code></p> <code>e</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pa.table({\"values\": [1, 2, 4]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; result = df.with_columns(\n...     log=nw.col(\"values\").log(), log_2=nw.col(\"values\").log(base=2)\n... )\n&gt;&gt;&gt; result\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|               Narwhals DataFrame               |\n|------------------------------------------------|\n|pyarrow.Table                                   |\n|values: int64                                   |\n|log: double                                     |\n|log_2: double                                   |\n|----                                            |\n|values: [[1,2,4]]                               |\n|log: [[0,0.6931471805599453,1.3862943611198906]]|\n|log_2: [[0,1,2]]                                |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.map_batches","title":"map_batches","text":"<pre><code>map_batches(\n    function: Callable[[Any], CompliantExpr[Any, Any]],\n    return_dtype: DType | None = None,\n    *,\n    returns_scalar: bool = False\n) -&gt; Self\n</code></pre> <p>Apply a custom python function to a whole Series or sequence of Series.</p> <p>The output of this custom function is presumed to be either a Series, or a NumPy array (in which case it will be automatically converted into a Series).</p> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>Callable[[Any], CompliantExpr[Any, Any]]</code> <p>Function to apply to Series.</p> required <code>return_dtype</code> <code>DType | None</code> <p>Dtype of the output Series. If not set, the dtype will be inferred based on the first non-null value that is returned by the function.</p> <code>None</code> <code>returns_scalar</code> <code>bool</code> <p>If the function returns a scalar, by default it will be wrapped in a list in the output, since the assumption is that the function always returns something Series-like. If you want to keep the result as a scalar, set this argument to True.</p> <code>False</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [1, 2, 3], \"b\": [4, 5, 6]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(\n...     nw.col(\"a\", \"b\")\n...     .map_batches(lambda s: s.to_numpy() + 1, return_dtype=nw.Float64)\n...     .name.suffix(\"_mapped\")\n... )\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|    Narwhals DataFrame     |\n|---------------------------|\n|   a  b  a_mapped  b_mapped|\n|0  1  4       2.0       5.0|\n|1  2  5       3.0       6.0|\n|2  3  6       4.0       7.0|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.max","title":"max","text":"<pre><code>max() -&gt; Self\n</code></pre> <p>Returns the maximum value(s) from a column(s).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [10, 20], \"b\": [50, 100]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.select(nw.max(\"a\", \"b\"))\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|        a    b    |\n|    0  20  100    |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.mean","title":"mean","text":"<pre><code>mean() -&gt; Self\n</code></pre> <p>Get mean value.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [-1, 0, 1], \"b\": [2, 4, 6]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.select(nw.col(\"a\", \"b\").mean())\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|        a    b    |\n|   0  0.0  4.0    |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.median","title":"median","text":"<pre><code>median() -&gt; Self\n</code></pre> <p>Get median value.</p> Notes <p>Results might slightly differ across backends due to differences in the underlying algorithms used to compute the median.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [1, 8, 3], \"b\": [4, 5, 2]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.select(nw.col(\"a\", \"b\").median())\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|        a    b    |\n|   0  3.0  4.0    |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.min","title":"min","text":"<pre><code>min() -&gt; Self\n</code></pre> <p>Returns the minimum value(s) from a column(s).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [1, 2], \"b\": [4, 3]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.select(nw.min(\"a\", \"b\"))\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|        a  b      |\n|     0  1  3      |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.mode","title":"mode","text":"<pre><code>mode(*, keep: ModeKeepStrategy = 'all') -&gt; Self\n</code></pre> <p>Compute the most occurring value(s).</p> <p>Can return multiple values.</p> <p>Parameters:</p> Name Type Description Default <code>keep</code> <code>ModeKeepStrategy</code> <p>Whether to keep all modes or any mode found. Remark that <code>keep='any'</code> is not deterministic for multimodal values.</p> <code>'all'</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [1, 1, 2, 3], \"b\": [1, 1, 2, 2]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.select(nw.col(\"a\").mode()).sort(\"a\")\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|          a       |\n|       0  1       |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.n_unique","title":"n_unique","text":"<pre><code>n_unique() -&gt; Self\n</code></pre> <p>Returns count of unique values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [1, 2, 3, 4, 5], \"b\": [1, 1, 3, 3, 5]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.select(nw.col(\"a\", \"b\").n_unique())\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|        a  b      |\n|     0  5  3      |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.null_count","title":"null_count","text":"<pre><code>null_count() -&gt; Self\n</code></pre> <p>Count null values.</p> Notes <p>pandas handles null values differently from Polars and PyArrow. See null_handling for reference.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame(\n...     {\"a\": [1, 2, None, 1], \"b\": [\"a\", None, \"b\", None]}\n... )\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.select(nw.all().null_count())\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|        a  b      |\n|     0  1  2      |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.over","title":"over","text":"<pre><code>over(\n    *partition_by: str | Sequence[str],\n    order_by: str | Sequence[str] | None = None\n) -&gt; Self\n</code></pre> <p>Compute expressions over the given groups (optionally with given order).</p> <p>Parameters:</p> Name Type Description Default <code>partition_by</code> <code>str | Sequence[str]</code> <p>Names of columns to compute window expression over. Must be names of columns, as opposed to expressions - so, this is a bit less flexible than Polars' <code>Expr.over</code>.</p> <code>()</code> <code>order_by</code> <code>str | Sequence[str] | None</code> <p>Column(s) to order window functions by. For lazy backends, this argument is required when <code>over</code> is applied to order-dependent functions, see order-dependence.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [1, 2, 4], \"b\": [\"x\", \"x\", \"y\"]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(a_min_per_group=nw.col(\"a\").min().over(\"b\"))\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|   Narwhals DataFrame   |\n|------------------------|\n|   a  b  a_min_per_group|\n|0  1  x                1|\n|1  2  x                1|\n|2  4  y                4|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Cumulative operations are also supported, but (currently) only for pandas and Polars:</p> <pre><code>&gt;&gt;&gt; df.with_columns(a_cum_sum_per_group=nw.col(\"a\").cum_sum().over(\"b\"))\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|     Narwhals DataFrame     |\n|----------------------------|\n|   a  b  a_cum_sum_per_group|\n|0  1  x                    1|\n|1  2  x                    3|\n|2  4  y                    4|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.pipe","title":"pipe","text":"<pre><code>pipe(\n    function: Callable[Concatenate[Self, PS], R],\n    *args: args,\n    **kwargs: kwargs\n) -&gt; R\n</code></pre> <p>Pipe function call.</p> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>Callable[Concatenate[Self, PS], R]</code> <p>Function to apply.</p> required <code>args</code> <code>args</code> <p>Positional arguments to pass to function.</p> <code>()</code> <code>kwargs</code> <code>kwargs</code> <p>Keyword arguments to pass to function.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [1, 2, 3, 4]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(a_piped=nw.col(\"a\").pipe(lambda x: x + 1))\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|     a  a_piped   |\n|  0  1        2   |\n|  1  2        3   |\n|  2  3        4   |\n|  3  4        5   |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.quantile","title":"quantile","text":"<pre><code>quantile(\n    quantile: float,\n    interpolation: RollingInterpolationMethod,\n) -&gt; Self\n</code></pre> <p>Get quantile value.</p> <p>Parameters:</p> Name Type Description Default <code>quantile</code> <code>float</code> <p>Quantile between 0.0 and 1.0.</p> required <code>interpolation</code> <code>RollingInterpolationMethod</code> <p>Interpolation method.</p> required Note <ul> <li>pandas and Polars may have implementation differences for a given interpolation method.</li> <li>dask has     its own method to approximate quantile and it doesn't implement 'nearest', 'higher',     'lower', 'midpoint' as interpolation method - use 'linear' which is closest to the     native 'dask' - method.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame(\n...     {\"a\": list(range(50)), \"b\": list(range(50, 100))}\n... )\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.select(nw.col(\"a\", \"b\").quantile(0.5, interpolation=\"linear\"))\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|        a     b   |\n|  0  24.5  74.5   |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.rank","title":"rank","text":"<pre><code>rank(\n    method: RankMethod = \"average\",\n    *,\n    descending: bool = False\n) -&gt; Self\n</code></pre> <p>Assign ranks to data, dealing with ties appropriately.</p> Notes <p>The resulting dtype may differ between backends.</p> Info <p>For lazy backends, this operation must be followed by <code>Expr.over</code> with <code>order_by</code> specified, see order-dependence.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>RankMethod</code> <p>The method used to assign ranks to tied elements. The following methods are available (default is 'average')</p> <ul> <li>\"average\": The average of the ranks that would have been assigned to     all the tied values is assigned to each value.</li> <li>\"min\": The minimum of the ranks that would have been assigned to all     the tied values is assigned to each value. (This is also referred to     as \"competition\" ranking.)</li> <li>\"max\": The maximum of the ranks that would have been assigned to all     the tied values is assigned to each value.</li> <li>\"dense\": Like \"min\", but the rank of the next highest element is     assigned the rank immediately after those assigned to the tied elements.</li> <li>\"ordinal\": All values are given a distinct rank, corresponding to the     order that the values occur in the Series.</li> </ul> <code>'average'</code> <code>descending</code> <code>bool</code> <p>Rank in descending order.</p> <code>False</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [3, 6, 1, 1, 6]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; result = df.with_columns(rank=nw.col(\"a\").rank(method=\"dense\"))\n&gt;&gt;&gt; result\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|       a  rank    |\n|    0  3   2.0    |\n|    1  6   3.0    |\n|    2  1   1.0    |\n|    3  1   1.0    |\n|    4  6   3.0    |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.replace_strict","title":"replace_strict","text":"<pre><code>replace_strict(\n    old: Sequence[Any] | Mapping[Any, Any],\n    new: Sequence[Any] | None = None,\n    *,\n    return_dtype: IntoDType | None = None\n) -&gt; Self\n</code></pre> <p>Replace all values by different values.</p> <p>This function must replace all non-null input values (else it raises an error).</p> <p>Parameters:</p> Name Type Description Default <code>old</code> <code>Sequence[Any] | Mapping[Any, Any]</code> <p>Sequence of values to replace. It also accepts a mapping of values to their replacement as syntactic sugar for <code>replace_strict(old=list(mapping.keys()), new=list(mapping.values()))</code>.</p> required <code>new</code> <code>Sequence[Any] | None</code> <p>Sequence of values to replace by. Length must match the length of <code>old</code>.</p> <code>None</code> <code>return_dtype</code> <code>IntoDType | None</code> <p>The data type of the resulting expression. If set to <code>None</code> (default), the data type is determined automatically based on the other inputs.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [3, 0, 1, 2]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(\n...     b=nw.col(\"a\").replace_strict(\n...         [0, 1, 2, 3],\n...         [\"zero\", \"one\", \"two\", \"three\"],\n...         return_dtype=nw.String,\n...     )\n... )\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|      a      b    |\n|   0  3  three    |\n|   1  0   zero    |\n|   2  1    one    |\n|   3  2    two    |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.rolling_mean","title":"rolling_mean","text":"<pre><code>rolling_mean(\n    window_size: int,\n    *,\n    min_samples: int | None = None,\n    center: bool = False\n) -&gt; Self\n</code></pre> <p>Apply a rolling mean (moving mean) over the values.</p> <p>A window of length <code>window_size</code> will traverse the values. The resulting values will be aggregated to their mean.</p> <p>The window at a given row will include the row itself and the <code>window_size - 1</code> elements before it.</p> Info <p>For lazy backends, this operation must be followed by <code>Expr.over</code> with <code>order_by</code> specified, see order-dependence.</p> <p>Parameters:</p> Name Type Description Default <code>window_size</code> <code>int</code> <p>The length of the window in number of elements. It must be a strictly positive integer.</p> required <code>min_samples</code> <code>int | None</code> <p>The number of values in the window that should be non-null before computing a result. If set to <code>None</code> (default), it will be set equal to <code>window_size</code>. If provided, it must be a strictly positive integer, and less than or equal to <code>window_size</code></p> <code>None</code> <code>center</code> <code>bool</code> <p>Set the labels at the center of the window.</p> <code>False</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [1.0, 2.0, None, 4.0]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(\n...     a_rolling_mean=nw.col(\"a\").rolling_mean(window_size=3, min_samples=1)\n... )\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|  Narwhals DataFrame  |\n|----------------------|\n|     a  a_rolling_mean|\n|0  1.0             1.0|\n|1  2.0             1.5|\n|2  NaN             1.5|\n|3  4.0             3.0|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.rolling_std","title":"rolling_std","text":"<pre><code>rolling_std(\n    window_size: int,\n    *,\n    min_samples: int | None = None,\n    center: bool = False,\n    ddof: int = 1\n) -&gt; Self\n</code></pre> <p>Apply a rolling standard deviation (moving standard deviation) over the values.</p> <p>A window of length <code>window_size</code> will traverse the values. The resulting values will be aggregated to their standard deviation.</p> <p>The window at a given row will include the row itself and the <code>window_size - 1</code> elements before it.</p> Info <p>For lazy backends, this operation must be followed by <code>Expr.over</code> with <code>order_by</code> specified, see order-dependence.</p> <p>Parameters:</p> Name Type Description Default <code>window_size</code> <code>int</code> <p>The length of the window in number of elements. It must be a strictly positive integer.</p> required <code>min_samples</code> <code>int | None</code> <p>The number of values in the window that should be non-null before computing a result. If set to <code>None</code> (default), it will be set equal to <code>window_size</code>. If provided, it must be a strictly positive integer, and less than or equal to <code>window_size</code>.</p> <code>None</code> <code>center</code> <code>bool</code> <p>Set the labels at the center of the window.</p> <code>False</code> <code>ddof</code> <code>int</code> <p>Delta Degrees of Freedom; the divisor for a length N window is N - ddof.</p> <code>1</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [1.0, 2.0, None, 4.0]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(\n...     a_rolling_std=nw.col(\"a\").rolling_std(window_size=3, min_samples=1)\n... )\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n| Narwhals DataFrame  |\n|---------------------|\n|     a  a_rolling_std|\n|0  1.0            NaN|\n|1  2.0       0.707107|\n|2  NaN       0.707107|\n|3  4.0       1.414214|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.rolling_sum","title":"rolling_sum","text":"<pre><code>rolling_sum(\n    window_size: int,\n    *,\n    min_samples: int | None = None,\n    center: bool = False\n) -&gt; Self\n</code></pre> <p>Apply a rolling sum (moving sum) over the values.</p> <p>A window of length <code>window_size</code> will traverse the values. The resulting values will be aggregated to their sum.</p> <p>The window at a given row will include the row itself and the <code>window_size - 1</code> elements before it.</p> Info <p>For lazy backends, this operation must be followed by <code>Expr.over</code> with <code>order_by</code> specified, see order-dependence.</p> <p>Parameters:</p> Name Type Description Default <code>window_size</code> <code>int</code> <p>The length of the window in number of elements. It must be a strictly positive integer.</p> required <code>min_samples</code> <code>int | None</code> <p>The number of values in the window that should be non-null before computing a result. If set to <code>None</code> (default), it will be set equal to <code>window_size</code>. If provided, it must be a strictly positive integer, and less than or equal to <code>window_size</code></p> <code>None</code> <code>center</code> <code>bool</code> <p>Set the labels at the center of the window.</p> <code>False</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [1.0, 2.0, None, 4.0]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(\n...     a_rolling_sum=nw.col(\"a\").rolling_sum(window_size=3, min_samples=1)\n... )\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n| Narwhals DataFrame  |\n|---------------------|\n|     a  a_rolling_sum|\n|0  1.0            1.0|\n|1  2.0            3.0|\n|2  NaN            3.0|\n|3  4.0            6.0|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.rolling_var","title":"rolling_var","text":"<pre><code>rolling_var(\n    window_size: int,\n    *,\n    min_samples: int | None = None,\n    center: bool = False,\n    ddof: int = 1\n) -&gt; Self\n</code></pre> <p>Apply a rolling variance (moving variance) over the values.</p> <p>A window of length <code>window_size</code> will traverse the values. The resulting values will be aggregated to their variance.</p> <p>The window at a given row will include the row itself and the <code>window_size - 1</code> elements before it.</p> Info <p>For lazy backends, this operation must be followed by <code>Expr.over</code> with <code>order_by</code> specified, see order-dependence.</p> <p>Parameters:</p> Name Type Description Default <code>window_size</code> <code>int</code> <p>The length of the window in number of elements. It must be a strictly positive integer.</p> required <code>min_samples</code> <code>int | None</code> <p>The number of values in the window that should be non-null before computing a result. If set to <code>None</code> (default), it will be set equal to <code>window_size</code>. If provided, it must be a strictly positive integer, and less than or equal to <code>window_size</code>.</p> <code>None</code> <code>center</code> <code>bool</code> <p>Set the labels at the center of the window.</p> <code>False</code> <code>ddof</code> <code>int</code> <p>Delta Degrees of Freedom; the divisor for a length N window is N - ddof.</p> <code>1</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [1.0, 2.0, None, 4.0]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(\n...     a_rolling_var=nw.col(\"a\").rolling_var(window_size=3, min_samples=1)\n... )\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n| Narwhals DataFrame  |\n|---------------------|\n|     a  a_rolling_var|\n|0  1.0            NaN|\n|1  2.0            0.5|\n|2  NaN            0.5|\n|3  4.0            2.0|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.round","title":"round","text":"<pre><code>round(decimals: int = 0) -&gt; Self\n</code></pre> <p>Round underlying floating point data by <code>decimals</code> digits.</p> <p>Parameters:</p> Name Type Description Default <code>decimals</code> <code>int</code> <p>Number of decimals to round by.</p> <code>0</code> Notes <p>For values exactly halfway between rounded decimal values pandas behaves differently than Polars and Arrow.</p> <p>pandas rounds to the nearest even value (e.g. -0.5 and 0.5 round to 0.0, 1.5 and 2.5 round to 2.0, 3.5 and 4.5 to 4.0, etc..).</p> <p>Polars and Arrow round away from 0 (e.g. -0.5 to -1.0, 0.5 to 1.0, 1.5 to 2.0, 2.5 to 3.0, etc..).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [1.12345, 2.56789, 3.901234]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(a_rounded=nw.col(\"a\").round(1))\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|  Narwhals DataFrame  |\n|----------------------|\n|          a  a_rounded|\n|0  1.123450        1.1|\n|1  2.567890        2.6|\n|2  3.901234        3.9|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.shift","title":"shift","text":"<pre><code>shift(n: int) -&gt; Self\n</code></pre> <p>Shift values by <code>n</code> positions.</p> Info <p>For lazy backends, this operation must be followed by <code>Expr.over</code> with <code>order_by</code> specified, see order-dependence.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Number of positions to shift values by.</p> required Notes <p>pandas may change the dtype here, for example when introducing missing values in an integer column. To ensure, that the dtype doesn't change, you may want to use <code>fill_null</code> and <code>cast</code>. For example, to shift and fill missing values with <code>0</code> in a Int64 column, you could do:</p> <pre><code>nw.col(\"a\").shift(1).fill_null(0).cast(nw.Int64)\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pl.DataFrame({\"a\": [1, 1, 3, 5, 5]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(a_shift=nw.col(\"a\").shift(n=1))\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|shape: (5, 2)     |\n|\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 |\n|\u2502 a   \u2506 a_shift \u2502 |\n|\u2502 --- \u2506 ---     \u2502 |\n|\u2502 i64 \u2506 i64     \u2502 |\n|\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 |\n|\u2502 1   \u2506 null    \u2502 |\n|\u2502 1   \u2506 1       \u2502 |\n|\u2502 3   \u2506 1       \u2502 |\n|\u2502 5   \u2506 3       \u2502 |\n|\u2502 5   \u2506 5       \u2502 |\n|\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.skew","title":"skew","text":"<pre><code>skew() -&gt; Self\n</code></pre> <p>Calculate the sample skewness of a column.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [1, 2, 3, 4, 5], \"b\": [1, 1, 2, 10, 100]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.select(nw.col(\"a\", \"b\").skew())\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|      a         b |\n| 0  0.0  1.472427 |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.sqrt","title":"sqrt","text":"<pre><code>sqrt() -&gt; Self\n</code></pre> <p>Compute the square root.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pa.table({\"values\": [1, 4, 9]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; result = df.with_columns(sqrt=nw.col(\"values\").sqrt())\n&gt;&gt;&gt; result\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|pyarrow.Table     |\n|values: int64     |\n|sqrt: double      |\n|----              |\n|values: [[1,4,9]] |\n|sqrt: [[1,2,3]]   |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.std","title":"std","text":"<pre><code>std(*, ddof: int = 1) -&gt; Self\n</code></pre> <p>Get standard deviation.</p> <p>Parameters:</p> Name Type Description Default <code>ddof</code> <code>int</code> <p>\"Delta Degrees of Freedom\": the divisor used in the calculation is N - ddof, where N represents the number of elements. By default ddof is 1.</p> <code>1</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [20, 25, 60], \"b\": [1.5, 1, -1.4]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.select(nw.col(\"a\", \"b\").std(ddof=0))\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n| Narwhals DataFrame  |\n|---------------------|\n|          a         b|\n|0  17.79513  1.265789|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.sum","title":"sum","text":"<pre><code>sum() -&gt; Self\n</code></pre> <p>Return the sum value.</p> <p>If there are no non-null elements, the result is zero.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import duckdb\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = duckdb.sql(\"SELECT * FROM VALUES (5, 50), (10, 100) df(a, b)\")\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.select(nw.col(\"a\", \"b\").sum())\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals LazyFrame |\n|-------------------|\n|\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510|\n|\u2502   a    \u2502   b    \u2502|\n|\u2502 int128 \u2502 int128 \u2502|\n|\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524|\n|\u2502     15 \u2502    150 \u2502|\n|\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.unique","title":"unique","text":"<pre><code>unique() -&gt; Self\n</code></pre> <p>Return unique values of this expression.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [1, 1, 3, 5, 5], \"b\": [2, 4, 4, 6, 6]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.select(nw.col(\"a\", \"b\").unique().sum())\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|        a   b     |\n|     0  9  12     |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.var","title":"var","text":"<pre><code>var(*, ddof: int = 1) -&gt; Self\n</code></pre> <p>Get variance.</p> <p>Parameters:</p> Name Type Description Default <code>ddof</code> <code>int</code> <p>\"Delta Degrees of Freedom\": the divisor used in the calculation is N - ddof,      where N represents the number of elements. By default ddof is 1.</p> <code>1</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [20, 25, 60], \"b\": [1.5, 1, -1.4]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.select(nw.col(\"a\", \"b\").var(ddof=0))\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|  Narwhals DataFrame   |\n|-----------------------|\n|            a         b|\n|0  316.666667  1.602222|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr_cat/","title":"<code>narwhals.Expr.cat</code>","text":""},{"location":"api-reference/expr_cat/#narwhals.expr.ExprCatNamespace.get_categories","title":"get_categories","text":"<pre><code>get_categories() -&gt; ExprT\n</code></pre> <p>Get unique categories from column.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pl.DataFrame(\n...     {\"fruits\": [\"apple\", \"mango\", \"mango\"]},\n...     schema={\"fruits\": pl.Categorical},\n... )\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.select(nw.col(\"fruits\").cat.get_categories()).to_native()\nshape: (2, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 fruits \u2502\n\u2502 ---    \u2502\n\u2502 str    \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 apple  \u2502\n\u2502 mango  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr_dt/","title":"<code>narwhals.Expr.dt</code>","text":""},{"location":"api-reference/expr_dt/#narwhals.expr.ExprDateTimeNamespace.convert_time_zone","title":"convert_time_zone","text":"<pre><code>convert_time_zone(time_zone: str) -&gt; ExprT\n</code></pre> <p>Convert to a new time zone.</p> <p>If converting from a time-zone-naive column, then conversion happens as if converting from UTC.</p> <p>Parameters:</p> Name Type Description Default <code>time_zone</code> <code>str</code> <p>Target time zone.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime, timezone\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame(\n...     {\n...         \"a\": [\n...             datetime(2024, 1, 1, tzinfo=timezone.utc),\n...             datetime(2024, 1, 2, tzinfo=timezone.utc),\n...         ]\n...     }\n... )\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.select(nw.col(\"a\").dt.convert_time_zone(\"Asia/Kathmandu\")).to_native()\n                          a\n0 2024-01-01 05:45:00+05:45\n1 2024-01-02 05:45:00+05:45\n</code></pre>"},{"location":"api-reference/expr_dt/#narwhals.expr.ExprDateTimeNamespace.date","title":"date","text":"<pre><code>date() -&gt; ExprT\n</code></pre> <p>Extract the date from underlying DateTime representation.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If pandas default backend is being used.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pl.DataFrame(\n...     {\"a\": [datetime(2012, 1, 7, 10), datetime(2027, 12, 13)]}\n... )\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.select(nw.col(\"a\").dt.date()).to_native()\nshape: (2, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a          \u2502\n\u2502 ---        \u2502\n\u2502 date       \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2012-01-07 \u2502\n\u2502 2027-12-13 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr_dt/#narwhals.expr.ExprDateTimeNamespace.day","title":"day","text":"<pre><code>day() -&gt; ExprT\n</code></pre> <p>Extract day from underlying DateTime representation.</p> <p>Returns the day of month starting from 1. The return value ranges from 1 to 31. (The last day of month differs by months.)</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pa.table({\"a\": [datetime(1978, 6, 1), datetime(2065, 1, 1)]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(nw.col(\"a\").dt.day().alias(\"day\")).to_native()\npyarrow.Table\na: timestamp[us]\nday: int64\n----\na: [[1978-06-01 00:00:00.000000,2065-01-01 00:00:00.000000]]\nday: [[1,1]]\n</code></pre>"},{"location":"api-reference/expr_dt/#narwhals.expr.ExprDateTimeNamespace.hour","title":"hour","text":"<pre><code>hour() -&gt; ExprT\n</code></pre> <p>Extract hour from underlying DateTime representation.</p> <p>Returns the hour number from 0 to 23.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pl.DataFrame(\n...     {\"a\": [datetime(1978, 1, 1, 1), datetime(2065, 1, 1, 10)]}\n... )\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(nw.col(\"a\").dt.hour().alias(\"hour\"))\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|      Narwhals DataFrame      |\n|------------------------------|\n|shape: (2, 2)                 |\n|\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510|\n|\u2502 a                   \u2506 hour \u2502|\n|\u2502 ---                 \u2506 ---  \u2502|\n|\u2502 datetime[\u03bcs]        \u2506 i8   \u2502|\n|\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561|\n|\u2502 1978-01-01 01:00:00 \u2506 1    \u2502|\n|\u2502 2065-01-01 10:00:00 \u2506 10   \u2502|\n|\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr_dt/#narwhals.expr.ExprDateTimeNamespace.microsecond","title":"microsecond","text":"<pre><code>microsecond() -&gt; ExprT\n</code></pre> <p>Extract microseconds from underlying DateTime representation.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pa.table(\n...     {\n...         \"a\": [\n...             datetime(1978, 1, 1, 1, 1, 1, 0),\n...             datetime(2065, 1, 1, 10, 20, 30, 67000),\n...         ]\n...     }\n... )\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(\n...     nw.col(\"a\").dt.microsecond().alias(\"microsecond\")\n... ).to_native()\npyarrow.Table\na: timestamp[us]\nmicrosecond: int64\n----\na: [[1978-01-01 01:01:01.000000,2065-01-01 10:20:30.067000]]\nmicrosecond: [[0,67000]]\n</code></pre>"},{"location":"api-reference/expr_dt/#narwhals.expr.ExprDateTimeNamespace.millisecond","title":"millisecond","text":"<pre><code>millisecond() -&gt; ExprT\n</code></pre> <p>Extract milliseconds from underlying DateTime representation.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pa.table(\n...     {\n...         \"a\": [\n...             datetime(1978, 1, 1, 1, 1, 1, 0),\n...             datetime(2065, 1, 1, 10, 20, 30, 67000),\n...         ]\n...     }\n... )\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(\n...     nw.col(\"a\").dt.millisecond().alias(\"millisecond\")\n... ).to_native()\npyarrow.Table\na: timestamp[us]\nmillisecond: int64\n----\na: [[1978-01-01 01:01:01.000000,2065-01-01 10:20:30.067000]]\nmillisecond: [[0,67]]\n</code></pre>"},{"location":"api-reference/expr_dt/#narwhals.expr.ExprDateTimeNamespace.minute","title":"minute","text":"<pre><code>minute() -&gt; ExprT\n</code></pre> <p>Extract minutes from underlying DateTime representation.</p> <p>Returns the minute number from 0 to 59.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame(\n...     {\"a\": [datetime(1978, 1, 1, 1, 1), datetime(2065, 1, 1, 10, 20)]}\n... )\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(nw.col(\"a\").dt.minute().alias(\"minute\")).to_native()\n                    a  minute\n0 1978-01-01 01:01:00       1\n1 2065-01-01 10:20:00      20\n</code></pre>"},{"location":"api-reference/expr_dt/#narwhals.expr.ExprDateTimeNamespace.month","title":"month","text":"<pre><code>month() -&gt; ExprT\n</code></pre> <p>Extract month from underlying DateTime representation.</p> <p>Returns the month number starting from 1. The return value ranges from 1 to 12.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pa.table({\"a\": [datetime(1978, 6, 1), datetime(2065, 1, 1)]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(nw.col(\"a\").dt.month().alias(\"month\")).to_native()\npyarrow.Table\na: timestamp[us]\nmonth: int64\n----\na: [[1978-06-01 00:00:00.000000,2065-01-01 00:00:00.000000]]\nmonth: [[6,1]]\n</code></pre>"},{"location":"api-reference/expr_dt/#narwhals.expr.ExprDateTimeNamespace.nanosecond","title":"nanosecond","text":"<pre><code>nanosecond() -&gt; ExprT\n</code></pre> <p>Extract Nanoseconds from underlying DateTime representation.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pa.table(\n...     {\n...         \"a\": [\n...             datetime(1978, 1, 1, 1, 1, 1, 0),\n...             datetime(2065, 1, 1, 10, 20, 30, 67000),\n...         ]\n...     }\n... )\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(\n...     nw.col(\"a\").dt.nanosecond().alias(\"nanosecond\")\n... ).to_native()\npyarrow.Table\na: timestamp[us]\nnanosecond: int64\n----\na: [[1978-01-01 01:01:01.000000,2065-01-01 10:20:30.067000]]\nnanosecond: [[0,67000000]]\n</code></pre>"},{"location":"api-reference/expr_dt/#narwhals.expr.ExprDateTimeNamespace.offset_by","title":"offset_by","text":"<pre><code>offset_by(by: str) -&gt; ExprT\n</code></pre> <p>Offset this date by a relative time offset.</p> <p>Parameters:</p> Name Type Description Default <code>by</code> <code>str</code> <p>The offset. Must be of form <code>&lt;multiple&gt;&lt;unit&gt;</code>, where <code>multiple</code> is a positive integer and <code>unit</code> is one of</p> <ul> <li>'ns': nanosecond.</li> <li>'us': microsecond.</li> <li>'ms': millisecond.</li> <li>'s': second.</li> <li>'m': minute.</li> <li>'h': hour.</li> <li>'d': day.</li> <li>'mo': month.</li> <li>'q': quarter.</li> <li>'y': year.</li> </ul> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pl.DataFrame({\"datetime\": [datetime(2021, 3, 1, 12, 34)]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(\n...     nw.col(\"datetime\").dt.offset_by(\"1h\").alias(\"datetime_offset_by_1h\")\n... )\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|              Narwhals DataFrame               |\n|-----------------------------------------------|\n|shape: (1, 2)                                  |\n|\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510|\n|\u2502 datetime            \u2506 datetime_offset_by_1h \u2502|\n|\u2502 ---                 \u2506 ---                   \u2502|\n|\u2502 datetime[\u03bcs]        \u2506 datetime[\u03bcs]          \u2502|\n|\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561|\n|\u2502 2021-03-01 12:34:00 \u2506 2021-03-01 13:34:00   \u2502|\n|\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr_dt/#narwhals.expr.ExprDateTimeNamespace.ordinal_day","title":"ordinal_day","text":"<pre><code>ordinal_day() -&gt; ExprT\n</code></pre> <p>Get ordinal day.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame(\n...     {\"a\": [datetime(2020, 1, 1), datetime(2020, 8, 3)]}\n... )\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(a_ordinal_day=nw.col(\"a\").dt.ordinal_day())\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|    Narwhals DataFrame     |\n|---------------------------|\n|           a  a_ordinal_day|\n|0 2020-01-01              1|\n|1 2020-08-03            216|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr_dt/#narwhals.expr.ExprDateTimeNamespace.replace_time_zone","title":"replace_time_zone","text":"<pre><code>replace_time_zone(time_zone: str | None) -&gt; ExprT\n</code></pre> <p>Replace time zone.</p> <p>Parameters:</p> Name Type Description Default <code>time_zone</code> <code>str | None</code> <p>Target time zone.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime, timezone\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame(\n...     {\n...         \"a\": [\n...             datetime(2024, 1, 1, tzinfo=timezone.utc),\n...             datetime(2024, 1, 2, tzinfo=timezone.utc),\n...         ]\n...     }\n... )\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.select(nw.col(\"a\").dt.replace_time_zone(\"Asia/Kathmandu\")).to_native()\n                          a\n0 2024-01-01 00:00:00+05:45\n1 2024-01-02 00:00:00+05:45\n</code></pre>"},{"location":"api-reference/expr_dt/#narwhals.expr.ExprDateTimeNamespace.second","title":"second","text":"<pre><code>second() -&gt; ExprT\n</code></pre> <p>Extract seconds from underlying DateTime representation.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pa.table(\n...     {\n...         \"a\": [\n...             datetime(1978, 1, 1, 1, 1, 1),\n...             datetime(2065, 1, 1, 10, 20, 30),\n...         ]\n...     }\n... )\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(nw.col(\"a\").dt.second().alias(\"second\")).to_native()\npyarrow.Table\na: timestamp[us]\nsecond: int64\n----\na: [[1978-01-01 01:01:01.000000,2065-01-01 10:20:30.000000]]\nsecond: [[1,30]]\n</code></pre>"},{"location":"api-reference/expr_dt/#narwhals.expr.ExprDateTimeNamespace.timestamp","title":"timestamp","text":"<pre><code>timestamp(time_unit: TimeUnit = 'us') -&gt; ExprT\n</code></pre> <p>Return a timestamp in the given time unit.</p> <p>Parameters:</p> Name Type Description Default <code>time_unit</code> <code>TimeUnit</code> <p>One of - 'ns': nanosecond. - 'us': microsecond. - 'ms': millisecond.</p> <code>'us'</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import date\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pl.DataFrame({\"date\": [date(2001, 1, 1), None]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(nw.col(\"date\").dt.timestamp(\"ms\").alias(\"timestamp_ms\"))\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|     Narwhals DataFrame      |\n|-----------------------------|\n|shape: (2, 2)                |\n|\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510|\n|\u2502 date       \u2506 timestamp_ms \u2502|\n|\u2502 ---        \u2506 ---          \u2502|\n|\u2502 date       \u2506 i64          \u2502|\n|\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561|\n|\u2502 2001-01-01 \u2506 978307200000 \u2502|\n|\u2502 null       \u2506 null         \u2502|\n|\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr_dt/#narwhals.expr.ExprDateTimeNamespace.to_string","title":"to_string","text":"<pre><code>to_string(format: str) -&gt; ExprT\n</code></pre> <p>Convert a Date/Time/Datetime column into a String column with the given format.</p> <p>Parameters:</p> Name Type Description Default <code>format</code> <code>str</code> <p>Format to format temporal column with.</p> required Notes <p>Unfortunately, different libraries interpret format directives a bit differently.</p> <ul> <li>Chrono, the library used by Polars, uses <code>\"%.f\"</code> for fractional seconds,   whereas pandas and Python stdlib use <code>\".%f\"</code>.</li> <li>PyArrow interprets <code>\"%S\"</code> as \"seconds, including fractional seconds\"   whereas most other tools interpret it as \"just seconds, as 2 digits\".</li> </ul> <p>Therefore, we make the following adjustments.</p> <ul> <li>for pandas-like libraries, we replace <code>\"%S.%f\"</code> with <code>\"%S%.f\"</code>.</li> <li>for PyArrow, we replace <code>\"%S.%f\"</code> with <code>\"%S\"</code>.</li> </ul> <p>Workarounds like these don't make us happy, and we try to avoid them as much as possible, but here we feel like it's the best compromise.</p> <p>If you just want to format a date/datetime Series as a local datetime string, and have it work as consistently as possible across libraries, we suggest using:</p> <ul> <li><code>\"%Y-%m-%dT%H:%M:%S%.f\"</code> for datetimes</li> <li><code>\"%Y-%m-%d\"</code> for dates</li> </ul> <p>Though note that, even then, different tools may return a different number of trailing zeros. Nonetheless, this is probably consistent enough for most applications.</p> <p>If you have an application where this is not enough, please open an issue and let us know.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pl.DataFrame(\n...     {\"a\": [datetime(2020, 3, 1), datetime(2020, 5, 1)]}\n... )\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.select(nw.col(\"a\").dt.to_string(\"%Y/%m/%d %H:%M:%S\"))\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|  Narwhals DataFrame   |\n|-----------------------|\n|shape: (2, 1)          |\n|\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510|\n|\u2502 a                   \u2502|\n|\u2502 ---                 \u2502|\n|\u2502 str                 \u2502|\n|\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561|\n|\u2502 2020/03/01 00:00:00 \u2502|\n|\u2502 2020/05/01 00:00:00 \u2502|\n|\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr_dt/#narwhals.expr.ExprDateTimeNamespace.total_microseconds","title":"total_microseconds","text":"<pre><code>total_microseconds() -&gt; ExprT\n</code></pre> <p>Get total microseconds.</p> Notes <p>The function outputs the total microseconds in the int dtype by default, however, pandas may change the dtype to float when there are missing values, consider using <code>fill_null()</code> and <code>cast</code> in this case.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import timedelta\n&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pa.table(\n...     {\n...         \"a\": [\n...             timedelta(microseconds=10),\n...             timedelta(milliseconds=1, microseconds=200),\n...         ]\n...     }\n... )\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(\n...     a_total_microseconds=nw.col(\"a\").dt.total_microseconds()\n... ).to_native()\npyarrow.Table\na: duration[us]\na_total_microseconds: int64\n----\na: [[10,1200]]\na_total_microseconds: [[10,1200]]\n</code></pre>"},{"location":"api-reference/expr_dt/#narwhals.expr.ExprDateTimeNamespace.total_milliseconds","title":"total_milliseconds","text":"<pre><code>total_milliseconds() -&gt; ExprT\n</code></pre> <p>Get total milliseconds.</p> Notes <p>The function outputs the total milliseconds in the int dtype by default, however, pandas may change the dtype to float when there are missing values, consider using <code>fill_null()</code> and <code>cast</code> in this case.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import timedelta\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pl.DataFrame(\n...     {\n...         \"a\": [\n...             timedelta(milliseconds=10),\n...             timedelta(milliseconds=20, microseconds=40),\n...         ]\n...     }\n... )\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(\n...     a_total_milliseconds=nw.col(\"a\").dt.total_milliseconds()\n... ).to_native()\nshape: (2, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a            \u2506 a_total_milliseconds \u2502\n\u2502 ---          \u2506 ---                  \u2502\n\u2502 duration[\u03bcs] \u2506 i64                  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 10ms         \u2506 10                   \u2502\n\u2502 20040\u00b5s      \u2506 20                   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr_dt/#narwhals.expr.ExprDateTimeNamespace.total_minutes","title":"total_minutes","text":"<pre><code>total_minutes() -&gt; ExprT\n</code></pre> <p>Get total minutes.</p> Notes <p>The function outputs the total minutes in the int dtype by default, however, pandas may change the dtype to float when there are missing values, consider using <code>fill_null()</code> and <code>cast</code> in this case.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import timedelta\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pl.DataFrame(\n...     {\"a\": [timedelta(minutes=10), timedelta(minutes=20, seconds=40)]}\n... )\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(\n...     a_total_minutes=nw.col(\"a\").dt.total_minutes()\n... ).to_native()\nshape: (2, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a            \u2506 a_total_minutes \u2502\n\u2502 ---          \u2506 ---             \u2502\n\u2502 duration[\u03bcs] \u2506 i64             \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 10m          \u2506 10              \u2502\n\u2502 20m 40s      \u2506 20              \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr_dt/#narwhals.expr.ExprDateTimeNamespace.total_nanoseconds","title":"total_nanoseconds","text":"<pre><code>total_nanoseconds() -&gt; ExprT\n</code></pre> <p>Get total nanoseconds.</p> Notes <p>The function outputs the total nanoseconds in the int dtype by default, however, pandas may change the dtype to float when there are missing values, consider using <code>fill_null()</code> and <code>cast</code> in this case.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import timedelta\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame(\n...     {\n...         \"a\": pd.to_datetime(\n...             [\n...                 \"2024-01-01 00:00:00.000000001\",\n...                 \"2024-01-01 00:00:00.000000002\",\n...             ]\n...         )\n...     }\n... )\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(\n...     a_diff_total_nanoseconds=nw.col(\"a\").diff().dt.total_nanoseconds()\n... ).to_native()\n                              a  a_diff_total_nanoseconds\n0 2024-01-01 00:00:00.000000001                       NaN\n1 2024-01-01 00:00:00.000000002                       1.0\n</code></pre>"},{"location":"api-reference/expr_dt/#narwhals.expr.ExprDateTimeNamespace.total_seconds","title":"total_seconds","text":"<pre><code>total_seconds() -&gt; ExprT\n</code></pre> <p>Get total seconds.</p> Notes <p>The function outputs the total seconds in the int dtype by default, however, pandas may change the dtype to float when there are missing values, consider using <code>fill_null()</code> and <code>cast</code> in this case.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import timedelta\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pl.DataFrame(\n...     {\"a\": [timedelta(seconds=10), timedelta(seconds=20, milliseconds=40)]}\n... )\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(\n...     a_total_seconds=nw.col(\"a\").dt.total_seconds()\n... ).to_native()\nshape: (2, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a            \u2506 a_total_seconds \u2502\n\u2502 ---          \u2506 ---             \u2502\n\u2502 duration[\u03bcs] \u2506 i64             \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 10s          \u2506 10              \u2502\n\u2502 20s 40ms     \u2506 20              \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr_dt/#narwhals.expr.ExprDateTimeNamespace.truncate","title":"truncate","text":"<pre><code>truncate(every: str) -&gt; ExprT\n</code></pre> <p>Divide the date/datetime range into buckets.</p> <p>Parameters:</p> Name Type Description Default <code>every</code> <code>str</code> <p>Length of bucket. Must be of form <code>&lt;multiple&gt;&lt;unit&gt;</code>, where <code>multiple</code> is a positive integer and <code>unit</code> is one of</p> <ul> <li>'ns': nanosecond.</li> <li>'us': microsecond.</li> <li>'ms': millisecond.</li> <li>'s': second.</li> <li>'m': minute.</li> <li>'h': hour.</li> <li>'d': day.</li> <li>'mo': month.</li> <li>'q': quarter.</li> <li>'y': year.</li> </ul> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pl.DataFrame({\"datetime\": [datetime(2021, 3, 1, 12, 34)]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(\n...     nw.col(\"datetime\").dt.truncate(\"1h\").alias(\"datetime_trunc\")\n... )\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|             Narwhals DataFrame              |\n|---------------------------------------------|\n|shape: (1, 2)                                |\n|\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510|\n|\u2502 datetime            \u2506 datetime_trunc      \u2502|\n|\u2502 ---                 \u2506 ---                 \u2502|\n|\u2502 datetime[\u03bcs]        \u2506 datetime[\u03bcs]        \u2502|\n|\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561|\n|\u2502 2021-03-01 12:34:00 \u2506 2021-03-01 12:00:00 \u2502|\n|\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr_dt/#narwhals.expr.ExprDateTimeNamespace.weekday","title":"weekday","text":"<pre><code>weekday() -&gt; ExprT\n</code></pre> <p>Extract the week day from the underlying Date representation.</p> <p>Note that Monday = 1 and Sunday = 7.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame(\n...     {\"a\": [datetime(2020, 1, 1), datetime(2020, 8, 3)]}\n... )\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(a_week_day=nw.col(\"a\").dt.weekday())\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|   Narwhals DataFrame   |\n|------------------------|\n|           a  a_week_day|\n|0 2020-01-01           3|\n|1 2020-08-03           1|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr_dt/#narwhals.expr.ExprDateTimeNamespace.year","title":"year","text":"<pre><code>year() -&gt; ExprT\n</code></pre> <p>Extract year from underlying DateTime representation.</p> <p>Returns the year number in the calendar date.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame(\n...     {\"a\": [datetime(1978, 6, 1), datetime(2065, 1, 1)]}\n... )\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(nw.col(\"a\").dt.year().alias(\"year\"))\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|           a  year|\n|0 1978-06-01  1978|\n|1 2065-01-01  2065|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr_list/","title":"<code>narwhals.Expr.list</code>","text":""},{"location":"api-reference/expr_list/#narwhals.expr.ExprListNamespace.contains","title":"contains","text":"<pre><code>contains(item: NonNestedLiteral) -&gt; ExprT\n</code></pre> <p>Check if sublists contain the given item.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>NonNestedLiteral</code> <p>Item that will be checked for membership.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pl.DataFrame({\"a\": [[1, 2], None, []]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(a_contains_1=nw.col(\"a\").list.contains(1))\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|     Narwhals DataFrame     |\n|----------------------------|\n|shape: (3, 2)               |\n|\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510|\n|\u2502 a         \u2506 a_contains_1 \u2502|\n|\u2502 ---       \u2506 ---          \u2502|\n|\u2502 list[i64] \u2506 bool         \u2502|\n|\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561|\n|\u2502 [1, 2]    \u2506 true         \u2502|\n|\u2502 null      \u2506 null         \u2502|\n|\u2502 []        \u2506 false        \u2502|\n|\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr_list/#narwhals.expr.ExprListNamespace.get","title":"get","text":"<pre><code>get(index: int) -&gt; ExprT\n</code></pre> <p>Return the value by index in each list.</p> <p>Negative indices are not accepted.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pl.DataFrame({\"a\": [[1, 2], [3, 4, None], [None, 5]]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(a_first=nw.col(\"a\").list.get(0))\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|    Narwhals DataFrame    |\n|--------------------------|\n|shape: (3, 2)             |\n|\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510|\n|\u2502 a            \u2506 a_first \u2502|\n|\u2502 ---          \u2506 ---     \u2502|\n|\u2502 list[i64]    \u2506 i64     \u2502|\n|\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561|\n|\u2502 [1, 2]       \u2506 1       \u2502|\n|\u2502 [3, 4, null] \u2506 3       \u2502|\n|\u2502 [null, 5]    \u2506 null    \u2502|\n|\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr_list/#narwhals.expr.ExprListNamespace.len","title":"len","text":"<pre><code>len() -&gt; ExprT\n</code></pre> <p>Return the number of elements in each list.</p> <p>Null values count towards the total.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pl.DataFrame({\"a\": [[1, 2], [3, 4, None], None, []]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(a_len=nw.col(\"a\").list.len())\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|   Narwhals DataFrame   |\n|------------------------|\n|shape: (4, 2)           |\n|\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510|\n|\u2502 a            \u2506 a_len \u2502|\n|\u2502 ---          \u2506 ---   \u2502|\n|\u2502 list[i64]    \u2506 u32   \u2502|\n|\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561|\n|\u2502 [1, 2]       \u2506 2     \u2502|\n|\u2502 [3, 4, null] \u2506 3     \u2502|\n|\u2502 null         \u2506 null  \u2502|\n|\u2502 []           \u2506 0     \u2502|\n|\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr_list/#narwhals.expr.ExprListNamespace.unique","title":"unique","text":"<pre><code>unique() -&gt; ExprT\n</code></pre> <p>Get the unique/distinct values in the list.</p> <p>Null values are included in the result. The order of unique values is not guaranteed.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pl.DataFrame({\"a\": [[1, 1, 2], [3, 3, None], None, []]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(a_unique=nw.col(\"a\").list.unique())\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|     Narwhals DataFrame     |\n|----------------------------|\n|shape: (4, 2)               |\n|\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510|\n|\u2502 a            \u2506 a_unique  \u2502|\n|\u2502 ---          \u2506 ---       \u2502|\n|\u2502 list[i64]    \u2506 list[i64] \u2502|\n|\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561|\n|\u2502 [1, 1, 2]    \u2506 [1, 2]    \u2502|\n|\u2502 [3, 3, null] \u2506 [null, 3] \u2502|\n|\u2502 null         \u2506 null      \u2502|\n|\u2502 []           \u2506 []        \u2502|\n|\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr_name/","title":"<code>narwhals.Expr.name</code>","text":""},{"location":"api-reference/expr_name/#narwhals.expr.ExprNameNamespace.keep","title":"keep","text":"<pre><code>keep() -&gt; ExprT\n</code></pre> <p>Keep the original root name of the expression.</p> Notes <p>For Polars versions prior to 1.32, this will undo any previous renaming operations on the expression.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"foo\": [1, 2], \"BAR\": [4, 5]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.select(nw.col(\"foo\").alias(\"alias_for_foo\").name.keep()).columns\n['foo']\n</code></pre>"},{"location":"api-reference/expr_name/#narwhals.expr.ExprNameNamespace.map","title":"map","text":"<pre><code>map(function: Callable[[str], str]) -&gt; ExprT\n</code></pre> <p>Rename the output of an expression by mapping a function over the root name.</p> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>Callable[[str], str]</code> <p>Function that maps a root name to a new name.</p> required Notes <p>For Polars versions prior to 1.32, this will undo any previous renaming operations on the expression.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"foo\": [1, 2], \"BAR\": [4, 5]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; renaming_func = lambda s: s[::-1]  # reverse column name\n&gt;&gt;&gt; df.select(nw.col(\"foo\", \"BAR\").name.map(renaming_func)).columns\n['oof', 'RAB']\n</code></pre>"},{"location":"api-reference/expr_name/#narwhals.expr.ExprNameNamespace.prefix","title":"prefix","text":"<pre><code>prefix(prefix: str) -&gt; ExprT\n</code></pre> <p>Add a prefix to the root column name of the expression.</p> <p>Parameters:</p> Name Type Description Default <code>prefix</code> <code>str</code> <p>Prefix to add to the root column name.</p> required Notes <p>For Polars versions prior to 1.32, this will undo any previous renaming operations on the expression.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pl.DataFrame({\"foo\": [1, 2], \"BAR\": [4, 5]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.select(nw.col(\"foo\", \"BAR\").name.prefix(\"with_prefix\")).columns\n['with_prefixfoo', 'with_prefixBAR']\n</code></pre>"},{"location":"api-reference/expr_name/#narwhals.expr.ExprNameNamespace.suffix","title":"suffix","text":"<pre><code>suffix(suffix: str) -&gt; ExprT\n</code></pre> <p>Add a suffix to the root column name of the expression.</p> <p>Parameters:</p> Name Type Description Default <code>suffix</code> <code>str</code> <p>Suffix to add to the root column name.</p> required Notes <p>For Polars versions prior to 1.32, this will undo any previous renaming operations on the expression.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pl.DataFrame({\"foo\": [1, 2], \"BAR\": [4, 5]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.select(nw.col(\"foo\", \"BAR\").name.suffix(\"_with_suffix\")).columns\n['foo_with_suffix', 'BAR_with_suffix']\n</code></pre>"},{"location":"api-reference/expr_name/#narwhals.expr.ExprNameNamespace.to_lowercase","title":"to_lowercase","text":"<pre><code>to_lowercase() -&gt; ExprT\n</code></pre> <p>Make the root column name lowercase.</p> Notes <p>For Polars versions prior to 1.32, this will undo any previous renaming operations on the expression.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pa.table({\"foo\": [1, 2], \"BAR\": [4, 5]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.select(nw.col(\"foo\", \"BAR\").name.to_lowercase()).columns\n['foo', 'bar']\n</code></pre>"},{"location":"api-reference/expr_name/#narwhals.expr.ExprNameNamespace.to_uppercase","title":"to_uppercase","text":"<pre><code>to_uppercase() -&gt; ExprT\n</code></pre> <p>Make the root column name uppercase.</p> Notes <p>For Polars versions prior to 1.32, this will undo any previous renaming operations on the expression.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pa.table({\"foo\": [1, 2], \"BAR\": [4, 5]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.select(nw.col(\"foo\", \"BAR\").name.to_uppercase()).columns\n['FOO', 'BAR']\n</code></pre>"},{"location":"api-reference/expr_str/","title":"<code>narwhals.Expr.str</code>","text":""},{"location":"api-reference/expr_str/#narwhals.expr.ExprStringNamespace.contains","title":"contains","text":"<pre><code>contains(pattern: str, *, literal: bool = False) -&gt; ExprT\n</code></pre> <p>Check if string contains a substring that matches a pattern.</p> <p>Parameters:</p> Name Type Description Default <code>pattern</code> <code>str</code> <p>A Character sequence or valid regular expression pattern.</p> required <code>literal</code> <code>bool</code> <p>If True, treats the pattern as a literal string.      If False, assumes the pattern is a regular expression.</p> <code>False</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pa.table({\"pets\": [\"cat\", \"dog\", \"rabbit and parrot\"]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(\n...     default_match=nw.col(\"pets\").str.contains(\"cat|parrot\"),\n...     case_insensitive_match=nw.col(\"pets\").str.contains(\"cat|(?i)parrot\"),\n... ).to_native()\npyarrow.Table\npets: string\ndefault_match: bool\ncase_insensitive_match: bool\n----\npets: [[\"cat\",\"dog\",\"rabbit and parrot\"]]\ndefault_match: [[true,false,true]]\ncase_insensitive_match: [[true,false,true]]\n</code></pre>"},{"location":"api-reference/expr_str/#narwhals.expr.ExprStringNamespace.ends_with","title":"ends_with","text":"<pre><code>ends_with(suffix: str) -&gt; ExprT\n</code></pre> <p>Check if string values end with a substring.</p> <p>Parameters:</p> Name Type Description Default <code>suffix</code> <code>str</code> <p>suffix substring</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"fruits\": [\"apple\", \"mango\", None]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(has_suffix=nw.col(\"fruits\").str.ends_with(\"ngo\"))\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame |\n|-------------------|\n|  fruits has_suffix|\n|0  apple      False|\n|1  mango       True|\n|2   None       None|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr_str/#narwhals.expr.ExprStringNamespace.head","title":"head","text":"<pre><code>head(n: int = 5) -&gt; ExprT\n</code></pre> <p>Take the first n elements of each string.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Number of elements to take. Negative indexing is not supported.</p> <code>5</code> Notes <p>If the length of the string has fewer than <code>n</code> characters, the full string is returned.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pa.table({\"lyrics\": [\"taata\", \"taatatata\", \"zukkyun\"]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(lyrics_head=nw.col(\"lyrics\").str.head()).to_native()\npyarrow.Table\nlyrics: string\nlyrics_head: string\n----\nlyrics: [[\"taata\",\"taatatata\",\"zukkyun\"]]\nlyrics_head: [[\"taata\",\"taata\",\"zukky\"]]\n</code></pre>"},{"location":"api-reference/expr_str/#narwhals.expr.ExprStringNamespace.len_chars","title":"len_chars","text":"<pre><code>len_chars() -&gt; ExprT\n</code></pre> <p>Return the length of each string as the number of characters.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pl.DataFrame({\"words\": [\"foo\", \"345\", None]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(words_len=nw.col(\"words\").str.len_chars())\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n| Narwhals DataFrame  |\n|---------------------|\n|shape: (3, 2)        |\n|\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510|\n|\u2502 words \u2506 words_len \u2502|\n|\u2502 ---   \u2506 ---       \u2502|\n|\u2502 str   \u2506 u32       \u2502|\n|\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561|\n|\u2502 foo   \u2506 3         \u2502|\n|\u2502 345   \u2506 3         \u2502|\n|\u2502 null  \u2506 null      \u2502|\n|\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr_str/#narwhals.expr.ExprStringNamespace.replace","title":"replace","text":"<pre><code>replace(\n    pattern: str,\n    value: str | IntoExpr,\n    *,\n    literal: bool = False,\n    n: int = 1\n) -&gt; ExprT\n</code></pre> <p>Replace first matching regex/literal substring with a new string value.</p> <p>Parameters:</p> Name Type Description Default <code>pattern</code> <code>str</code> <p>A valid regular expression pattern.</p> required <code>value</code> <code>str | IntoExpr</code> <p>String that will replace the matched substring.</p> required <code>literal</code> <code>bool</code> <p>Treat <code>pattern</code> as a literal string.</p> <code>False</code> <code>n</code> <code>int</code> <p>Number of matches to replace.</p> <code>1</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"foo\": [\"123abc\", \"abc abc123\"]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(replaced=nw.col(\"foo\").str.replace(\"abc\", \"\"))\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|  Narwhals DataFrame  |\n|----------------------|\n|          foo replaced|\n|0      123abc      123|\n|1  abc abc123   abc123|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr_str/#narwhals.expr.ExprStringNamespace.replace_all","title":"replace_all","text":"<pre><code>replace_all(\n    pattern: str, value: IntoExpr, *, literal: bool = False\n) -&gt; ExprT\n</code></pre> <p>Replace all matching regex/literal substring with a new string value.</p> <p>Parameters:</p> Name Type Description Default <code>pattern</code> <code>str</code> <p>A valid regular expression pattern.</p> required <code>value</code> <code>IntoExpr</code> <p>String that will replace the matched substring.</p> required <code>literal</code> <code>bool</code> <p>Treat <code>pattern</code> as a literal string.</p> <code>False</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"foo\": [\"123abc\", \"abc abc123\"]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(replaced=nw.col(\"foo\").str.replace_all(\"abc\", \"\"))\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|  Narwhals DataFrame  |\n|----------------------|\n|          foo replaced|\n|0      123abc      123|\n|1  abc abc123      123|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr_str/#narwhals.expr.ExprStringNamespace.slice","title":"slice","text":"<pre><code>slice(offset: int, length: int | None = None) -&gt; ExprT\n</code></pre> <p>Create subslices of the string values of an expression.</p> <p>Parameters:</p> Name Type Description Default <code>offset</code> <code>int</code> <p>Start index. Negative indexing is supported.</p> required <code>length</code> <code>int | None</code> <p>Length of the slice. If set to <code>None</code> (default), the slice is taken to the end of the string.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"s\": [\"pear\", None, \"papaya\"]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(s_sliced=nw.col(\"s\").str.slice(4, length=3))\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|        s s_sliced|\n|0    pear         |\n|1    None     None|\n|2  papaya       ya|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr_str/#narwhals.expr.ExprStringNamespace.split","title":"split","text":"<pre><code>split(by: str) -&gt; ExprT\n</code></pre> <p>Split the string values of an expression by a substring.</p> <p>Parameters:</p> Name Type Description Default <code>by</code> <code>str</code> <p>Substring to split by.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pl.DataFrame({\"s\": [\"foo bar\", \"foo_bar\"]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(nw.col(\"s\").str.split(\"_\").alias(\"s_split\"))\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|     Narwhals DataFrame     |\n|----------------------------|\n|shape: (2, 2)               |\n|\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510|\n|\u2502 s       \u2506 s_split        \u2502|\n|\u2502 ---     \u2506 ---            \u2502|\n|\u2502 str     \u2506 list[str]      \u2502|\n|\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561|\n|\u2502 foo bar \u2506 [\"foo bar\"]    \u2502|\n|\u2502 foo_bar \u2506 [\"foo\", \"bar\"] \u2502|\n|\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr_str/#narwhals.expr.ExprStringNamespace.starts_with","title":"starts_with","text":"<pre><code>starts_with(prefix: str) -&gt; ExprT\n</code></pre> <p>Check if string values start with a substring.</p> <p>Parameters:</p> Name Type Description Default <code>prefix</code> <code>str</code> <p>prefix substring</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"fruits\": [\"apple\", \"mango\", None]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(has_prefix=nw.col(\"fruits\").str.starts_with(\"app\"))\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame |\n|-------------------|\n|  fruits has_prefix|\n|0  apple       True|\n|1  mango      False|\n|2   None       None|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr_str/#narwhals.expr.ExprStringNamespace.strip_chars","title":"strip_chars","text":"<pre><code>strip_chars(characters: str | None = None) -&gt; ExprT\n</code></pre> <p>Remove leading and trailing characters.</p> <p>Parameters:</p> Name Type Description Default <code>characters</code> <code>str | None</code> <p>The set of characters to be removed. All combinations of this set of characters will be stripped from the start and end of the string. If set to None (default), all leading and trailing whitespace is removed instead.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pl.DataFrame({\"fruits\": [\"apple\", \"\\nmango\"]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(stripped=nw.col(\"fruits\").str.strip_chars()).to_dict(\n...     as_series=False\n... )\n{'fruits': ['apple', '\\nmango'], 'stripped': ['apple', 'mango']}\n</code></pre>"},{"location":"api-reference/expr_str/#narwhals.expr.ExprStringNamespace.tail","title":"tail","text":"<pre><code>tail(n: int = 5) -&gt; ExprT\n</code></pre> <p>Take the last n elements of each string.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Number of elements to take. Negative indexing is not supported.</p> <code>5</code> Notes <p>If the length of the string has fewer than <code>n</code> characters, the full string is returned.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pa.table({\"lyrics\": [\"taata\", \"taatatata\", \"zukkyun\"]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(lyrics_tail=nw.col(\"lyrics\").str.tail()).to_native()\npyarrow.Table\nlyrics: string\nlyrics_tail: string\n----\nlyrics: [[\"taata\",\"taatatata\",\"zukkyun\"]]\nlyrics_tail: [[\"taata\",\"atata\",\"kkyun\"]]\n</code></pre>"},{"location":"api-reference/expr_str/#narwhals.expr.ExprStringNamespace.to_date","title":"to_date","text":"<pre><code>to_date(format: str | None = None) -&gt; ExprT\n</code></pre> <p>Convert to date dtype.</p> Warning <p>As different backends auto-infer format in different ways, if <code>format=None</code> there is no guarantee that the result will be equal.</p> <p>Parameters:</p> Name Type Description Default <code>format</code> <code>str | None</code> <p>Format to use for conversion. If set to None (default), the format is inferred from the data.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pa.table({\"a\": [\"2020-01-01\", \"2020-01-02\"]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.select(nw.col(\"a\").str.to_date(format=\"%Y-%m-%d\"))\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|     Narwhals DataFrame     |\n|----------------------------|\n|pyarrow.Table               |\n|a: date32[day]              |\n|----                        |\n|a: [[2020-01-01,2020-01-02]]|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr_str/#narwhals.expr.ExprStringNamespace.to_datetime","title":"to_datetime","text":"<pre><code>to_datetime(format: str | None = None) -&gt; ExprT\n</code></pre> <p>Convert to Datetime dtype.</p> Notes <ul> <li>pandas defaults to nanosecond time unit, Polars to microsecond.   Prior to pandas 2.0, nanoseconds were the only time unit supported   in pandas, with no ability to set any other one. The ability to   set the time unit in pandas, if the version permits, will arrive.</li> <li>timezone-aware strings are all converted to and parsed as UTC.</li> </ul> Warning <p>As different backends auto-infer format in different ways, if <code>format=None</code> there is no guarantee that the result will be equal.</p> <p>Parameters:</p> Name Type Description Default <code>format</code> <code>str | None</code> <p>Format to use for conversion. If set to None (default), the format is inferred from the data.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pl.DataFrame({\"a\": [\"2020-01-01\", \"2020-01-02\"]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.select(nw.col(\"a\").str.to_datetime(format=\"%Y-%m-%d\"))\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|  Narwhals DataFrame   |\n|-----------------------|\n|shape: (2, 1)          |\n|\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510|\n|\u2502 a                   \u2502|\n|\u2502 ---                 \u2502|\n|\u2502 datetime[\u03bcs]        \u2502|\n|\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561|\n|\u2502 2020-01-01 00:00:00 \u2502|\n|\u2502 2020-01-02 00:00:00 \u2502|\n|\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr_str/#narwhals.expr.ExprStringNamespace.to_lowercase","title":"to_lowercase","text":"<pre><code>to_lowercase() -&gt; ExprT\n</code></pre> <p>Transform string to lowercase variant.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"fruits\": [\"APPLE\", None]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(lower_col=nw.col(\"fruits\").str.to_lowercase())\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|  fruits lower_col|\n|0  APPLE     apple|\n|1   None      None|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr_str/#narwhals.expr.ExprStringNamespace.to_titlecase","title":"to_titlecase","text":"<pre><code>to_titlecase() -&gt; ExprT\n</code></pre> <p>Modify strings to their titlecase equivalent.</p> Notes <p>This is a form of case transform where the first letter of each word is capitalized, with the rest of the word in lowercase.</p> <p>Word boundaries are defined by non-alphabetic characters, matching the behavior of <code>str.title</code></p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pl.DataFrame(\n...     {\n...         \"quotes\": [\n...             \"'e.t. phone home'\",\n...             \"you talkin' to me?\",\n...             \"to infinity,and BEYOND!\",\n...         ]\n...     }\n... )\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(quotes_title=nw.col(\"quotes\").str.to_titlecase())\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|                 Narwhals DataFrame                  |\n|-----------------------------------------------------|\n|shape: (3, 2)                                        |\n|\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510|\n|\u2502 quotes                  \u2506 quotes_title            \u2502|\n|\u2502 ---                     \u2506 ---                     \u2502|\n|\u2502 str                     \u2506 str                     \u2502|\n|\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561|\n|\u2502 'e.t. phone home'       \u2506 'E.T. Phone Home'       \u2502|\n|\u2502 you talkin' to me?      \u2506 You Talkin' To Me?      \u2502|\n|\u2502 to infinity,and BEYOND! \u2506 To Infinity,And Beyond! \u2502|\n|\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr_str/#narwhals.expr.ExprStringNamespace.to_uppercase","title":"to_uppercase","text":"<pre><code>to_uppercase() -&gt; ExprT\n</code></pre> <p>Transform string to uppercase variant.</p> Notes <p>The PyArrow backend will convert '\u00df' to '\u1e9e' instead of 'SS'. For more info see the related issue. There may be other unicode-edge-case-related variations across implementations.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"fruits\": [\"apple\", None]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(upper_col=nw.col(\"fruits\").str.to_uppercase())\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|  fruits upper_col|\n|0  apple     APPLE|\n|1   None      None|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr_str/#narwhals.expr.ExprStringNamespace.zfill","title":"zfill","text":"<pre><code>zfill(width: int) -&gt; ExprT\n</code></pre> <p>Transform string to zero-padded variant.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>The desired length of the string after padding. If the length of the string is greater than <code>width</code>, no padding is applied. If <code>width</code> is less than 0, no padding is applied.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"digits\": [\"+1\", \"-1\", \"1\", None]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(zfill_col=nw.col(\"digits\").str.zfill(3))\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|  digits zfill_col|\n|0     +1       +01|\n|1     -1       -01|\n|2      1       001|\n|3   None      None|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr_struct/","title":"<code>narwhals.Expr.struct</code>","text":""},{"location":"api-reference/expr_struct/#narwhals.expr.ExprStructNamespace.field","title":"field","text":"<pre><code>field(name: str) -&gt; ExprT\n</code></pre> <p>Retrieve a Struct field as a new expression.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the struct field to retrieve.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pl.DataFrame(\n...     {\"user\": [{\"id\": \"0\", \"name\": \"john\"}, {\"id\": \"1\", \"name\": \"jane\"}]}\n... )\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(name=nw.col(\"user\").struct.field(\"name\"))\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|  Narwhals DataFrame   |\n|-----------------------|\n|shape: (2, 2)          |\n|\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510|\n|\u2502 user         \u2506 name \u2502|\n|\u2502 ---          \u2506 ---  \u2502|\n|\u2502 struct[2]    \u2506 str  \u2502|\n|\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561|\n|\u2502 {\"0\",\"john\"} \u2506 john \u2502|\n|\u2502 {\"1\",\"jane\"} \u2506 jane \u2502|\n|\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/group_by/","title":"<code>narwhals.GroupBy</code>","text":""},{"location":"api-reference/group_by/#narwhals.group_by.GroupBy.agg","title":"agg","text":"<pre><code>agg(\n    *aggs: Expr | Iterable[Expr], **named_aggs: Expr\n) -&gt; DataFrameT\n</code></pre> <p>Compute aggregations for each group of a group by operation.</p> <p>Parameters:</p> Name Type Description Default <code>aggs</code> <code>Expr | Iterable[Expr]</code> <p>Aggregations to compute for each group of the group by operation, specified as positional arguments.</p> <code>()</code> <code>named_aggs</code> <code>Expr</code> <p>Additional aggregations, specified as keyword arguments.</p> <code>{}</code> <p>Examples:</p> <p>Group by one column or by multiple columns and call <code>agg</code> to compute the grouped sum of another column.</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame(\n...     {\n...         \"a\": [\"a\", \"b\", \"a\", \"b\", \"c\"],\n...         \"b\": [1, 2, 1, 3, 3],\n...         \"c\": [5, 4, 3, 2, 1],\n...     }\n... )\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt;\n&gt;&gt;&gt; df.group_by(\"a\").agg(nw.col(\"b\").sum()).sort(\"a\")\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|        a  b      |\n|     0  a  2      |\n|     1  b  5      |\n|     2  c  3      |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt;\n&gt;&gt;&gt; df.group_by(\"a\", \"b\").agg(nw.col(\"c\").sum()).sort(\"a\", \"b\").to_native()\n   a  b  c\n0  a  1  8\n1  b  2  4\n2  b  3  2\n3  c  3  1\n</code></pre>"},{"location":"api-reference/implementation/","title":"<code>narwhals.Implementation</code>","text":"<p>               Bases: <code>NoAutoEnum</code></p> <p>Implementation of native object (pandas, Polars, PyArrow, ...).</p>"},{"location":"api-reference/implementation/#narwhals.Implementation.CUDF","title":"CUDF  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CUDF = 'cudf'\n</code></pre> <p>cuDF implementation.</p>"},{"location":"api-reference/implementation/#narwhals.Implementation.DASK","title":"DASK  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DASK = 'dask'\n</code></pre> <p>Dask implementation.</p>"},{"location":"api-reference/implementation/#narwhals.Implementation.DUCKDB","title":"DUCKDB  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DUCKDB = 'duckdb'\n</code></pre> <p>DuckDB implementation.</p>"},{"location":"api-reference/implementation/#narwhals.Implementation.IBIS","title":"IBIS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>IBIS = 'ibis'\n</code></pre> <p>Ibis implementation.</p>"},{"location":"api-reference/implementation/#narwhals.Implementation.MODIN","title":"MODIN  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MODIN = 'modin'\n</code></pre> <p>Modin implementation.</p>"},{"location":"api-reference/implementation/#narwhals.Implementation.PANDAS","title":"PANDAS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PANDAS = 'pandas'\n</code></pre> <p>pandas implementation.</p>"},{"location":"api-reference/implementation/#narwhals.Implementation.POLARS","title":"POLARS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>POLARS = 'polars'\n</code></pre> <p>Polars implementation.</p>"},{"location":"api-reference/implementation/#narwhals.Implementation.PYARROW","title":"PYARROW  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PYARROW = 'pyarrow'\n</code></pre> <p>PyArrow implementation.</p>"},{"location":"api-reference/implementation/#narwhals.Implementation.PYSPARK","title":"PYSPARK  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PYSPARK = 'pyspark'\n</code></pre> <p>PySpark implementation.</p>"},{"location":"api-reference/implementation/#narwhals.Implementation.PYSPARK_CONNECT","title":"PYSPARK_CONNECT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PYSPARK_CONNECT = 'pyspark[connect]'\n</code></pre> <p>PySpark Connect implementation.</p>"},{"location":"api-reference/implementation/#narwhals.Implementation.SQLFRAME","title":"SQLFRAME  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SQLFRAME = 'sqlframe'\n</code></pre> <p>SQLFrame implementation.</p>"},{"location":"api-reference/implementation/#narwhals.Implementation.UNKNOWN","title":"UNKNOWN  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UNKNOWN = 'unknown'\n</code></pre> <p>Unknown implementation.</p>"},{"location":"api-reference/implementation/#narwhals.Implementation.from_backend","title":"from_backend  <code>classmethod</code>","text":"<pre><code>from_backend(\n    backend: IntoBackend[Backend] | UnknownBackendName,\n) -&gt; Implementation\n</code></pre> <p>Instantiate from native namespace module, string, or Implementation.</p> <p>Parameters:</p> Name Type Description Default <code>backend</code> <code>IntoBackend[Backend] | UnknownBackendName</code> <p>Backend to instantiate Implementation from.</p> required"},{"location":"api-reference/implementation/#narwhals.Implementation.from_native_namespace","title":"from_native_namespace  <code>classmethod</code>","text":"<pre><code>from_native_namespace(\n    native_namespace: ModuleType,\n) -&gt; Implementation\n</code></pre> <p>Instantiate Implementation object from a native namespace module.</p> <p>Parameters:</p> Name Type Description Default <code>native_namespace</code> <code>ModuleType</code> <p>Native namespace.</p> required"},{"location":"api-reference/implementation/#narwhals.Implementation.from_string","title":"from_string  <code>classmethod</code>","text":"<pre><code>from_string(backend_name: str) -&gt; Implementation\n</code></pre> <p>Instantiate Implementation object from a native namespace module.</p> <p>Parameters:</p> Name Type Description Default <code>backend_name</code> <code>str</code> <p>Name of backend, expressed as string.</p> required"},{"location":"api-reference/implementation/#narwhals.Implementation.is_cudf","title":"is_cudf","text":"<pre><code>is_cudf() -&gt; bool\n</code></pre> <p>Return whether implementation is cuDF.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pl.DataFrame({\"a\": [1, 2, 3]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.implementation.is_cudf()\nFalse\n</code></pre>"},{"location":"api-reference/implementation/#narwhals.Implementation.is_dask","title":"is_dask","text":"<pre><code>is_dask() -&gt; bool\n</code></pre> <p>Return whether implementation is Dask.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pl.DataFrame({\"a\": [1, 2, 3]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.implementation.is_dask()\nFalse\n</code></pre>"},{"location":"api-reference/implementation/#narwhals.Implementation.is_duckdb","title":"is_duckdb","text":"<pre><code>is_duckdb() -&gt; bool\n</code></pre> <p>Return whether implementation is DuckDB.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pl.DataFrame({\"a\": [1, 2, 3]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.implementation.is_duckdb()\nFalse\n</code></pre>"},{"location":"api-reference/implementation/#narwhals.Implementation.is_ibis","title":"is_ibis","text":"<pre><code>is_ibis() -&gt; bool\n</code></pre> <p>Return whether implementation is Ibis.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pl.DataFrame({\"a\": [1, 2, 3]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.implementation.is_ibis()\nFalse\n</code></pre>"},{"location":"api-reference/implementation/#narwhals.Implementation.is_modin","title":"is_modin","text":"<pre><code>is_modin() -&gt; bool\n</code></pre> <p>Return whether implementation is Modin.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pl.DataFrame({\"a\": [1, 2, 3]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.implementation.is_modin()\nFalse\n</code></pre>"},{"location":"api-reference/implementation/#narwhals.Implementation.is_pandas","title":"is_pandas","text":"<pre><code>is_pandas() -&gt; bool\n</code></pre> <p>Return whether implementation is pandas.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [1, 2, 3]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.implementation.is_pandas()\nTrue\n</code></pre>"},{"location":"api-reference/implementation/#narwhals.Implementation.is_pandas_like","title":"is_pandas_like","text":"<pre><code>is_pandas_like() -&gt; bool\n</code></pre> <p>Return whether implementation is pandas, Modin, or cuDF.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [1, 2, 3]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.implementation.is_pandas_like()\nTrue\n</code></pre>"},{"location":"api-reference/implementation/#narwhals.Implementation.is_polars","title":"is_polars","text":"<pre><code>is_polars() -&gt; bool\n</code></pre> <p>Return whether implementation is Polars.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pl.DataFrame({\"a\": [1, 2, 3]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.implementation.is_polars()\nTrue\n</code></pre>"},{"location":"api-reference/implementation/#narwhals.Implementation.is_pyarrow","title":"is_pyarrow","text":"<pre><code>is_pyarrow() -&gt; bool\n</code></pre> <p>Return whether implementation is PyArrow.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pl.DataFrame({\"a\": [1, 2, 3]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.implementation.is_pyarrow()\nFalse\n</code></pre>"},{"location":"api-reference/implementation/#narwhals.Implementation.is_pyspark","title":"is_pyspark","text":"<pre><code>is_pyspark() -&gt; bool\n</code></pre> <p>Return whether implementation is PySpark.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pl.DataFrame({\"a\": [1, 2, 3]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.implementation.is_pyspark()\nFalse\n</code></pre>"},{"location":"api-reference/implementation/#narwhals.Implementation.is_pyspark_connect","title":"is_pyspark_connect","text":"<pre><code>is_pyspark_connect() -&gt; bool\n</code></pre> <p>Return whether implementation is PySpark.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pl.DataFrame({\"a\": [1, 2, 3]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.implementation.is_pyspark_connect()\nFalse\n</code></pre>"},{"location":"api-reference/implementation/#narwhals.Implementation.is_spark_like","title":"is_spark_like","text":"<pre><code>is_spark_like() -&gt; bool\n</code></pre> <p>Return whether implementation is pyspark or sqlframe.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [1, 2, 3]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.implementation.is_spark_like()\nFalse\n</code></pre>"},{"location":"api-reference/implementation/#narwhals.Implementation.is_sqlframe","title":"is_sqlframe","text":"<pre><code>is_sqlframe() -&gt; bool\n</code></pre> <p>Return whether implementation is SQLFrame.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pl.DataFrame({\"a\": [1, 2, 3]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.implementation.is_sqlframe()\nFalse\n</code></pre>"},{"location":"api-reference/implementation/#narwhals.Implementation.to_native_namespace","title":"to_native_namespace","text":"<pre><code>to_native_namespace() -&gt; ModuleType\n</code></pre> <p>Return the native namespace module corresponding to Implementation.</p>"},{"location":"api-reference/lazy_group_by/","title":"<code>narwhals.LazyGroupBy</code>","text":""},{"location":"api-reference/lazy_group_by/#narwhals.group_by.LazyGroupBy.agg","title":"agg","text":"<pre><code>agg(\n    *aggs: Expr | Iterable[Expr], **named_aggs: Expr\n) -&gt; LazyFrameT\n</code></pre> <p>Compute aggregations for each group of a group by operation.</p> <p>Parameters:</p> Name Type Description Default <code>aggs</code> <code>Expr | Iterable[Expr]</code> <p>Aggregations to compute for each group of the group by operation, specified as positional arguments.</p> <code>()</code> <code>named_aggs</code> <code>Expr</code> <p>Additional aggregations, specified as keyword arguments.</p> <code>{}</code> <p>Examples:</p> <p>Group by one column or by multiple columns and call <code>agg</code> to compute the grouped sum of another column.</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; from narwhals.typing import IntoFrameT\n&gt;&gt;&gt; lf_native = pl.LazyFrame(\n...     {\n...         \"a\": [\"a\", \"b\", \"a\", \"b\", \"c\"],\n...         \"b\": [1, 2, 1, 3, 3],\n...         \"c\": [5, 4, 3, 2, 1],\n...     }\n... )\n&gt;&gt;&gt; lf = nw.from_native(lf_native)\n&gt;&gt;&gt;\n&gt;&gt;&gt; nw.to_native(lf.group_by(\"a\").agg(nw.col(\"b\").sum()).sort(\"a\")).collect()\nshape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 str \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 a   \u2506 2   \u2502\n\u2502 b   \u2506 5   \u2502\n\u2502 c   \u2506 3   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt;\n&gt;&gt;&gt; lf.group_by(\"a\", \"b\").agg(nw.sum(\"c\")).sort(\"a\", \"b\").collect()\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame |\n|-------------------|\n|shape: (4, 3)      |\n|\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510|\n|\u2502 a   \u2506 b   \u2506 c   \u2502|\n|\u2502 --- \u2506 --- \u2506 --- \u2502|\n|\u2502 str \u2506 i64 \u2506 i64 \u2502|\n|\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561|\n|\u2502 a   \u2506 1   \u2506 8   \u2502|\n|\u2502 b   \u2506 2   \u2506 4   \u2502|\n|\u2502 b   \u2506 3   \u2506 2   \u2502|\n|\u2502 c   \u2506 3   \u2506 1   \u2502|\n|\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/lazyframe/","title":"<code>narwhals.LazyFrame</code>","text":"<p>Narwhals LazyFrame, backed by a native lazyframe.</p> Warning <p>This class is not meant to be instantiated directly - instead use <code>narwhals.from_native</code> with a native object that is a lazy dataframe from one of the supported backend (e.g. polars.LazyFrame, dask_expr._collection.DataFrame): <pre><code>narwhals.from_native(native_lazyframe)\n</code></pre></p>"},{"location":"api-reference/lazyframe/#narwhals.dataframe.LazyFrame.columns","title":"columns  <code>property</code>","text":"<pre><code>columns: list[str]\n</code></pre> <p>Get column names.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import duckdb\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; lf_native = duckdb.sql(\"SELECT * FROM VALUES (1, 4.5), (3, 2.) df(a, b)\")\n&gt;&gt;&gt; nw.from_native(lf_native).columns\n['a', 'b']\n</code></pre>"},{"location":"api-reference/lazyframe/#narwhals.dataframe.LazyFrame.implementation","title":"implementation  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>implementation: _Implementation = _Implementation()\n</code></pre> <p>Return <code>narwhals.Implementation</code> of native frame.</p> <p>This can be useful when you need to use special-casing for features outside of Narwhals' scope - for example, when dealing with pandas' Period Dtype.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [1, 2, 3]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.implementation\n&lt;Implementation.PANDAS: 'pandas'&gt;\n&gt;&gt;&gt; df.implementation.is_pandas()\nTrue\n&gt;&gt;&gt; df.implementation.is_pandas_like()\nTrue\n&gt;&gt;&gt; df.implementation.is_polars()\nFalse\n</code></pre>"},{"location":"api-reference/lazyframe/#narwhals.dataframe.LazyFrame.schema","title":"schema  <code>property</code>","text":"<pre><code>schema: Schema\n</code></pre> <p>Get an ordered mapping of column names to their data type.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import duckdb\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; lf_native = duckdb.sql(\"SELECT * FROM VALUES (1, 4.5), (3, 2.) df(a, b)\")\n&gt;&gt;&gt; nw.from_native(lf_native).schema\nSchema({'a': Int32, 'b': Decimal})\n</code></pre>"},{"location":"api-reference/lazyframe/#narwhals.dataframe.LazyFrame.collect","title":"collect","text":"<pre><code>collect(\n    backend: (\n        IntoBackend[Polars | Pandas | Arrow] | None\n    ) = None,\n    **kwargs: Any\n) -&gt; DataFrame[Any]\n</code></pre> <p>Materialize this LazyFrame into a DataFrame.</p> <p>As each underlying lazyframe has different arguments to set when materializing the lazyframe into a dataframe, we allow to pass them as kwargs (see examples below for how to generalize the specification).</p> <p>Parameters:</p> Name Type Description Default <code>backend</code> <code>IntoBackend[Polars | Pandas | Arrow] | None</code> <p>specifies which eager backend collect to. This will be the underlying backend for the resulting Narwhals DataFrame. If None, then the following default conversions will be applied</p> <ul> <li><code>polars.LazyFrame</code> -&gt; <code>polars.DataFrame</code></li> <li><code>dask.DataFrame</code> -&gt; <code>pandas.DataFrame</code></li> <li><code>duckdb.PyRelation</code> -&gt; <code>pyarrow.Table</code></li> <li><code>pyspark.DataFrame</code> -&gt; <code>pyarrow.Table</code></li> </ul> <p><code>backend</code> can be specified in various ways</p> <ul> <li>As <code>Implementation.&lt;BACKEND&gt;</code> with <code>BACKEND</code> being <code>PANDAS</code>, <code>PYARROW</code>     or <code>POLARS</code>.</li> <li>As a string: <code>\"pandas\"</code>, <code>\"pyarrow\"</code> or <code>\"polars\"</code></li> <li>Directly as a module <code>pandas</code>, <code>pyarrow</code> or <code>polars</code>.</li> </ul> <code>None</code> <code>kwargs</code> <code>Any</code> <p>backend specific kwargs to pass along. To know more please check the backend specific documentation</p> <ul> <li>polars.LazyFrame.collect</li> <li>dask.dataframe.DataFrame.compute</li> </ul> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import duckdb\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; lf_native = duckdb.sql(\"SELECT * FROM VALUES (1, 2), (3, 4) df(a, b)\")\n&gt;&gt;&gt; lf = nw.from_native(lf_native)\n&gt;&gt;&gt; lf\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals LazyFrame|\n|------------------|\n|\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 |\n|\u2502   a   \u2502   b   \u2502 |\n|\u2502 int32 \u2502 int32 \u2502 |\n|\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 |\n|\u2502     1 \u2502     2 \u2502 |\n|\u2502     3 \u2502     4 \u2502 |\n|\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; lf.collect()\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|  pyarrow.Table   |\n|  a: int32        |\n|  b: int32        |\n|  ----            |\n|  a: [[1,3]]      |\n|  b: [[2,4]]      |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/lazyframe/#narwhals.dataframe.LazyFrame.collect_schema","title":"collect_schema","text":"<pre><code>collect_schema() -&gt; Schema\n</code></pre> <p>Get an ordered mapping of column names to their data type.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import duckdb\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; lf_native = duckdb.sql(\"SELECT * FROM VALUES (1, 4.5), (3, 2.) df(a, b)\")\n&gt;&gt;&gt; nw.from_native(lf_native).collect_schema()\nSchema({'a': Int32, 'b': Decimal})\n</code></pre>"},{"location":"api-reference/lazyframe/#narwhals.dataframe.LazyFrame.drop","title":"drop","text":"<pre><code>drop(\n    *columns: str | Iterable[str], strict: bool = True\n) -&gt; Self\n</code></pre> <p>Remove columns from the LazyFrame.</p> <p>Parameters:</p> Name Type Description Default <code>*columns</code> <code>str | Iterable[str]</code> <p>Names of the columns that should be removed from the dataframe.</p> <code>()</code> <code>strict</code> <code>bool</code> <p>Validate that all column names exist in the schema and throw an exception if a column name does not exist in the schema.</p> <code>True</code> Warning <p><code>strict</code> argument is ignored for <code>polars&lt;1.0.0</code>.</p> <p>Please consider upgrading to a newer version or pass to eager mode.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import duckdb\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; lf_native = duckdb.sql(\"SELECT * FROM VALUES (1, 2), (3, 4) df(a, b)\")\n&gt;&gt;&gt; nw.from_native(lf_native).drop(\"a\").to_native()\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   b   \u2502\n\u2502 int32 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     2 \u2502\n\u2502     4 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/lazyframe/#narwhals.dataframe.LazyFrame.drop_nulls","title":"drop_nulls","text":"<pre><code>drop_nulls(subset: str | list[str] | None = None) -&gt; Self\n</code></pre> <p>Drop rows that contain null values.</p> <p>Parameters:</p> Name Type Description Default <code>subset</code> <code>str | list[str] | None</code> <p>Column name(s) for which null values are considered. If set to None (default), use all columns.</p> <code>None</code> Notes <p>pandas handles null values differently from Polars and PyArrow. See null_handling for reference.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import duckdb\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; lf_native = duckdb.sql(\"SELECT * FROM VALUES (1, NULL), (3, 4) df(a, b)\")\n&gt;&gt;&gt; nw.from_native(lf_native).drop_nulls()\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals LazyFrame|\n|------------------|\n|\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 |\n|\u2502   a   \u2502   b   \u2502 |\n|\u2502 int32 \u2502 int32 \u2502 |\n|\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 |\n|\u2502     3 \u2502     4 \u2502 |\n|\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/lazyframe/#narwhals.dataframe.LazyFrame.explode","title":"explode","text":"<pre><code>explode(\n    columns: str | Sequence[str], *more_columns: str\n) -&gt; Self\n</code></pre> <p>Explode the dataframe to long format by exploding the given columns.</p> Notes <p>It is possible to explode multiple columns only if these columns have matching element counts.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>str | Sequence[str]</code> <p>Column names. The underlying columns being exploded must be of the <code>List</code> data type.</p> required <code>*more_columns</code> <code>str</code> <p>Additional names of columns to explode, specified as positional arguments.</p> <code>()</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import duckdb\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = duckdb.sql(\n...     \"SELECT * FROM VALUES ('x', [1, 2]), ('y', [3, 4]), ('z', [5, 6]) df(a, b)\"\n... )\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.explode(\"b\").to_native()\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502    a    \u2502   b   \u2502\n\u2502 varchar \u2502 int32 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 x       \u2502     1 \u2502\n\u2502 x       \u2502     2 \u2502\n\u2502 y       \u2502     3 \u2502\n\u2502 y       \u2502     4 \u2502\n\u2502 z       \u2502     5 \u2502\n\u2502 z       \u2502     6 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/lazyframe/#narwhals.dataframe.LazyFrame.filter","title":"filter","text":"<pre><code>filter(\n    *predicates: IntoExpr | Iterable[IntoExpr],\n    **constraints: Any\n) -&gt; Self\n</code></pre> <p>Filter the rows in the LazyFrame based on a predicate expression.</p> <p>The original order of the remaining rows is preserved.</p> <p>Parameters:</p> Name Type Description Default <code>*predicates</code> <code>IntoExpr | Iterable[IntoExpr]</code> <p>Expression(s) that evaluates to a boolean Series.</p> <code>()</code> <code>**constraints</code> <code>Any</code> <p>Column filters; use <code>name = value</code> to filter columns by the supplied value. Each constraint will behave the same as <code>nw.col(name).eq(value)</code>, and will be implicitly joined with the other filter conditions using &amp;.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import duckdb\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = duckdb.sql('''\n...     SELECT * FROM VALUES\n...         (1, 6, 'a'),\n...         (2, 7, 'b'),\n...         (3, 8, 'c')\n...     df(foo, bar, ham)\n... ''')\n</code></pre> <p>Filter on one condition</p> <pre><code>&gt;&gt;&gt; nw.from_native(df_native).filter(nw.col(\"foo\") &gt; 1).to_native()\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  foo  \u2502  bar  \u2502   ham   \u2502\n\u2502 int32 \u2502 int32 \u2502 varchar \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     2 \u2502     7 \u2502 b       \u2502\n\u2502     3 \u2502     8 \u2502 c       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Filter on multiple conditions with implicit <code>&amp;</code></p> <pre><code>&gt;&gt;&gt; nw.from_native(df_native).filter(\n...     nw.col(\"foo\") &lt; 3, nw.col(\"ham\") == \"a\"\n... ).to_native()\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  foo  \u2502  bar  \u2502   ham   \u2502\n\u2502 int32 \u2502 int32 \u2502 varchar \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     1 \u2502     6 \u2502 a       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Filter on multiple conditions with <code>|</code></p> <pre><code>&gt;&gt;&gt; nw.from_native(df_native).filter(\n...     (nw.col(\"foo\") == 1) | (nw.col(\"ham\") == \"c\")\n... ).to_native()\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  foo  \u2502  bar  \u2502   ham   \u2502\n\u2502 int32 \u2502 int32 \u2502 varchar \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     1 \u2502     6 \u2502 a       \u2502\n\u2502     3 \u2502     8 \u2502 c       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Filter using <code>**kwargs</code> syntax</p> <pre><code>&gt;&gt;&gt; nw.from_native(df_native).filter(foo=2, ham=\"b\").to_native()\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  foo  \u2502  bar  \u2502   ham   \u2502\n\u2502 int32 \u2502 int32 \u2502 varchar \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     2 \u2502     7 \u2502 b       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/lazyframe/#narwhals.dataframe.LazyFrame.gather_every","title":"gather_every","text":"<pre><code>gather_every(n: int, offset: int = 0) -&gt; Self\n</code></pre>"},{"location":"api-reference/lazyframe/#narwhals.dataframe.LazyFrame.group_by","title":"group_by","text":"<pre><code>group_by(\n    *keys: IntoExpr | Iterable[IntoExpr],\n    drop_null_keys: Literal[False] = ...\n) -&gt; LazyGroupBy[Self]\n</code></pre><pre><code>group_by(\n    *keys: str | Iterable[str],\n    drop_null_keys: Literal[True]\n) -&gt; LazyGroupBy[Self]\n</code></pre> <pre><code>group_by(\n    *keys: IntoExpr | Iterable[IntoExpr],\n    drop_null_keys: bool = False\n) -&gt; LazyGroupBy[Self]\n</code></pre> <p>Start a group by operation.</p> <p>Parameters:</p> Name Type Description Default <code>*keys</code> <code>IntoExpr | Iterable[IntoExpr]</code> <p>Column(s) to group by. Accepts expression input. Strings are parsed as column names.</p> <code>()</code> <code>drop_null_keys</code> <code>bool</code> <p>if True, then groups where any key is null won't be included in the result.</p> <code>False</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import duckdb\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = duckdb.sql(\n...     \"SELECT * FROM VALUES (1, 'a'), (2, 'b'), (3, 'a') df(a, b)\"\n... )\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.group_by(\"b\").agg(nw.col(\"a\").sum()).sort(\"b\").to_native()\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502    b    \u2502   a    \u2502\n\u2502 varchar \u2502 int128 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 a       \u2502      4 \u2502\n\u2502 b       \u2502      2 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Expressions are also accepted.</p> <pre><code>&gt;&gt;&gt; df.group_by(nw.col(\"b\").str.len_chars()).agg(\n...     nw.col(\"a\").sum()\n... ).to_native()\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   b   \u2502   a    \u2502\n\u2502 int64 \u2502 int128 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     1 \u2502      6 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/lazyframe/#narwhals.dataframe.LazyFrame.head","title":"head","text":"<pre><code>head(n: int = 5) -&gt; Self\n</code></pre> <p>Get <code>n</code> rows.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Number of rows to return.</p> <code>5</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import dask.dataframe as dd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; lf_native = dd.from_dict({\"a\": [1, 2, 3], \"b\": [4, 5, 6]}, npartitions=1)\n&gt;&gt;&gt; nw.from_native(lf_native).head(2).collect()\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|        a  b      |\n|     0  1  4      |\n|     1  2  5      |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/lazyframe/#narwhals.dataframe.LazyFrame.join","title":"join","text":"<pre><code>join(\n    other: Self,\n    on: str | list[str] | None = None,\n    how: JoinStrategy = \"inner\",\n    *,\n    left_on: str | list[str] | None = None,\n    right_on: str | list[str] | None = None,\n    suffix: str = \"_right\"\n) -&gt; Self\n</code></pre> <p>Add a join operation to the Logical Plan.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Self</code> <p>Lazy DataFrame to join with.</p> required <code>on</code> <code>str | list[str] | None</code> <p>Name(s) of the join columns in both DataFrames. If set, <code>left_on</code> and <code>right_on</code> should be None.</p> <code>None</code> <code>how</code> <code>JoinStrategy</code> <p>Join strategy.</p> <ul> <li>inner: Returns rows that have matching values in both tables.</li> <li>left: Returns all rows from the left table, and the matched rows from the right table.</li> <li>full: Returns all rows in both dataframes, with the suffix appended to the right join keys.</li> <li>cross: Returns the Cartesian product of rows from both tables.</li> <li>semi: Filter rows that have a match in the right table.</li> <li>anti: Filter rows that do not have a match in the right table.</li> </ul> <code>'inner'</code> <code>left_on</code> <code>str | list[str] | None</code> <p>Join column of the left DataFrame.</p> <code>None</code> <code>right_on</code> <code>str | list[str] | None</code> <p>Join column of the right DataFrame.</p> <code>None</code> <code>suffix</code> <code>str</code> <p>Suffix to append to columns with a duplicate name.</p> <code>'_right'</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import duckdb\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native1 = duckdb.sql(\n...     \"SELECT * FROM VALUES (1, 'a'), (2, 'b') df(a, b)\"\n... )\n&gt;&gt;&gt; df_native2 = duckdb.sql(\n...     \"SELECT * FROM VALUES (1, 'x'), (3, 'y') df(a, c)\"\n... )\n&gt;&gt;&gt; df1 = nw.from_native(df_native1)\n&gt;&gt;&gt; df2 = nw.from_native(df_native2)\n&gt;&gt;&gt; df1.join(df2, on=\"a\")\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|     Narwhals LazyFrame      |\n|-----------------------------|\n|\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510|\n|\u2502   a   \u2502    b    \u2502    c    \u2502|\n|\u2502 int32 \u2502 varchar \u2502 varchar \u2502|\n|\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524|\n|\u2502     1 \u2502 a       \u2502 x       \u2502|\n|\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/lazyframe/#narwhals.dataframe.LazyFrame.join_asof","title":"join_asof","text":"<pre><code>join_asof(\n    other: Self,\n    *,\n    left_on: str | None = None,\n    right_on: str | None = None,\n    on: str | None = None,\n    by_left: str | list[str] | None = None,\n    by_right: str | list[str] | None = None,\n    by: str | list[str] | None = None,\n    strategy: AsofJoinStrategy = \"backward\",\n    suffix: str = \"_right\"\n) -&gt; Self\n</code></pre> <p>Perform an asof join.</p> <p>This is similar to a left-join except that we match on nearest key rather than equal keys.</p> <p>For Polars, both DataFrames must be sorted by the <code>on</code> key (within each <code>by</code> group if specified).</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Self</code> <p>DataFrame to join with.</p> required <code>left_on</code> <code>str | None</code> <p>Name(s) of the left join column(s).</p> <code>None</code> <code>right_on</code> <code>str | None</code> <p>Name(s) of the right join column(s).</p> <code>None</code> <code>on</code> <code>str | None</code> <p>Join column of both DataFrames. If set, left_on and right_on should be None.</p> <code>None</code> <code>by_left</code> <code>str | list[str] | None</code> <p>join on these columns before doing asof join</p> <code>None</code> <code>by_right</code> <code>str | list[str] | None</code> <p>join on these columns before doing asof join</p> <code>None</code> <code>by</code> <code>str | list[str] | None</code> <p>join on these columns before doing asof join</p> <code>None</code> <code>strategy</code> <code>AsofJoinStrategy</code> <p>Join strategy. The default is \"backward\".</p> <ul> <li>backward: selects the last row in the right DataFrame whose \"on\" key is less than or equal to the left's key.</li> <li>forward: selects the first row in the right DataFrame whose \"on\" key is greater than or equal to the left's key.</li> <li>nearest: search selects the last row in the right DataFrame whose value is nearest to the left's key.</li> </ul> <code>'backward'</code> <code>suffix</code> <code>str</code> <p>Suffix to append to columns with a duplicate name.</p> <code>'_right'</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data_gdp = {\n...     \"datetime\": [\n...         datetime(2016, 1, 1),\n...         datetime(2017, 1, 1),\n...         datetime(2018, 1, 1),\n...         datetime(2019, 1, 1),\n...         datetime(2020, 1, 1),\n...     ],\n...     \"gdp\": [4164, 4411, 4566, 4696, 4827],\n... }\n&gt;&gt;&gt; data_population = {\n...     \"datetime\": [\n...         datetime(2016, 3, 1),\n...         datetime(2018, 8, 1),\n...         datetime(2019, 1, 1),\n...     ],\n...     \"population\": [82.19, 82.66, 83.12],\n... }\n&gt;&gt;&gt; gdp_native = pl.DataFrame(data_gdp)\n&gt;&gt;&gt; population_native = pl.DataFrame(data_population)\n&gt;&gt;&gt; gdp = nw.from_native(gdp_native)\n&gt;&gt;&gt; population = nw.from_native(population_native)\n&gt;&gt;&gt; population.join_asof(gdp, on=\"datetime\", strategy=\"backward\").to_native()\nshape: (3, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 datetime            \u2506 population \u2506 gdp  \u2502\n\u2502 ---                 \u2506 ---        \u2506 ---  \u2502\n\u2502 datetime[\u03bcs]        \u2506 f64        \u2506 i64  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2016-03-01 00:00:00 \u2506 82.19      \u2506 4164 \u2502\n\u2502 2018-08-01 00:00:00 \u2506 82.66      \u2506 4566 \u2502\n\u2502 2019-01-01 00:00:00 \u2506 83.12      \u2506 4696 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/lazyframe/#narwhals.dataframe.LazyFrame.lazy","title":"lazy","text":"<pre><code>lazy() -&gt; Self\n</code></pre> <p>Restrict available API methods to lazy-only ones.</p> <p>This is a no-op, and exists only for compatibility with <code>DataFrame.lazy</code>.</p>"},{"location":"api-reference/lazyframe/#narwhals.dataframe.LazyFrame.pipe","title":"pipe","text":"<pre><code>pipe(\n    function: Callable[Concatenate[Self, PS], R],\n    *args: args,\n    **kwargs: kwargs\n) -&gt; R\n</code></pre> <p>Pipe function call.</p> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>Callable[Concatenate[Self, PS], R]</code> <p>Function to apply.</p> required <code>args</code> <code>args</code> <p>Positional arguments to pass to function.</p> <code>()</code> <code>kwargs</code> <code>kwargs</code> <p>Keyword arguments to pass to function.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import duckdb\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; lf_native = duckdb.sql(\"SELECT * FROM VALUES (1, 2), (3, 4) df(a, b)\")\n&gt;&gt;&gt; nw.from_native(lf_native).pipe(lambda x: x.select(\"a\")).to_native()\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   a   \u2502\n\u2502 int32 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     1 \u2502\n\u2502     3 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/lazyframe/#narwhals.dataframe.LazyFrame.rename","title":"rename","text":"<pre><code>rename(mapping: dict[str, str]) -&gt; Self\n</code></pre> <p>Rename column names.</p> <p>Parameters:</p> Name Type Description Default <code>mapping</code> <code>dict[str, str]</code> <p>Key value pairs that map from old name to new name, or a       function that takes the old name as input and returns the       new name.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import duckdb\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; lf_native = duckdb.sql(\"SELECT * FROM VALUES (1, 4.5), (3, 2.) df(a, b)\")\n&gt;&gt;&gt; nw.from_native(lf_native).rename({\"a\": \"c\"})\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|   Narwhals LazyFrame   |\n|------------------------|\n|\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510|\n|\u2502   c   \u2502      b       \u2502|\n|\u2502 int32 \u2502 decimal(2,1) \u2502|\n|\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524|\n|\u2502     1 \u2502          4.5 \u2502|\n|\u2502     3 \u2502          2.0 \u2502|\n|\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/lazyframe/#narwhals.dataframe.LazyFrame.select","title":"select","text":"<pre><code>select(\n    *exprs: IntoExpr | Iterable[IntoExpr],\n    **named_exprs: IntoExpr\n) -&gt; Self\n</code></pre> <p>Select columns from this LazyFrame.</p> <p>Parameters:</p> Name Type Description Default <code>*exprs</code> <code>IntoExpr | Iterable[IntoExpr]</code> <p>Column(s) to select, specified as positional arguments. Accepts expression input. Strings are parsed as column names.</p> <code>()</code> <code>**named_exprs</code> <code>IntoExpr</code> <p>Additional columns to select, specified as keyword arguments. The columns will be renamed to the keyword used.</p> <code>{}</code> Notes <p>If you'd like to select a column whose name isn't a string (for example, if you're working with pandas) then you should explicitly use <code>nw.col</code> instead of just passing the column name. For example, to select a column named <code>0</code> use <code>df.select(nw.col(0))</code>, not <code>df.select(0)</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import duckdb\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; lf_native = duckdb.sql(\"SELECT * FROM VALUES (1, 4.5), (3, 2.) df(a, b)\")\n&gt;&gt;&gt; nw.from_native(lf_native).select(\"a\", a_plus_1=nw.col(\"a\") + 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n| Narwhals LazyFrame |\n|--------------------|\n|\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510|\n|\u2502   a   \u2502 a_plus_1 \u2502|\n|\u2502 int32 \u2502  int32   \u2502|\n|\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524|\n|\u2502     1 \u2502        2 \u2502|\n|\u2502     3 \u2502        4 \u2502|\n|\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/lazyframe/#narwhals.dataframe.LazyFrame.sink_parquet","title":"sink_parquet","text":"<pre><code>sink_parquet(file: str | Path | BytesIO) -&gt; None\n</code></pre> <p>Write LazyFrame to Parquet file.</p> <p>This may allow larger-than-RAM datasets to be written to disk.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>str | Path | BytesIO</code> <p>String, path object or file-like object to which the dataframe will be written.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pl.LazyFrame({\"foo\": [1, 2], \"bar\": [6.0, 7.0]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.sink_parquet(\"out.parquet\")\n</code></pre>"},{"location":"api-reference/lazyframe/#narwhals.dataframe.LazyFrame.sort","title":"sort","text":"<pre><code>sort(\n    by: str | Iterable[str],\n    *more_by: str,\n    descending: bool | Sequence[bool] = False,\n    nulls_last: bool = False\n) -&gt; Self\n</code></pre> <p>Sort the LazyFrame by the given columns.</p> <p>Parameters:</p> Name Type Description Default <code>by</code> <code>str | Iterable[str]</code> <p>Column(s) names to sort by.</p> required <code>*more_by</code> <code>str</code> <p>Additional columns to sort by, specified as positional arguments.</p> <code>()</code> <code>descending</code> <code>bool | Sequence[bool]</code> <p>Sort in descending order. When sorting by multiple columns, can be specified per column by passing a sequence of booleans.</p> <code>False</code> <code>nulls_last</code> <code>bool</code> <p>Place null values last; can specify a single boolean applying to all columns or a sequence of booleans for per-column control.</p> <code>False</code> Warning <p>Unlike Polars, it is not possible to specify a sequence of booleans for <code>nulls_last</code> in order to control per-column behaviour. Instead a single boolean is applied for all <code>by</code> columns.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import duckdb\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = duckdb.sql(\n...     \"SELECT * FROM VALUES (1, 6.0, 'a'), (2, 5.0, 'c'), (NULL, 4.0, 'b') df(a, b, c)\"\n... )\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.sort(\"a\")\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|        Narwhals LazyFrame        |\n|----------------------------------|\n|\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510|\n|\u2502   a   \u2502      b       \u2502    c    \u2502|\n|\u2502 int32 \u2502 decimal(2,1) \u2502 varchar \u2502|\n|\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524|\n|\u2502  NULL \u2502          4.0 \u2502 b       \u2502|\n|\u2502     1 \u2502          6.0 \u2502 a       \u2502|\n|\u2502     2 \u2502          5.0 \u2502 c       \u2502|\n|\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/lazyframe/#narwhals.dataframe.LazyFrame.tail","title":"tail","text":"<pre><code>tail(n: int) -&gt; Self\n</code></pre>"},{"location":"api-reference/lazyframe/#narwhals.dataframe.LazyFrame.to_native","title":"to_native","text":"<pre><code>to_native() -&gt; LazyFrameT\n</code></pre> <p>Convert Narwhals LazyFrame to native one.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import duckdb\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; lf_native = duckdb.sql(\"SELECT * FROM VALUES (1, 2), (3, 4) df(a, b)\")\n&gt;&gt;&gt; nw.from_native(lf_native).to_native()\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   a   \u2502   b   \u2502\n\u2502 int32 \u2502 int32 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     1 \u2502     2 \u2502\n\u2502     3 \u2502     4 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/lazyframe/#narwhals.dataframe.LazyFrame.top_k","title":"top_k","text":"<pre><code>top_k(\n    k: int,\n    *,\n    by: str | Iterable[str],\n    reverse: bool | Sequence[bool] = False\n) -&gt; Self\n</code></pre> <p>Return the <code>k</code> largest rows.</p> <p>Non-null elements are always preferred over null elements, regardless of the value of reverse. The output is not guaranteed to be in any particular order, sort the outputs afterwards if you wish the output to be sorted.</p> <p>Parameters:</p> Name Type Description Default <code>k</code> <code>int</code> <p>Number of rows to return.</p> required <code>by</code> <code>str | Iterable[str]</code> <p>Column(s) used to determine the top rows. Accepts expression input. Strings are parsed as column names.</p> required <code>reverse</code> <code>bool | Sequence[bool]</code> <p>Consider the k smallest elements of the by column(s) (instead of the k largest). This can be specified per column by passing a sequence of booleans.</p> <code>False</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import duckdb\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = duckdb.sql(\n...     \"SELECT * FROM VALUES ('a', 2), ('b', 1), ('a', 1), ('b', 3), (NULL, 2), ('c', 1) df(a, b)\"\n... )\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.top_k(4, by=[\"b\", \"a\"])\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals LazyFrame |\n|-------------------|\n|\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510|\n|\u2502    a    \u2502   b   \u2502|\n|\u2502 varchar \u2502 int32 \u2502|\n|\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524|\n|\u2502 b       \u2502     3 \u2502|\n|\u2502 a       \u2502     2 \u2502|\n|\u2502 NULL    \u2502     2 \u2502|\n|\u2502 c       \u2502     1 \u2502|\n|\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/lazyframe/#narwhals.dataframe.LazyFrame.unique","title":"unique","text":"<pre><code>unique(\n    subset: str | list[str] | None = None,\n    *,\n    keep: UniqueKeepStrategy = \"any\",\n    order_by: str | Sequence[str] | None = None\n) -&gt; Self\n</code></pre> <p>Drop duplicate rows from this LazyFrame.</p> <p>Parameters:</p> Name Type Description Default <code>subset</code> <code>str | list[str] | None</code> <p>Column name(s) to consider when identifying duplicate rows.      If set to <code>None</code>, use all columns.</p> <code>None</code> <code>keep</code> <code>UniqueKeepStrategy</code> <p>{'any', 'none', 'first', 'last} Which of the duplicate rows to keep.</p> <ul> <li>'any': Does not give any guarantee of which row is kept.</li> <li>'none': Don't keep duplicate rows.</li> <li>'first': Keep the first row. Requires <code>order_by</code> to be specified.</li> <li>'last': Keep the last row. Requires <code>order_by</code> to be specified.</li> </ul> <code>'any'</code> <code>order_by</code> <code>str | Sequence[str] | None</code> <p>Column(s) to order by when computing the row index.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import duckdb\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; lf_native = duckdb.sql(\"SELECT * FROM VALUES (1, 3), (1, 4) df(a, b)\")\n&gt;&gt;&gt; nw.from_native(lf_native).unique(\"a\").sort(\"a\", descending=True)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals LazyFrame|\n|------------------|\n|\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 |\n|\u2502   a   \u2502   b   \u2502 |\n|\u2502 int32 \u2502 int32 \u2502 |\n|\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 |\n|\u2502     1 \u2502     3 \u2502 |\n|\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/lazyframe/#narwhals.dataframe.LazyFrame.unpivot","title":"unpivot","text":"<pre><code>unpivot(\n    on: str | list[str] | None = None,\n    *,\n    index: str | list[str] | None = None,\n    variable_name: str = \"variable\",\n    value_name: str = \"value\"\n) -&gt; Self\n</code></pre> <p>Unpivot a DataFrame from wide to long format.</p> <p>Optionally leaves identifiers set.</p> <p>This function is useful to massage a DataFrame into a format where one or more columns are identifier variables (index) while all other columns, considered measured variables (on), are \"unpivoted\" to the row axis leaving just two non-identifier columns, 'variable' and 'value'.</p> <p>Parameters:</p> Name Type Description Default <code>on</code> <code>str | list[str] | None</code> <p>Column(s) to use as values variables; if <code>on</code> is empty all columns that are not in <code>index</code> will be used.</p> <code>None</code> <code>index</code> <code>str | list[str] | None</code> <p>Column(s) to use as identifier variables.</p> <code>None</code> <code>variable_name</code> <code>str</code> <p>Name to give to the <code>variable</code> column. Defaults to \"variable\".</p> <code>'variable'</code> <code>value_name</code> <code>str</code> <p>Name to give to the <code>value</code> column. Defaults to \"value\".</p> <code>'value'</code> Notes <p>If you're coming from pandas, this is similar to <code>pandas.DataFrame.melt</code>, but with <code>index</code> replacing <code>id_vars</code> and <code>on</code> replacing <code>value_vars</code>. In other frameworks, you might know this operation as <code>pivot_longer</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import duckdb\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = duckdb.sql(\n...     \"SELECT * FROM VALUES ('x', 1, 2), ('y', 3, 4), ('z', 5, 6) df(a, b, c)\"\n... )\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.unpivot(on=[\"b\", \"c\"], index=\"a\").sort(\"a\", \"variable\").to_native()\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502    a    \u2502 variable \u2502 value \u2502\n\u2502 varchar \u2502 varchar  \u2502 int32 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 x       \u2502 b        \u2502     1 \u2502\n\u2502 x       \u2502 c        \u2502     2 \u2502\n\u2502 y       \u2502 b        \u2502     3 \u2502\n\u2502 y       \u2502 c        \u2502     4 \u2502\n\u2502 z       \u2502 b        \u2502     5 \u2502\n\u2502 z       \u2502 c        \u2502     6 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/lazyframe/#narwhals.dataframe.LazyFrame.with_columns","title":"with_columns","text":"<pre><code>with_columns(\n    *exprs: IntoExpr | Iterable[IntoExpr],\n    **named_exprs: IntoExpr\n) -&gt; Self\n</code></pre> <p>Add columns to this LazyFrame.</p> <p>Added columns will replace existing columns with the same name.</p> <p>Parameters:</p> Name Type Description Default <code>*exprs</code> <code>IntoExpr | Iterable[IntoExpr]</code> <p>Column(s) to add, specified as positional arguments.      Accepts expression input. Strings are parsed as column names, other      non-expression inputs are parsed as literals.</p> <code>()</code> <code>**named_exprs</code> <code>IntoExpr</code> <p>Additional columns to add, specified as keyword arguments.             The columns will be renamed to the keyword used.</p> <code>{}</code> Note <p>Creating a new LazyFrame using this method does not create a new copy of existing data.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import duckdb\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; lf_native = duckdb.sql(\"SELECT * FROM VALUES (1, 4.5), (3, 2.) df(a, b)\")\n&gt;&gt;&gt; nw.from_native(lf_native).with_columns(c=nw.col(\"a\") + 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|       Narwhals LazyFrame       |\n|--------------------------------|\n|\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510|\n|\u2502   a   \u2502      b       \u2502   c   \u2502|\n|\u2502 int32 \u2502 decimal(2,1) \u2502 int32 \u2502|\n|\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524|\n|\u2502     1 \u2502          4.5 \u2502     2 \u2502|\n|\u2502     3 \u2502          2.0 \u2502     4 \u2502|\n|\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/lazyframe/#narwhals.dataframe.LazyFrame.with_row_index","title":"with_row_index","text":"<pre><code>with_row_index(\n    name: str = \"index\", *, order_by: str | Sequence[str]\n) -&gt; Self\n</code></pre> <p>Insert column which enumerates rows.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the column as a string. The default is \"index\".</p> <code>'index'</code> <code>order_by</code> <code>str | Sequence[str]</code> <p>Column(s) to order by when computing the row index.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import duckdb\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; lf_native = duckdb.sql(\"SELECT * FROM VALUES (1, 5), (2, 4) df(a, b)\")\n&gt;&gt;&gt; nw.from_native(lf_native).with_row_index(order_by=\"a\").sort(\"a\").collect()\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|  pyarrow.Table   |\n|  index: int64    |\n|  a: int32        |\n|  b: int32        |\n|  ----            |\n|  index: [[0,1]]  |\n|  a: [[1,2]]      |\n|  b: [[5,4]]      |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; nw.from_native(lf_native).with_row_index(order_by=\"b\").sort(\"a\").collect()\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|  pyarrow.Table   |\n|  index: int64    |\n|  a: int32        |\n|  b: int32        |\n|  ----            |\n|  index: [[1,0]]  |\n|  a: [[1,2]]      |\n|  b: [[5,4]]      |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/narwhals/","title":"Top-level functions","text":"<p>Here are the top-level functions available in Narwhals.</p>"},{"location":"api-reference/narwhals/#narwhals.all","title":"all","text":"<pre><code>all() -&gt; Expr\n</code></pre> <p>Instantiate an expression representing all columns.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [1, 2], \"b\": [3.14, 0.123]})\n&gt;&gt;&gt; nw.from_native(df_native).select(nw.all() * 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|      a      b    |\n|   0  2  6.280    |\n|   1  4  0.246    |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.all_horizontal","title":"all_horizontal","text":"<pre><code>all_horizontal(\n    *exprs: IntoExpr | Iterable[IntoExpr],\n    ignore_nulls: bool\n) -&gt; Expr\n</code></pre> <p>Compute the bitwise AND horizontally across columns.</p> <p>Parameters:</p> Name Type Description Default <code>exprs</code> <code>IntoExpr | Iterable[IntoExpr]</code> <p>Name(s) of the columns to use in the aggregation function. Accepts expression input.</p> <code>()</code> <code>ignore_nulls</code> <code>bool</code> <p>Whether to ignore nulls:</p> <ul> <li>If <code>True</code>, null values are ignored. If there are no elements, the result   is <code>True</code>.</li> <li>If <code>False</code>, Kleene logic is followed. Note that this is not allowed for   pandas with classical NumPy dtypes when null values are present.</li> </ul> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; data = {\n...     \"a\": [False, False, True, True, False, None],\n...     \"b\": [False, True, True, None, None, None],\n... }\n&gt;&gt;&gt; df_native = pa.table(data)\n&gt;&gt;&gt; nw.from_native(df_native).select(\n...     \"a\", \"b\", all=nw.all_horizontal(\"a\", \"b\", ignore_nulls=False)\n... )\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|           Narwhals DataFrame            |\n|-----------------------------------------|\n|pyarrow.Table                            |\n|a: bool                                  |\n|b: bool                                  |\n|all: bool                                |\n|----                                     |\n|a: [[false,false,true,true,false,null]]  |\n|b: [[false,true,true,null,null,null]]    |\n|all: [[false,false,true,null,false,null]]|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.any_horizontal","title":"any_horizontal","text":"<pre><code>any_horizontal(\n    *exprs: IntoExpr | Iterable[IntoExpr],\n    ignore_nulls: bool\n) -&gt; Expr\n</code></pre> <p>Compute the bitwise OR horizontally across columns.</p> <p>Parameters:</p> Name Type Description Default <code>exprs</code> <code>IntoExpr | Iterable[IntoExpr]</code> <p>Name(s) of the columns to use in the aggregation function. Accepts expression input.</p> <code>()</code> <code>ignore_nulls</code> <code>bool</code> <p>Whether to ignore nulls:</p> <ul> <li>If <code>True</code>, null values are ignored. If there are no elements, the result   is <code>False</code>.</li> <li>If <code>False</code>, Kleene logic is followed. Note that this is not allowed for   pandas with classical NumPy dtypes when null values are present.</li> </ul> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; data = {\n...     \"a\": [False, False, True, True, False, None],\n...     \"b\": [False, True, True, None, None, None],\n... }\n&gt;&gt;&gt; df_native = pl.DataFrame(data)\n&gt;&gt;&gt; nw.from_native(df_native).select(\n...     \"a\", \"b\", any=nw.any_horizontal(\"a\", \"b\", ignore_nulls=False)\n... )\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|   Narwhals DataFrame    |\n|-------------------------|\n|shape: (6, 3)            |\n|\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510|\n|\u2502 a     \u2506 b     \u2506 any   \u2502|\n|\u2502 ---   \u2506 ---   \u2506 ---   \u2502|\n|\u2502 bool  \u2506 bool  \u2506 bool  \u2502|\n|\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561|\n|\u2502 false \u2506 false \u2506 false \u2502|\n|\u2502 false \u2506 true  \u2506 true  \u2502|\n|\u2502 true  \u2506 true  \u2506 true  \u2502|\n|\u2502 true  \u2506 null  \u2506 true  \u2502|\n|\u2502 false \u2506 null  \u2506 null  \u2502|\n|\u2502 null  \u2506 null  \u2506 null  \u2502|\n|\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.coalesce","title":"coalesce","text":"<pre><code>coalesce(\n    exprs: IntoExpr | Iterable[IntoExpr],\n    *more_exprs: IntoExpr | NonNestedLiteral\n) -&gt; Expr\n</code></pre> <p>Folds the columns from left to right, keeping the first non-null value.</p> <p>Parameters:</p> Name Type Description Default <code>exprs</code> <code>IntoExpr | Iterable[IntoExpr]</code> <p>Columns to coalesce, must be a str, nw.Expr, or nw.Series where strings are parsed as column names and both nw.Expr/nw.Series are passed through as-is. Scalar values must be wrapped in <code>nw.lit</code>.</p> required <code>*more_exprs</code> <code>IntoExpr | NonNestedLiteral</code> <p>Additional columns to coalesce, specified as positional arguments.</p> <code>()</code> <p>Raises:</p> Type Description <code>TypeError</code> <p>If any of the inputs are not a str, nw.Expr, or nw.Series.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = [\n...     (1, 5, None),\n...     (None, 6, None),\n...     (None, None, 9),\n...     (4, 8, 10),\n...     (None, None, None),\n... ]\n&gt;&gt;&gt; df = pl.DataFrame(data, schema=[\"a\", \"b\", \"c\"], orient=\"row\")\n&gt;&gt;&gt; nw.from_native(df).select(nw.coalesce(\"a\", \"b\", \"c\", nw.lit(-1)))\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|  shape: (5, 1)   |\n|  \u250c\u2500\u2500\u2500\u2500\u2500\u2510         |\n|  \u2502 a   \u2502         |\n|  \u2502 --- \u2502         |\n|  \u2502 i64 \u2502         |\n|  \u255e\u2550\u2550\u2550\u2550\u2550\u2561         |\n|  \u2502 1   \u2502         |\n|  \u2502 6   \u2502         |\n|  \u2502 9   \u2502         |\n|  \u2502 4   \u2502         |\n|  \u2502 -1  \u2502         |\n|  \u2514\u2500\u2500\u2500\u2500\u2500\u2518         |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.col","title":"col","text":"<pre><code>col(*names: str | Iterable[str]) -&gt; Expr\n</code></pre> <p>Creates an expression that references one or more columns by their name(s).</p> <p>Parameters:</p> Name Type Description Default <code>names</code> <code>str | Iterable[str]</code> <p>Name(s) of the columns to use.</p> <code>()</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; df_native = pl.DataFrame({\"a\": [1, 2], \"b\": [3, 4], \"c\": [\"x\", \"z\"]})\n&gt;&gt;&gt; nw.from_native(df_native).select(nw.col(\"a\", \"b\") * nw.col(\"b\"))\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|  shape: (2, 2)   |\n|  \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510   |\n|  \u2502 a   \u2506 b   \u2502   |\n|  \u2502 --- \u2506 --- \u2502   |\n|  \u2502 i64 \u2506 i64 \u2502   |\n|  \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561   |\n|  \u2502 3   \u2506 9   \u2502   |\n|  \u2502 8   \u2506 16  \u2502   |\n|  \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518   |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.concat","title":"concat","text":"<pre><code>concat(\n    items: Iterable[FrameT],\n    *,\n    how: ConcatMethod = \"vertical\"\n) -&gt; FrameT\n</code></pre> <p>Concatenate multiple DataFrames, LazyFrames into a single entity.</p> <p>Parameters:</p> Name Type Description Default <code>items</code> <code>Iterable[FrameT]</code> <p>DataFrames, LazyFrames to concatenate.</p> required <code>how</code> <code>ConcatMethod</code> <p>concatenating strategy</p> <ul> <li>vertical: Concatenate vertically. Column names must match.</li> <li>horizontal: Concatenate horizontally. If lengths don't match, then     missing rows are filled with null values. This is only supported     when all inputs are (eager) DataFrames.</li> <li>diagonal: Finds a union between the column schemas and fills missing column     values with null.</li> </ul> <code>'vertical'</code> <p>Raises:</p> Type Description <code>TypeError</code> <p>The items to concatenate should either all be eager, or all lazy</p> <p>Examples:</p> <p>Let's take an example of vertical concatenation:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n</code></pre> <p>Let's look at one case a for vertical concatenation (pandas backed):</p> <pre><code>&gt;&gt;&gt; df_pd_1 = nw.from_native(pd.DataFrame({\"a\": [1, 2, 3], \"b\": [4, 5, 6]}))\n&gt;&gt;&gt; df_pd_2 = nw.from_native(pd.DataFrame({\"a\": [5, 2], \"b\": [1, 4]}))\n&gt;&gt;&gt; nw.concat([df_pd_1, df_pd_2], how=\"vertical\")\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|        a  b      |\n|     0  1  4      |\n|     1  2  5      |\n|     2  3  6      |\n|     0  5  1      |\n|     1  2  4      |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Let's look at one case a for horizontal concatenation (polars backed):</p> <pre><code>&gt;&gt;&gt; df_pl_1 = nw.from_native(pl.DataFrame({\"a\": [1, 2, 3], \"b\": [4, 5, 6]}))\n&gt;&gt;&gt; df_pl_2 = nw.from_native(pl.DataFrame({\"c\": [5, 2], \"d\": [1, 4]}))\n&gt;&gt;&gt; nw.concat([df_pl_1, df_pl_2], how=\"horizontal\")\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|    Narwhals DataFrame     |\n|---------------------------|\n|shape: (3, 4)              |\n|\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510|\n|\u2502 a   \u2506 b   \u2506 c    \u2506 d    \u2502|\n|\u2502 --- \u2506 --- \u2506 ---  \u2506 ---  \u2502|\n|\u2502 i64 \u2506 i64 \u2506 i64  \u2506 i64  \u2502|\n|\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561|\n|\u2502 1   \u2506 4   \u2506 5    \u2506 1    \u2502|\n|\u2502 2   \u2506 5   \u2506 2    \u2506 4    \u2502|\n|\u2502 3   \u2506 6   \u2506 null \u2506 null \u2502|\n|\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Let's look at one case a for diagonal concatenation (pyarrow backed):</p> <pre><code>&gt;&gt;&gt; df_pa_1 = nw.from_native(pa.table({\"a\": [1, 2], \"b\": [3.5, 4.5]}))\n&gt;&gt;&gt; df_pa_2 = nw.from_native(pa.table({\"a\": [3, 4], \"z\": [\"x\", \"y\"]}))\n&gt;&gt;&gt; nw.concat([df_pa_1, df_pa_2], how=\"diagonal\")\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|    Narwhals DataFrame    |\n|--------------------------|\n|pyarrow.Table             |\n|a: int64                  |\n|b: double                 |\n|z: string                 |\n|----                      |\n|a: [[1,2],[3,4]]          |\n|b: [[3.5,4.5],[null,null]]|\n|z: [[null,null],[\"x\",\"y\"]]|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.concat_str","title":"concat_str","text":"<pre><code>concat_str(\n    exprs: IntoExpr | Iterable[IntoExpr],\n    *more_exprs: IntoExpr,\n    separator: str = \"\",\n    ignore_nulls: bool = False\n) -&gt; Expr\n</code></pre> <p>Horizontally concatenate columns into a single string column.</p> <p>Parameters:</p> Name Type Description Default <code>exprs</code> <code>IntoExpr | Iterable[IntoExpr]</code> <p>Columns to concatenate into a single string column. Accepts expression input. Strings are parsed as column names, other non-expression inputs are parsed as literals. Non-<code>String</code> columns are cast to <code>String</code>.</p> required <code>*more_exprs</code> <code>IntoExpr</code> <p>Additional columns to concatenate into a single string column, specified as positional arguments.</p> <code>()</code> <code>separator</code> <code>str</code> <p>String that will be used to separate the values of each column.</p> <code>''</code> <code>ignore_nulls</code> <code>bool</code> <p>Ignore null values (default is <code>False</code>). If set to <code>False</code>, null values will be propagated and if the row contains any null values, the output is null.</p> <code>False</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; data = {\n...     \"a\": [1, 2, 3],\n...     \"b\": [\"dogs\", \"cats\", None],\n...     \"c\": [\"play\", \"swim\", \"walk\"],\n... }\n&gt;&gt;&gt; df_native = pd.DataFrame(data)\n&gt;&gt;&gt; (\n...     nw.from_native(df_native).select(\n...         nw.concat_str(\n...             [nw.col(\"a\") * 2, nw.col(\"b\"), nw.col(\"c\")], separator=\" \"\n...         ).alias(\"full_sentence\")\n...     )\n... )\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|   full_sentence  |\n| 0   2 dogs play  |\n| 1   4 cats swim  |\n| 2          None  |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.exclude","title":"exclude","text":"<pre><code>exclude(*names: str | Iterable[str]) -&gt; Expr\n</code></pre> <p>Creates an expression that excludes columns by their name(s).</p> <p>Parameters:</p> Name Type Description Default <code>names</code> <code>str | Iterable[str]</code> <p>Name(s) of the columns to exclude.</p> <code>()</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; df_native = pl.DataFrame({\"a\": [1, 2], \"b\": [3, 4], \"c\": [\"x\", \"z\"]})\n&gt;&gt;&gt; nw.from_native(df_native).select(nw.exclude(\"c\", \"a\"))\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|  shape: (2, 1)   |\n|  \u250c\u2500\u2500\u2500\u2500\u2500\u2510         |\n|  \u2502 b   \u2502         |\n|  \u2502 --- \u2502         |\n|  \u2502 i64 \u2502         |\n|  \u255e\u2550\u2550\u2550\u2550\u2550\u2561         |\n|  \u2502 3   \u2502         |\n|  \u2502 4   \u2502         |\n|  \u2514\u2500\u2500\u2500\u2500\u2500\u2518         |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.format","title":"format","text":"<pre><code>format(f_string: str, *args: IntoExpr) -&gt; Expr\n</code></pre> <p>Format expressions as a string.</p> <p>Parameters:</p> Name Type Description Default <code>f_string</code> <code>str</code> <p>A string that with placeholders.</p> required <code>args</code> <code>IntoExpr</code> <p>Expression(s) that fill the placeholders.</p> <code>()</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import duckdb\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; rel = duckdb.sql(\"select * from values ('a', 1), ('b', 2), ('c', 3) df(a, b)\")\n&gt;&gt;&gt; df = nw.from_native(rel)\n&gt;&gt;&gt; df.with_columns(formatted=nw.format(\"foo_{}_bar_{}\", nw.col(\"a\"), \"b\"))\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|       Narwhals LazyFrame        |\n|---------------------------------|\n|\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510|\n|\u2502    a    \u2502   b   \u2502  formatted  \u2502|\n|\u2502 varchar \u2502 int32 \u2502   varchar   \u2502|\n|\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524|\n|\u2502 a       \u2502     1 \u2502 foo_a_bar_1 \u2502|\n|\u2502 b       \u2502     2 \u2502 foo_b_bar_2 \u2502|\n|\u2502 c       \u2502     3 \u2502 foo_c_bar_3 \u2502|\n|\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.from_arrow","title":"from_arrow","text":"<pre><code>from_arrow(\n    native_frame: IntoArrowTable,\n    *,\n    backend: IntoBackend[EagerAllowed]\n) -&gt; DataFrame[Any]\n</code></pre> <p>Construct a DataFrame from an object which supports the PyCapsule Interface.</p> <p>Parameters:</p> Name Type Description Default <code>native_frame</code> <code>IntoArrowTable</code> <p>Object which implements <code>__arrow_c_stream__</code>.</p> required <code>backend</code> <code>IntoBackend[EagerAllowed]</code> <p>specifies which eager backend instantiate to.</p> <p><code>backend</code> can be specified in various ways</p> <ul> <li>As <code>Implementation.&lt;BACKEND&gt;</code> with <code>BACKEND</code> being <code>PANDAS</code>, <code>PYARROW</code>,     <code>POLARS</code>, <code>MODIN</code> or <code>CUDF</code>.</li> <li>As a string: <code>\"pandas\"</code>, <code>\"pyarrow\"</code>, <code>\"polars\"</code>, <code>\"modin\"</code> or <code>\"cudf\"</code>.</li> <li>Directly as a module <code>pandas</code>, <code>pyarrow</code>, <code>polars</code>, <code>modin</code> or <code>cudf</code>.</li> </ul> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [1, 2], \"b\": [4.2, 5.1]})\n&gt;&gt;&gt; nw.from_arrow(df_native, backend=\"polars\")\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|  shape: (2, 2)   |\n|  \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510   |\n|  \u2502 a   \u2506 b   \u2502   |\n|  \u2502 --- \u2506 --- \u2502   |\n|  \u2502 i64 \u2506 f64 \u2502   |\n|  \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561   |\n|  \u2502 1   \u2506 4.2 \u2502   |\n|  \u2502 2   \u2506 5.1 \u2502   |\n|  \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518   |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.from_dict","title":"from_dict","text":"<pre><code>from_dict(\n    data: Mapping[str, Any],\n    schema: (\n        IntoSchema | Mapping[str, DType | None] | None\n    ) = None,\n    *,\n    backend: IntoBackend[EagerAllowed] | None = None,\n    native_namespace: ModuleType | None = None\n) -&gt; DataFrame[Any]\n</code></pre> <p>Instantiate DataFrame from dictionary.</p> <p>Indexes (if present, for pandas-like backends) are aligned following the left-hand-rule.</p> Notes <p>For pandas-like dataframes, conversion to schema is applied after dataframe creation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Mapping[str, Any]</code> <p>Dictionary to create DataFrame from.</p> required <code>schema</code> <code>IntoSchema | Mapping[str, DType | None] | None</code> <p>The DataFrame schema as Schema or dict of {name: type}. If not specified, the schema will be inferred by the native library. If any <code>dtype</code> is <code>None</code>, the data type for that column will be inferred by the native library.</p> <code>None</code> <code>backend</code> <code>IntoBackend[EagerAllowed] | None</code> <p>specifies which eager backend instantiate to. Only necessary if inputs are not Narwhals Series.</p> <p><code>backend</code> can be specified in various ways</p> <ul> <li>As <code>Implementation.&lt;BACKEND&gt;</code> with <code>BACKEND</code> being <code>PANDAS</code>, <code>PYARROW</code>,     <code>POLARS</code>, <code>MODIN</code> or <code>CUDF</code>.</li> <li>As a string: <code>\"pandas\"</code>, <code>\"pyarrow\"</code>, <code>\"polars\"</code>, <code>\"modin\"</code> or <code>\"cudf\"</code>.</li> <li>Directly as a module <code>pandas</code>, <code>pyarrow</code>, <code>polars</code>, <code>modin</code> or <code>cudf</code>.</li> </ul> <code>None</code> <code>native_namespace</code> <code>ModuleType | None</code> <p>deprecated, same as <code>backend</code>.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = {\"c\": [5, 2], \"d\": [1, 4]}\n&gt;&gt;&gt; nw.from_dict(data, backend=\"pandas\")\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|        c  d      |\n|     0  5  1      |\n|     1  2  4      |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.from_dicts","title":"from_dicts","text":"<pre><code>from_dicts(\n    data: Sequence[Mapping[str, Any]],\n    schema: (\n        IntoSchema | Mapping[str, DType | None] | None\n    ) = None,\n    *,\n    backend: IntoBackend[EagerAllowed]\n) -&gt; DataFrame[Any]\n</code></pre> <p>Instantiate DataFrame from a sequence of dictionaries representing rows.</p> Notes <p>For pandas-like dataframes, conversion to schema is applied after dataframe creation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Sequence[Mapping[str, Any]]</code> <p>Sequence with dictionaries mapping column name to value.</p> required <code>schema</code> <code>IntoSchema | Mapping[str, DType | None] | None</code> <p>The DataFrame schema as Schema or dict of {name: type}. If not specified, the schema will be inferred by the native library. If any <code>dtype</code> is <code>None</code>, the data type for that column will be inferred by the native library.</p> <code>None</code> <code>backend</code> <code>IntoBackend[EagerAllowed]</code> <p>Specifies which eager backend instantiate to.</p> <p><code>backend</code> can be specified in various ways</p> <ul> <li>As <code>Implementation.&lt;BACKEND&gt;</code> with <code>BACKEND</code> being <code>PANDAS</code>, <code>PYARROW</code>,     <code>POLARS</code>, <code>MODIN</code> or <code>CUDF</code>.</li> <li>As a string: <code>\"pandas\"</code>, <code>\"pyarrow\"</code>, <code>\"polars\"</code>, <code>\"modin\"</code> or <code>\"cudf\"</code>.</li> <li>Directly as a module <code>pandas</code>, <code>pyarrow</code>, <code>polars</code>, <code>modin</code> or <code>cudf</code>.</li> </ul> required Tip <p>If you expect non-uniform keys in <code>data</code>, consider passing <code>schema</code> for more consistent results, as inference varies between backends:</p> <ul> <li>pandas uses all rows</li> <li>polars uses the first 100 rows</li> <li>pyarrow uses only the first row</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = [\n...     {\"item\": \"apple\", \"weight\": 80, \"price\": 0.60},\n...     {\"item\": \"egg\", \"weight\": 55, \"price\": 0.40},\n... ]\n&gt;&gt;&gt; nw.DataFrame.from_dicts(data, backend=\"polars\")\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|    Narwhals DataFrame    |\n|--------------------------|\n|shape: (2, 3)             |\n|\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510|\n|\u2502 item  \u2506 weight \u2506 price \u2502|\n|\u2502 ---   \u2506 ---    \u2506 ---   \u2502|\n|\u2502 str   \u2506 i64    \u2506 f64   \u2502|\n|\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561|\n|\u2502 apple \u2506 80     \u2506 0.6   \u2502|\n|\u2502 egg   \u2506 55     \u2506 0.4   \u2502|\n|\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.from_native","title":"from_native","text":"<pre><code>from_native(native_object: SeriesT, **kwds: Any) -&gt; SeriesT\n</code></pre><pre><code>from_native(\n    native_object: DataFrameT, **kwds: Any\n) -&gt; DataFrameT\n</code></pre><pre><code>from_native(\n    native_object: LazyFrameT, **kwds: Any\n) -&gt; LazyFrameT\n</code></pre><pre><code>from_native(\n    native_object: IntoDataFrameT | IntoSeriesT,\n    *,\n    pass_through: Literal[True],\n    eager_only: Literal[True],\n    series_only: Literal[False] = ...,\n    allow_series: Literal[True]\n) -&gt; DataFrame[IntoDataFrameT] | Series[IntoSeriesT]\n</code></pre><pre><code>from_native(\n    native_object: IntoDataFrameT,\n    *,\n    pass_through: Literal[True],\n    eager_only: Literal[False] = ...,\n    series_only: Literal[False] = ...,\n    allow_series: None = ...\n) -&gt; DataFrame[IntoDataFrameT]\n</code></pre><pre><code>from_native(\n    native_object: T,\n    *,\n    pass_through: Literal[True],\n    eager_only: Literal[False] = ...,\n    series_only: Literal[False] = ...,\n    allow_series: None = ...\n) -&gt; T\n</code></pre><pre><code>from_native(\n    native_object: IntoDataFrameT,\n    *,\n    pass_through: Literal[True],\n    eager_only: Literal[True],\n    series_only: Literal[False] = ...,\n    allow_series: None = ...\n) -&gt; DataFrame[IntoDataFrameT]\n</code></pre><pre><code>from_native(\n    native_object: T,\n    *,\n    pass_through: Literal[True],\n    eager_only: Literal[True],\n    series_only: Literal[False] = ...,\n    allow_series: None = ...\n) -&gt; T\n</code></pre><pre><code>from_native(\n    native_object: (\n        IntoDataFrameT | IntoLazyFrameT | IntoSeriesT\n    ),\n    *,\n    pass_through: Literal[True],\n    eager_only: Literal[False] = ...,\n    series_only: Literal[False] = ...,\n    allow_series: Literal[True]\n) -&gt; (\n    DataFrame[IntoDataFrameT]\n    | LazyFrame[IntoLazyFrameT]\n    | Series[IntoSeriesT]\n)\n</code></pre><pre><code>from_native(\n    native_object: IntoSeriesT,\n    *,\n    pass_through: Literal[True],\n    eager_only: Literal[False] = ...,\n    series_only: Literal[True],\n    allow_series: None = ...\n) -&gt; Series[IntoSeriesT]\n</code></pre><pre><code>from_native(\n    native_object: IntoLazyFrameT,\n    *,\n    pass_through: Literal[False] = ...,\n    eager_only: Literal[False] = ...,\n    series_only: Literal[False] = ...,\n    allow_series: None = ...\n) -&gt; LazyFrame[IntoLazyFrameT]\n</code></pre><pre><code>from_native(\n    native_object: IntoDataFrameT,\n    *,\n    pass_through: Literal[False] = ...,\n    eager_only: Literal[False] = ...,\n    series_only: Literal[False] = ...,\n    allow_series: None = ...\n) -&gt; DataFrame[IntoDataFrameT]\n</code></pre><pre><code>from_native(\n    native_object: IntoDataFrameT,\n    *,\n    pass_through: Literal[False] = ...,\n    eager_only: Literal[True],\n    series_only: Literal[False] = ...,\n    allow_series: None = ...\n) -&gt; DataFrame[IntoDataFrameT]\n</code></pre><pre><code>from_native(\n    native_object: IntoFrame | IntoSeries,\n    *,\n    pass_through: Literal[False] = ...,\n    eager_only: Literal[False] = ...,\n    series_only: Literal[False] = ...,\n    allow_series: Literal[True]\n) -&gt; DataFrame[Any] | LazyFrame[Any] | Series[Any]\n</code></pre><pre><code>from_native(\n    native_object: IntoSeriesT,\n    *,\n    pass_through: Literal[False] = ...,\n    eager_only: Literal[False] = ...,\n    series_only: Literal[True],\n    allow_series: None = ...\n) -&gt; Series[IntoSeriesT]\n</code></pre><pre><code>from_native(\n    native_object: Any,\n    *,\n    pass_through: bool,\n    eager_only: bool,\n    series_only: bool,\n    allow_series: bool | None\n) -&gt; Any\n</code></pre> <pre><code>from_native(\n    native_object: (\n        IntoLazyFrameT\n        | IntoDataFrameT\n        | IntoSeriesT\n        | IntoFrame\n        | IntoSeries\n        | T\n    ),\n    *,\n    pass_through: bool = False,\n    eager_only: bool = False,\n    series_only: bool = False,\n    allow_series: bool | None = None,\n    **kwds: Any\n) -&gt; (\n    LazyFrame[IntoLazyFrameT]\n    | DataFrame[IntoDataFrameT]\n    | Series[IntoSeriesT]\n    | T\n)\n</code></pre> <p>Convert <code>native_object</code> to Narwhals Dataframe, Lazyframe, or Series.</p> <p>Parameters:</p> Name Type Description Default <code>native_object</code> <code>IntoLazyFrameT | IntoDataFrameT | IntoSeriesT | IntoFrame | IntoSeries | T</code> <p>Raw object from user. Depending on the other arguments, input object can be</p> <ul> <li>a Dataframe / Lazyframe / Series supported by Narwhals (pandas, Polars, PyArrow, ...)</li> <li>an object which implements <code>__narwhals_dataframe__</code>, <code>__narwhals_lazyframe__</code>,   or <code>__narwhals_series__</code></li> </ul> required <code>pass_through</code> <code>bool</code> <p>Determine what happens if the object can't be converted to Narwhals</p> <ul> <li><code>False</code> (default): raise an error</li> <li><code>True</code>: pass object through as-is</li> </ul> <code>False</code> <code>eager_only</code> <code>bool</code> <p>Whether to only allow eager objects</p> <ul> <li><code>False</code> (default): don't require <code>native_object</code> to be eager</li> <li><code>True</code>: only convert to Narwhals if <code>native_object</code> is eager</li> </ul> <code>False</code> <code>series_only</code> <code>bool</code> <p>Whether to only allow Series</p> <ul> <li><code>False</code> (default): don't require <code>native_object</code> to be a Series</li> <li><code>True</code>: only convert to Narwhals if <code>native_object</code> is a Series</li> </ul> <code>False</code> <code>allow_series</code> <code>bool | None</code> <p>Whether to allow Series (default is only Dataframe / Lazyframe)</p> <ul> <li><code>False</code> or <code>None</code> (default): don't convert to Narwhals if <code>native_object</code> is a Series</li> <li><code>True</code>: allow <code>native_object</code> to be a Series</li> </ul> <code>None</code> <p>Returns:</p> Type Description <code>LazyFrame[IntoLazyFrameT] | DataFrame[IntoDataFrameT] | Series[IntoSeriesT] | T</code> <p>DataFrame, LazyFrame, Series, or original object, depending on which combination of parameters was passed.</p>"},{"location":"api-reference/narwhals/#narwhals.from_numpy","title":"from_numpy","text":"<pre><code>from_numpy(\n    data: _2DArray,\n    schema: IntoSchema | Sequence[str] | None = None,\n    *,\n    backend: IntoBackend[EagerAllowed]\n) -&gt; DataFrame[Any]\n</code></pre> <p>Construct a DataFrame from a NumPy ndarray.</p> Notes <p>Only row orientation is currently supported.</p> <p>For pandas-like dataframes, conversion to schema is applied after dataframe creation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>_2DArray</code> <p>Two-dimensional data represented as a NumPy ndarray.</p> required <code>schema</code> <code>IntoSchema | Sequence[str] | None</code> <p>The DataFrame schema as Schema, dict of {name: type}, or a sequence of str.</p> <code>None</code> <code>backend</code> <code>IntoBackend[EagerAllowed]</code> <p>specifies which eager backend instantiate to.</p> <p><code>backend</code> can be specified in various ways</p> <ul> <li>As <code>Implementation.&lt;BACKEND&gt;</code> with <code>BACKEND</code> being <code>PANDAS</code>, <code>PYARROW</code>,     <code>POLARS</code>, <code>MODIN</code> or <code>CUDF</code>.</li> <li>As a string: <code>\"pandas\"</code>, <code>\"pyarrow\"</code>, <code>\"polars\"</code>, <code>\"modin\"</code> or <code>\"cudf\"</code>.</li> <li>Directly as a module <code>pandas</code>, <code>pyarrow</code>, <code>polars</code>, <code>modin</code> or <code>cudf</code>.</li> </ul> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; arr = np.array([[5, 2, 1], [1, 4, 3]])\n&gt;&gt;&gt; schema = {\"c\": nw.Int16(), \"d\": nw.Float32(), \"e\": nw.Int8()}\n&gt;&gt;&gt; nw.from_numpy(arr, schema=schema, backend=\"pyarrow\")\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|  pyarrow.Table   |\n|  c: int16        |\n|  d: float        |\n|  e: int8         |\n|  ----            |\n|  c: [[5,1]]      |\n|  d: [[2,4]]      |\n|  e: [[1,3]]      |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.generate_temporary_column_name","title":"generate_temporary_column_name","text":"<pre><code>generate_temporary_column_name(\n    n_bytes: int,\n    columns: Container[str],\n    prefix: str = \"nw\",\n) -&gt; str\n</code></pre> <p>Generates a unique column name that is not present in the given list of columns.</p> <p>It relies on python secrets token_hex function to return a string nbytes random bytes.</p> <p>Parameters:</p> Name Type Description Default <code>n_bytes</code> <code>int</code> <p>The number of bytes to generate for the token.</p> required <code>columns</code> <code>Container[str]</code> <p>The list of columns to check for uniqueness.</p> required <code>prefix</code> <code>str</code> <p>prefix with which the temporary column name should start with.</p> <code>'nw'</code> <p>Returns:</p> Type Description <code>str</code> <p>A unique token that is not present in the given list of columns.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If a unique token cannot be generated after 100 attempts.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; columns = [\"abc\", \"xyz\"]\n&gt;&gt;&gt; nw.generate_temporary_column_name(n_bytes=8, columns=columns) not in columns\nTrue\n&gt;&gt;&gt; temp_name = nw.generate_temporary_column_name(\n...     n_bytes=8, columns=columns, prefix=\"foo\"\n... )\n&gt;&gt;&gt; temp_name not in columns and temp_name.startswith(\"foo\")\nTrue\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.get_native_namespace","title":"get_native_namespace","text":"<pre><code>get_native_namespace(\n    *obj: Frame | Series[Any] | IntoFrame | IntoSeries,\n) -&gt; Any\n</code></pre> <p>Get native namespace from object.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Frame | Series[Any] | IntoFrame | IntoSeries</code> <p>Dataframe, Lazyframe, or Series. Multiple objects can be passed positionally, in which case they must all have the same native namespace (else an error is raised).</p> <code>()</code> <p>Returns:</p> Type Description <code>Any</code> <p>Native module.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df = nw.from_native(pd.DataFrame({\"a\": [1, 2, 3]}))\n&gt;&gt;&gt; nw.get_native_namespace(df)\n&lt;module 'pandas'...&gt;\n&gt;&gt;&gt; df = nw.from_native(pl.DataFrame({\"a\": [1, 2, 3]}))\n&gt;&gt;&gt; nw.get_native_namespace(df)\n&lt;module 'polars'...&gt;\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.is_ordered_categorical","title":"is_ordered_categorical","text":"<pre><code>is_ordered_categorical(series: Series[Any]) -&gt; bool\n</code></pre> <p>Return whether indices of categories are semantically meaningful.</p> <p>This is a convenience function to accessing what would otherwise be the <code>is_ordered</code> property from the DataFrame Interchange Protocol, see https://data-apis.org/dataframe-protocol/latest/API.html.</p> <ul> <li>For Polars:</li> <li>Enums are always ordered.</li> <li>Categoricals are ordered if <code>dtype.ordering == \"physical\"</code>.</li> <li>For pandas-like APIs:</li> <li>Categoricals are ordered if <code>dtype.cat.ordered == True</code>.</li> <li>For PyArrow table:</li> <li>Categoricals are ordered if <code>dtype.type.ordered == True</code>.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>series</code> <code>Series[Any]</code> <p>Input Series.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; data = [\"x\", \"y\"]\n&gt;&gt;&gt; s_pd = pd.Series(data, dtype=pd.CategoricalDtype(ordered=True))\n&gt;&gt;&gt; s_pl = pl.Series(data, dtype=pl.Categorical(ordering=\"lexical\"))\n</code></pre> <p>Let's define a library-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s):\n...     return nw.is_ordered_categorical(s)\n</code></pre> <p>Then, we can pass any supported library to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\nTrue\n&gt;&gt;&gt; func(s_pl)\nFalse\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.len","title":"len","text":"<pre><code>len() -&gt; Expr\n</code></pre> <p>Return the number of rows.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; df_native = pl.DataFrame({\"a\": [1, 2], \"b\": [5, None]})\n&gt;&gt;&gt; nw.from_native(df_native).select(nw.len())\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|  shape: (1, 1)   |\n|  \u250c\u2500\u2500\u2500\u2500\u2500\u2510         |\n|  \u2502 len \u2502         |\n|  \u2502 --- \u2502         |\n|  \u2502 u32 \u2502         |\n|  \u255e\u2550\u2550\u2550\u2550\u2550\u2561         |\n|  \u2502 2   \u2502         |\n|  \u2514\u2500\u2500\u2500\u2500\u2500\u2518         |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.lit","title":"lit","text":"<pre><code>lit(\n    value: NonNestedLiteral, dtype: IntoDType | None = None\n) -&gt; Expr\n</code></pre> <p>Return an expression representing a literal value.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>NonNestedLiteral</code> <p>The value to use as literal.</p> required <code>dtype</code> <code>IntoDType | None</code> <p>The data type of the literal value. If not provided, the data type will be inferred by the native library.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [1, 2]})\n&gt;&gt;&gt; nw.from_native(df_native).with_columns(nw.lit(3))\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|     a  literal   |\n|  0  1        3   |\n|  1  2        3   |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.max","title":"max","text":"<pre><code>max(*columns: str) -&gt; Expr\n</code></pre> <p>Return the maximum value.</p> Note <p>Syntactic sugar for <code>nw.col(columns).max()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>str</code> <p>Name(s) of the columns to use in the aggregation function.</p> <code>()</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [1, 2], \"b\": [5, 10]})\n&gt;&gt;&gt; nw.from_native(df_native).select(nw.max(\"a\", \"b\"))\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|        a   b     |\n|     0  2  10     |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.max_horizontal","title":"max_horizontal","text":"<pre><code>max_horizontal(\n    *exprs: IntoExpr | Iterable[IntoExpr],\n) -&gt; Expr\n</code></pre> <p>Get the maximum value horizontally across columns.</p> Notes <p>We support <code>max_horizontal</code> over numeric columns only.</p> <p>Parameters:</p> Name Type Description Default <code>exprs</code> <code>IntoExpr | Iterable[IntoExpr]</code> <p>Name(s) of the columns to use in the aggregation function. Accepts expression input.</p> <code>()</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; df_native = pl.DataFrame({\"a\": [1, 8, 3], \"b\": [4, 5, None]})\n&gt;&gt;&gt; nw.from_native(df_native).with_columns(h_max=nw.max_horizontal(\"a\", \"b\"))\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|  Narwhals DataFrame  |\n|----------------------|\n|shape: (3, 3)         |\n|\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510|\n|\u2502 a   \u2506 b    \u2506 h_max \u2502|\n|\u2502 --- \u2506 ---  \u2506 ---   \u2502|\n|\u2502 i64 \u2506 i64  \u2506 i64   \u2502|\n|\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561|\n|\u2502 1   \u2506 4    \u2506 4     \u2502|\n|\u2502 8   \u2506 5    \u2506 8     \u2502|\n|\u2502 3   \u2506 null \u2506 3     \u2502|\n|\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.maybe_align_index","title":"maybe_align_index","text":"<pre><code>maybe_align_index(\n    lhs: FrameOrSeriesT,\n    rhs: Series[Any] | DataFrame[Any] | LazyFrame[Any],\n) -&gt; FrameOrSeriesT\n</code></pre> <p>Align <code>lhs</code> to the Index of <code>rhs</code>, if they're both pandas-like.</p> <p>Parameters:</p> Name Type Description Default <code>lhs</code> <code>FrameOrSeriesT</code> <p>Dataframe or Series.</p> required <code>rhs</code> <code>Series[Any] | DataFrame[Any] | LazyFrame[Any]</code> <p>Dataframe or Series to align with.</p> required Notes <p>This is only really intended for backwards-compatibility purposes, for example if your library already aligns indices for users. If you're designing a new library, we highly encourage you to not rely on the Index. For non-pandas-like inputs, this only checks that <code>lhs</code> and <code>rhs</code> are the same length.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_pd = pd.DataFrame({\"a\": [1, 2]}, index=[3, 4])\n&gt;&gt;&gt; s_pd = pd.Series([6, 7], index=[4, 3])\n&gt;&gt;&gt; df = nw.from_native(df_pd)\n&gt;&gt;&gt; s = nw.from_native(s_pd, series_only=True)\n&gt;&gt;&gt; nw.to_native(nw.maybe_align_index(df, s))\n   a\n4  2\n3  1\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.maybe_convert_dtypes","title":"maybe_convert_dtypes","text":"<pre><code>maybe_convert_dtypes(\n    obj: FrameOrSeriesT, *args: bool, **kwargs: bool | str\n) -&gt; FrameOrSeriesT\n</code></pre> <p>Convert columns or series to the best possible dtypes using dtypes supporting <code>pd.NA</code>, if df is pandas-like.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>FrameOrSeriesT</code> <p>DataFrame or Series.</p> required <code>*args</code> <code>bool</code> <p>Additional arguments which gets passed through.</p> <code>()</code> <code>**kwargs</code> <code>bool | str</code> <p>Additional arguments which gets passed through.</p> <code>{}</code> Notes <p>For non-pandas-like inputs, this is a no-op. Also, <code>args</code> and <code>kwargs</code> just get passed down to the underlying library as-is.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; df_pd = pd.DataFrame(\n...     {\n...         \"a\": pd.Series([1, 2, 3], dtype=np.dtype(\"int32\")),\n...         \"b\": pd.Series([True, False, np.nan], dtype=np.dtype(\"O\")),\n...     }\n... )\n&gt;&gt;&gt; df = nw.from_native(df_pd)\n&gt;&gt;&gt; nw.to_native(\n...     nw.maybe_convert_dtypes(df)\n... ).dtypes\na             Int32\nb           boolean\ndtype: object\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.maybe_get_index","title":"maybe_get_index","text":"<pre><code>maybe_get_index(\n    obj: DataFrame[Any] | LazyFrame[Any] | Series[Any],\n) -&gt; Any | None\n</code></pre> <p>Get the index of a DataFrame or a Series, if it's pandas-like.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>DataFrame[Any] | LazyFrame[Any] | Series[Any]</code> <p>Dataframe or Series.</p> required Notes <p>This is only really intended for backwards-compatibility purposes, for example if your library already aligns indices for users. If you're designing a new library, we highly encourage you to not rely on the Index. For non-pandas-like inputs, this returns <code>None</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_pd = pd.DataFrame({\"a\": [1, 2], \"b\": [4, 5]})\n&gt;&gt;&gt; df = nw.from_native(df_pd)\n&gt;&gt;&gt; nw.maybe_get_index(df)\nRangeIndex(start=0, stop=2, step=1)\n&gt;&gt;&gt; series_pd = pd.Series([1, 2])\n&gt;&gt;&gt; series = nw.from_native(series_pd, series_only=True)\n&gt;&gt;&gt; nw.maybe_get_index(series)\nRangeIndex(start=0, stop=2, step=1)\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.maybe_reset_index","title":"maybe_reset_index","text":"<pre><code>maybe_reset_index(obj: FrameOrSeriesT) -&gt; FrameOrSeriesT\n</code></pre> <p>Reset the index to the default integer index of a DataFrame or a Series, if it's pandas-like.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>FrameOrSeriesT</code> <p>Dataframe or Series.</p> required Notes <p>This is only really intended for backwards-compatibility purposes, for example if your library already resets the index for users. If you're designing a new library, we highly encourage you to not rely on the Index. For non-pandas-like inputs, this is a no-op.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_pd = pd.DataFrame({\"a\": [1, 2], \"b\": [4, 5]}, index=([6, 7]))\n&gt;&gt;&gt; df = nw.from_native(df_pd)\n&gt;&gt;&gt; nw.to_native(nw.maybe_reset_index(df))\n   a  b\n0  1  4\n1  2  5\n&gt;&gt;&gt; series_pd = pd.Series([1, 2])\n&gt;&gt;&gt; series = nw.from_native(series_pd, series_only=True)\n&gt;&gt;&gt; nw.maybe_get_index(series)\nRangeIndex(start=0, stop=2, step=1)\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.maybe_set_index","title":"maybe_set_index","text":"<pre><code>maybe_set_index(\n    obj: FrameOrSeriesT,\n    column_names: str | list[str] | None = None,\n    *,\n    index: (\n        Series[IntoSeriesT]\n        | list[Series[IntoSeriesT]]\n        | None\n    ) = None\n) -&gt; FrameOrSeriesT\n</code></pre> <p>Set the index of a DataFrame or a Series, if it's pandas-like.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>FrameOrSeriesT</code> <p>object for which maybe set the index (can be either a Narwhals <code>DataFrame</code> or <code>Series</code>).</p> required <code>column_names</code> <code>str | list[str] | None</code> <p>name or list of names of the columns to set as index. For dataframes, only one of <code>column_names</code> and <code>index</code> can be specified but not both. If <code>column_names</code> is passed and <code>df</code> is a Series, then a <code>ValueError</code> is raised.</p> <code>None</code> <code>index</code> <code>Series[IntoSeriesT] | list[Series[IntoSeriesT]] | None</code> <p>series or list of series to set as index.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If one of the following conditions happens</p> <ul> <li>none of <code>column_names</code> and <code>index</code> are provided</li> <li>both <code>column_names</code> and <code>index</code> are provided</li> <li><code>column_names</code> is provided and <code>df</code> is a Series</li> </ul> Notes <p>This is only really intended for backwards-compatibility purposes, for example if your library already aligns indices for users. If you're designing a new library, we highly encourage you to not rely on the Index.</p> <p>For non-pandas-like inputs, this is a no-op.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_pd = pd.DataFrame({\"a\": [1, 2], \"b\": [4, 5]})\n&gt;&gt;&gt; df = nw.from_native(df_pd)\n&gt;&gt;&gt; nw.to_native(nw.maybe_set_index(df, \"b\"))\n   a\nb\n4  1\n5  2\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.mean","title":"mean","text":"<pre><code>mean(*columns: str) -&gt; Expr\n</code></pre> <p>Get the mean value.</p> Note <p>Syntactic sugar for <code>nw.col(columns).mean()</code></p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>str</code> <p>Name(s) of the columns to use in the aggregation function</p> <code>()</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; df_native = pa.table({\"a\": [1, 8, 3], \"b\": [3.14, 6.28, 42.1]})\n&gt;&gt;&gt; nw.from_native(df_native).select(nw.mean(\"a\", \"b\"))\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|   Narwhals DataFrame    |\n|-------------------------|\n|pyarrow.Table            |\n|a: double                |\n|b: double                |\n|----                     |\n|a: [[4]]                 |\n|b: [[17.173333333333336]]|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.mean_horizontal","title":"mean_horizontal","text":"<pre><code>mean_horizontal(\n    *exprs: IntoExpr | Iterable[IntoExpr],\n) -&gt; Expr\n</code></pre> <p>Compute the mean of all values horizontally across columns.</p> <p>Parameters:</p> Name Type Description Default <code>exprs</code> <code>IntoExpr | Iterable[IntoExpr]</code> <p>Name(s) of the columns to use in the aggregation function. Accepts expression input.</p> <code>()</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; data = {\"a\": [1, 8, 3], \"b\": [4, 5, None], \"c\": [\"x\", \"y\", \"z\"]}\n&gt;&gt;&gt; df_native = pa.table(data)\n</code></pre> <p>We define a dataframe-agnostic function that computes the horizontal mean of \"a\" and \"b\" columns:</p> <pre><code>&gt;&gt;&gt; nw.from_native(df_native).select(nw.mean_horizontal(\"a\", \"b\"))\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n| pyarrow.Table    |\n| a: double        |\n| ----             |\n| a: [[2.5,6.5,3]] |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.median","title":"median","text":"<pre><code>median(*columns: str) -&gt; Expr\n</code></pre> <p>Get the median value.</p> Notes <ul> <li>Syntactic sugar for <code>nw.col(columns).median()</code></li> <li>Results might slightly differ across backends due to differences in the     underlying algorithms used to compute the median.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>str</code> <p>Name(s) of the columns to use in the aggregation function</p> <code>()</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; df_native = pl.DataFrame({\"a\": [4, 5, 2]})\n&gt;&gt;&gt; nw.from_native(df_native).select(nw.median(\"a\"))\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|  shape: (1, 1)   |\n|  \u250c\u2500\u2500\u2500\u2500\u2500\u2510         |\n|  \u2502 a   \u2502         |\n|  \u2502 --- \u2502         |\n|  \u2502 f64 \u2502         |\n|  \u255e\u2550\u2550\u2550\u2550\u2550\u2561         |\n|  \u2502 4.0 \u2502         |\n|  \u2514\u2500\u2500\u2500\u2500\u2500\u2518         |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.min","title":"min","text":"<pre><code>min(*columns: str) -&gt; Expr\n</code></pre> <p>Return the minimum value.</p> Note <p>Syntactic sugar for <code>nw.col(columns).min()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>str</code> <p>Name(s) of the columns to use in the aggregation function.</p> <code>()</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; df_native = pa.table({\"a\": [1, 2], \"b\": [5, 10]})\n&gt;&gt;&gt; nw.from_native(df_native).select(nw.min(\"a\", \"b\"))\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|  pyarrow.Table   |\n|  a: int64        |\n|  b: int64        |\n|  ----            |\n|  a: [[1]]        |\n|  b: [[5]]        |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.min_horizontal","title":"min_horizontal","text":"<pre><code>min_horizontal(\n    *exprs: IntoExpr | Iterable[IntoExpr],\n) -&gt; Expr\n</code></pre> <p>Get the minimum value horizontally across columns.</p> Notes <p>We support <code>min_horizontal</code> over numeric columns only.</p> <p>Parameters:</p> Name Type Description Default <code>exprs</code> <code>IntoExpr | Iterable[IntoExpr]</code> <p>Name(s) of the columns to use in the aggregation function. Accepts expression input.</p> <code>()</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; df_native = pa.table({\"a\": [1, 8, 3], \"b\": [4, 5, None]})\n&gt;&gt;&gt; nw.from_native(df_native).with_columns(h_min=nw.min_horizontal(\"a\", \"b\"))\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n| pyarrow.Table    |\n| a: int64         |\n| b: int64         |\n| h_min: int64     |\n| ----             |\n| a: [[1,8,3]]     |\n| b: [[4,5,null]]  |\n| h_min: [[1,5,3]] |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.narwhalify","title":"narwhalify","text":"<pre><code>narwhalify(\n    func: Callable[..., Any] | None = None,\n    *,\n    pass_through: bool = True,\n    eager_only: bool = False,\n    series_only: bool = False,\n    allow_series: bool | None = True\n) -&gt; Callable[..., Any]\n</code></pre> <p>Decorate function so it becomes dataframe-agnostic.</p> <p>This will try to convert any dataframe/series-like object into the Narwhals respective DataFrame/Series, while leaving the other parameters as they are. Similarly, if the output of the function is a Narwhals DataFrame or Series, it will be converted back to the original dataframe/series type, while if the output is another type it will be left as is. By setting <code>pass_through=False</code>, then every input and every output will be required to be a dataframe/series-like object.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[..., Any] | None</code> <p>Function to wrap in a <code>from_native</code>-<code>to_native</code> block.</p> <code>None</code> <code>pass_through</code> <code>bool</code> <p>Determine what happens if the object can't be converted to Narwhals</p> <ul> <li><code>False</code>: raise an error</li> <li><code>True</code> (default): pass object through as-is</li> </ul> <code>True</code> <code>eager_only</code> <code>bool</code> <p>Whether to only allow eager objects</p> <ul> <li><code>False</code> (default): don't require <code>native_object</code> to be eager</li> <li><code>True</code>: only convert to Narwhals if <code>native_object</code> is eager</li> </ul> <code>False</code> <code>series_only</code> <code>bool</code> <p>Whether to only allow Series</p> <ul> <li><code>False</code> (default): don't require <code>native_object</code> to be a Series</li> <li><code>True</code>: only convert to Narwhals if <code>native_object</code> is a Series</li> </ul> <code>False</code> <code>allow_series</code> <code>bool | None</code> <p>Whether to allow Series (default is only Dataframe / Lazyframe)</p> <ul> <li><code>False</code> or <code>None</code>: don't convert to Narwhals if <code>native_object</code> is a Series</li> <li><code>True</code> (default): allow <code>native_object</code> to be a Series</li> </ul> <code>True</code> <p>Returns:</p> Type Description <code>Callable[..., Any]</code> <p>Decorated function.</p> <p>Examples:</p> <p>Instead of writing</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; def agnostic_group_by_sum(df):\n...     df = nw.from_native(df, pass_through=True)\n...     df = df.group_by(\"a\").agg(nw.col(\"b\").sum())\n...     return nw.to_native(df)\n</code></pre> <p>you can just write</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def agnostic_group_by_sum(df):\n...     return df.group_by(\"a\").agg(nw.col(\"b\").sum())\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.new_series","title":"new_series","text":"<pre><code>new_series(\n    name: str,\n    values: Any,\n    dtype: IntoDType | None = None,\n    *,\n    backend: IntoBackend[EagerAllowed]\n) -&gt; Series[Any]\n</code></pre> <p>Instantiate Narwhals Series from iterable (e.g. list or array).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of resulting Series.</p> required <code>values</code> <code>Any</code> <p>Values of make Series from.</p> required <code>dtype</code> <code>IntoDType | None</code> <p>(Narwhals) dtype. If not provided, the native library may auto-infer it from <code>values</code>.</p> <code>None</code> <code>backend</code> <code>IntoBackend[EagerAllowed]</code> <p>specifies which eager backend instantiate to.</p> <p><code>backend</code> can be specified in various ways</p> <ul> <li>As <code>Implementation.&lt;BACKEND&gt;</code> with <code>BACKEND</code> being <code>PANDAS</code>, <code>PYARROW</code>,     <code>POLARS</code>, <code>MODIN</code> or <code>CUDF</code>.</li> <li>As a string: <code>\"pandas\"</code>, <code>\"pyarrow\"</code>, <code>\"polars\"</code>, <code>\"modin\"</code> or <code>\"cudf\"</code>.</li> <li>Directly as a module <code>pandas</code>, <code>pyarrow</code>, <code>polars</code>, <code>modin</code> or <code>cudf</code>.</li> </ul> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; values = [4, 1, 2, 3]\n&gt;&gt;&gt; nw.new_series(name=\"a\", values=values, dtype=nw.Int32, backend=pd)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|   Narwhals Series   |\n|---------------------|\n|0    4               |\n|1    1               |\n|2    2               |\n|3    3               |\n|Name: a, dtype: int32|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.nth","title":"nth","text":"<pre><code>nth(*indices: int | Sequence[int]) -&gt; Expr\n</code></pre> <p>Creates an expression that references one or more columns by their index(es).</p> Notes <p><code>nth</code> is not supported for Polars version&lt;1.0.0. Please use <code>narwhals.col</code> instead.</p> <p>Parameters:</p> Name Type Description Default <code>indices</code> <code>int | Sequence[int]</code> <p>One or more indices representing the columns to retrieve.</p> <code>()</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; df_native = pa.table({\"a\": [1, 2], \"b\": [3, 4], \"c\": [0.123, 3.14]})\n&gt;&gt;&gt; nw.from_native(df_native).select(nw.nth(0, 2) * 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|pyarrow.Table     |\n|a: int64          |\n|c: double         |\n|----              |\n|a: [[2,4]]        |\n|c: [[0.246,6.28]] |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.read_csv","title":"read_csv","text":"<pre><code>read_csv(\n    source: FileSource,\n    *,\n    backend: IntoBackend[EagerAllowed],\n    **kwargs: Any\n) -&gt; DataFrame[Any]\n</code></pre> <p>Read a CSV file into a DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>FileSource</code> <p>Path to a file.</p> required <code>backend</code> <code>IntoBackend[EagerAllowed]</code> <p>The eager backend for DataFrame creation. <code>backend</code> can be specified in various ways</p> <ul> <li>As <code>Implementation.&lt;BACKEND&gt;</code> with <code>BACKEND</code> being <code>PANDAS</code>, <code>PYARROW</code>,     <code>POLARS</code>, <code>MODIN</code> or <code>CUDF</code>.</li> <li>As a string: <code>\"pandas\"</code>, <code>\"pyarrow\"</code>, <code>\"polars\"</code>, <code>\"modin\"</code> or <code>\"cudf\"</code>.</li> <li>Directly as a module <code>pandas</code>, <code>pyarrow</code>, <code>polars</code>, <code>modin</code> or <code>cudf</code>.</li> </ul> required <code>kwargs</code> <code>Any</code> <p>Extra keyword arguments which are passed to the native CSV reader. For example, you could use <code>nw.read_csv('file.csv', backend='pandas', engine='pyarrow')</code>.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; nw.read_csv(\"file.csv\", backend=\"pandas\")\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|        a   b     |\n|     0  1   4     |\n|     1  2   5     |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.read_parquet","title":"read_parquet","text":"<pre><code>read_parquet(\n    source: FileSource,\n    *,\n    backend: IntoBackend[EagerAllowed],\n    **kwargs: Any\n) -&gt; DataFrame[Any]\n</code></pre> <p>Read into a DataFrame from a parquet file.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>FileSource</code> <p>Path to a file.</p> required <code>backend</code> <code>IntoBackend[EagerAllowed]</code> <p>The eager backend for DataFrame creation. <code>backend</code> can be specified in various ways</p> <ul> <li>As <code>Implementation.&lt;BACKEND&gt;</code> with <code>BACKEND</code> being <code>PANDAS</code>, <code>PYARROW</code>,     <code>POLARS</code>, <code>MODIN</code> or <code>CUDF</code>.</li> <li>As a string: <code>\"pandas\"</code>, <code>\"pyarrow\"</code>, <code>\"polars\"</code>, <code>\"modin\"</code> or <code>\"cudf\"</code>.</li> <li>Directly as a module <code>pandas</code>, <code>pyarrow</code>, <code>polars</code>, <code>modin</code> or <code>cudf</code>.</li> </ul> required <code>kwargs</code> <code>Any</code> <p>Extra keyword arguments which are passed to the native parquet reader. For example, you could use <code>nw.read_parquet('file.parquet', backend=pd, engine='pyarrow')</code>.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; nw.read_parquet(\"file.parquet\", backend=\"pyarrow\")\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|pyarrow.Table     |\n|a: int64          |\n|c: double         |\n|----              |\n|a: [[1,2]]        |\n|c: [[0.2,0.1]]    |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.scan_csv","title":"scan_csv","text":"<pre><code>scan_csv(\n    source: FileSource,\n    *,\n    backend: IntoBackend[Backend],\n    **kwargs: Any\n) -&gt; LazyFrame[Any]\n</code></pre> <p>Lazily read from a CSV file.</p> <p>For the libraries that do not support lazy dataframes, the function reads a csv file eagerly and then converts the resulting dataframe to a lazyframe.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>FileSource</code> <p>Path to a file.</p> required <code>backend</code> <code>IntoBackend[Backend]</code> <p>The eager backend for DataFrame creation. <code>backend</code> can be specified in various ways</p> <ul> <li>As <code>Implementation.&lt;BACKEND&gt;</code> with <code>BACKEND</code> being <code>PANDAS</code>, <code>PYARROW</code>,     <code>POLARS</code>, <code>MODIN</code> or <code>CUDF</code>.</li> <li>As a string: <code>\"pandas\"</code>, <code>\"pyarrow\"</code>, <code>\"polars\"</code>, <code>\"modin\"</code> or <code>\"cudf\"</code>.</li> <li>Directly as a module <code>pandas</code>, <code>pyarrow</code>, <code>polars</code>, <code>modin</code> or <code>cudf</code>.</li> </ul> required <code>kwargs</code> <code>Any</code> <p>Extra keyword arguments which are passed to the native CSV reader. For example, you could use <code>nw.scan_csv('file.csv', backend=pd, engine='pyarrow')</code>.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import duckdb\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; nw.scan_csv(\"file.csv\", backend=\"duckdb\").to_native()\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502    a    \u2502   b   \u2502\n\u2502 varchar \u2502 int32 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 x       \u2502     1 \u2502\n\u2502 y       \u2502     2 \u2502\n\u2502 z       \u2502     3 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.scan_parquet","title":"scan_parquet","text":"<pre><code>scan_parquet(\n    source: FileSource,\n    *,\n    backend: IntoBackend[Backend],\n    **kwargs: Any\n) -&gt; LazyFrame[Any]\n</code></pre> <p>Lazily read from a parquet file.</p> <p>For the libraries that do not support lazy dataframes, the function reads a parquet file eagerly and then converts the resulting dataframe to a lazyframe.</p> Note <p>Spark like backends require a session object to be passed in <code>kwargs</code>.</p> <p>For instance:</p> <pre><code>import narwhals as nw\nfrom sqlframe.duckdb import DuckDBSession\n\nnw.scan_parquet(source, backend=\"sqlframe\", session=DuckDBSession())\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>FileSource</code> <p>Path to a file.</p> required <code>backend</code> <code>IntoBackend[Backend]</code> <p>The eager backend for DataFrame creation. <code>backend</code> can be specified in various ways</p> <ul> <li>As <code>Implementation.&lt;BACKEND&gt;</code> with <code>BACKEND</code> being <code>PANDAS</code>, <code>PYARROW</code>,     <code>POLARS</code>, <code>MODIN</code>, <code>CUDF</code>, <code>PYSPARK</code> or <code>SQLFRAME</code>.</li> <li>As a string: <code>\"pandas\"</code>, <code>\"pyarrow\"</code>, <code>\"polars\"</code>, <code>\"modin\"</code>, <code>\"cudf\"</code>,     <code>\"pyspark\"</code> or <code>\"sqlframe\"</code>.</li> <li>Directly as a module <code>pandas</code>, <code>pyarrow</code>, <code>polars</code>, <code>modin</code>, <code>cudf</code>,     <code>pyspark.sql</code> or <code>sqlframe</code>.</li> </ul> required <code>kwargs</code> <code>Any</code> <p>Extra keyword arguments which are passed to the native parquet reader. For example, you could use <code>nw.scan_parquet('file.parquet', backend=pd, engine='pyarrow')</code>.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import dask.dataframe as dd\n&gt;&gt;&gt; from sqlframe.duckdb import DuckDBSession\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; nw.scan_parquet(\"file.parquet\", backend=\"dask\").collect()\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|        a   b     |\n|     0  1   4     |\n|     1  2   5     |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; nw.scan_parquet(\n...     \"file.parquet\", backend=\"sqlframe\", session=DuckDBSession()\n... ).collect()\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|  pyarrow.Table   |\n|  a: int64        |\n|  b: int64        |\n|  ----            |\n|  a: [[1,2]]      |\n|  b: [[4,5]]      |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.show_versions","title":"show_versions","text":"<pre><code>show_versions() -&gt; None\n</code></pre> <p>Print useful debugging information.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from narwhals import show_versions\n&gt;&gt;&gt; show_versions()\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.sum","title":"sum","text":"<pre><code>sum(*columns: str) -&gt; Expr\n</code></pre> <p>Sum all values.</p> Note <p>Syntactic sugar for <code>nw.col(columns).sum()</code></p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>str</code> <p>Name(s) of the columns to use in the aggregation function</p> <code>()</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [1, 2], \"b\": [-1.4, 6.2]})\n&gt;&gt;&gt; nw.from_native(df_native).select(nw.sum(\"a\", \"b\"))\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|       a    b     |\n|    0  3  4.8     |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.sum_horizontal","title":"sum_horizontal","text":"<pre><code>sum_horizontal(\n    *exprs: IntoExpr | Iterable[IntoExpr],\n) -&gt; Expr\n</code></pre> <p>Sum all values horizontally across columns.</p> Warning <p>Unlike Polars, we support horizontal sum over numeric columns only.</p> <p>Parameters:</p> Name Type Description Default <code>exprs</code> <code>IntoExpr | Iterable[IntoExpr]</code> <p>Name(s) of the columns to use in the aggregation function. Accepts expression input.</p> <code>()</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; df_native = pl.DataFrame({\"a\": [1, 2, 3], \"b\": [5, 10, None]})\n&gt;&gt;&gt; nw.from_native(df_native).with_columns(sum=nw.sum_horizontal(\"a\", \"b\"))\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n| Narwhals DataFrame |\n|--------------------|\n|shape: (3, 3)       |\n|\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510|\n|\u2502 a   \u2506 b    \u2506 sum \u2502|\n|\u2502 --- \u2506 ---  \u2506 --- \u2502|\n|\u2502 i64 \u2506 i64  \u2506 i64 \u2502|\n|\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561|\n|\u2502 1   \u2506 5    \u2506 6   \u2502|\n|\u2502 2   \u2506 10   \u2506 12  \u2502|\n|\u2502 3   \u2506 null \u2506 3   \u2502|\n|\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.to_native","title":"to_native","text":"<pre><code>to_native(\n    narwhals_object: DataFrame[IntoDataFrameT],\n    *,\n    pass_through: Literal[False] = ...\n) -&gt; IntoDataFrameT\n</code></pre><pre><code>to_native(\n    narwhals_object: LazyFrame[IntoLazyFrameT],\n    *,\n    pass_through: Literal[False] = ...\n) -&gt; IntoLazyFrameT\n</code></pre><pre><code>to_native(\n    narwhals_object: Series[IntoSeriesT],\n    *,\n    pass_through: Literal[False] = ...\n) -&gt; IntoSeriesT\n</code></pre><pre><code>to_native(\n    narwhals_object: Any, *, pass_through: bool\n) -&gt; Any\n</code></pre> <pre><code>to_native(\n    narwhals_object: (\n        DataFrame[IntoDataFrameT]\n        | LazyFrame[IntoLazyFrameT]\n        | Series[IntoSeriesT]\n    ),\n    *,\n    pass_through: bool = False\n) -&gt; IntoDataFrameT | IntoLazyFrameT | IntoSeriesT | Any\n</code></pre> <p>Convert Narwhals object to native one.</p> <p>Parameters:</p> Name Type Description Default <code>narwhals_object</code> <code>DataFrame[IntoDataFrameT] | LazyFrame[IntoLazyFrameT] | Series[IntoSeriesT]</code> <p>Narwhals object.</p> required <code>pass_through</code> <code>bool</code> <p>Determine what happens if <code>narwhals_object</code> isn't a Narwhals class</p> <ul> <li><code>False</code> (default): raise an error</li> <li><code>True</code>: pass object through as-is</li> </ul> <code>False</code> <p>Returns:</p> Type Description <code>IntoDataFrameT | IntoLazyFrameT | IntoSeriesT | Any</code> <p>Object of class that user started with.</p>"},{"location":"api-reference/narwhals/#narwhals.to_py_scalar","title":"to_py_scalar","text":"<pre><code>to_py_scalar(scalar_like: Any) -&gt; Any\n</code></pre> <p>If a scalar is not Python native, converts it to Python native.</p> <p>Parameters:</p> Name Type Description Default <code>scalar_like</code> <code>Any</code> <p>Scalar-like value.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the object is not convertible to a scalar.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; df = nw.from_native(pd.DataFrame({\"a\": [1, 2, 3]}))\n&gt;&gt;&gt; nw.to_py_scalar(df[\"a\"].item(0))\n1\n&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; df = nw.from_native(pa.table({\"a\": [1, 2, 3]}))\n&gt;&gt;&gt; nw.to_py_scalar(df[\"a\"].item(0))\n1\n&gt;&gt;&gt; nw.to_py_scalar(1)\n1\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.when","title":"when","text":"<pre><code>when(*predicates: IntoExpr | Iterable[IntoExpr]) -&gt; When\n</code></pre> <p>Start a <code>when-then-otherwise</code> expression.</p> <p>Expression similar to an <code>if-else</code> statement in Python. Always initiated by a <code>pl.when(&lt;condition&gt;).then(&lt;value if condition&gt;)</code>, and optionally followed by a <code>.otherwise(&lt;value if condition is false&gt;)</code> can be appended at the end. If not appended, and the condition is not <code>True</code>, <code>None</code> will be returned.</p> Info <p>Chaining multiple <code>.when(&lt;condition&gt;).then(&lt;value&gt;)</code> statements is currently not supported. See Narwhals#668.</p> <p>Parameters:</p> Name Type Description Default <code>predicates</code> <code>IntoExpr | Iterable[IntoExpr]</code> <p>Condition(s) that must be met in order to apply the subsequent statement. Accepts one or more boolean expressions, which are implicitly combined with <code>&amp;</code>. String input is parsed as a column name.</p> <code>()</code> <p>Returns:</p> Type Description <code>When</code> <p>A \"when\" object, which <code>.then</code> can be called on.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; data = {\"a\": [1, 2, 3], \"b\": [5, 10, 15]}\n&gt;&gt;&gt; df_native = pd.DataFrame(data)\n&gt;&gt;&gt; nw.from_native(df_native).with_columns(\n...     nw.when(nw.col(\"a\") &lt; 3).then(5).otherwise(6).alias(\"a_when\")\n... )\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|    a   b  a_when |\n| 0  1   5       5 |\n| 1  2  10       5 |\n| 2  3  15       6 |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/schema/","title":"<code>narwhals.Schema</code>","text":"<p>Ordered mapping of column names to their data type.</p> <p>Parameters:</p> Name Type Description Default <code>schema</code> <code>Mapping[str, DType] | Iterable[tuple[str, DType]] | None</code> <p>The schema definition given by column names and their associated instantiated Narwhals data type. Accepts a mapping or an iterable of tuples.</p> <code>None</code> <p>Examples:</p> <p>Define a schema by passing instantiated data types.</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; schema = nw.Schema({\"foo\": nw.Int8(), \"bar\": nw.String()})\n&gt;&gt;&gt; schema\nSchema({'foo': Int8, 'bar': String})\n</code></pre> <p>Access the data type associated with a specific column name.</p> <pre><code>&gt;&gt;&gt; schema[\"foo\"]\nInt8\n</code></pre> <p>Access various schema properties using the <code>names</code>, <code>dtypes</code>, and <code>len</code> methods.</p> <pre><code>&gt;&gt;&gt; schema.names()\n['foo', 'bar']\n&gt;&gt;&gt; schema.dtypes()\n[Int8, String]\n&gt;&gt;&gt; schema.len()\n2\n</code></pre>"},{"location":"api-reference/schema/#narwhals.schema.Schema.dtypes","title":"dtypes","text":"<pre><code>dtypes() -&gt; list[DType]\n</code></pre> <p>Get the data types of the schema.</p>"},{"location":"api-reference/schema/#narwhals.schema.Schema.from_arrow","title":"from_arrow  <code>classmethod</code>","text":"<pre><code>from_arrow(schema: IntoArrowSchema) -&gt; Self\n</code></pre> <p>Construct a Schema from a pyarrow Schema.</p> <p>Parameters:</p> Name Type Description Default <code>schema</code> <code>IntoArrowSchema</code> <p>A pyarrow Schema or mapping of column names to pyarrow data types.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; mapping = {\n...     \"a\": pa.timestamp(\"us\", \"UTC\"),\n...     \"b\": pa.date32(),\n...     \"c\": pa.string(),\n...     \"d\": pa.uint8(),\n... }\n&gt;&gt;&gt; native = pa.schema(mapping)\n&gt;&gt;&gt;\n&gt;&gt;&gt; nw.Schema.from_arrow(native)\nSchema({'a': Datetime(time_unit='us', time_zone='UTC'), 'b': Date, 'c': String, 'd': UInt8})\n</code></pre> <pre><code>&gt;&gt;&gt; nw.Schema.from_arrow(mapping) == nw.Schema.from_arrow(native)\nTrue\n</code></pre>"},{"location":"api-reference/schema/#narwhals.schema.Schema.from_native","title":"from_native  <code>classmethod</code>","text":"<pre><code>from_native(\n    schema: (\n        IntoArrowSchema\n        | IntoPolarsSchema\n        | IntoPandasSchema\n    ),\n) -&gt; Self\n</code></pre> <p>Construct a Schema from a native schema representation.</p> <p>Parameters:</p> Name Type Description Default <code>schema</code> <code>IntoArrowSchema | IntoPolarsSchema | IntoPandasSchema</code> <p>A native schema object, or mapping of column names to instantiated native data types.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import datetime as dt\n&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; data = {\"a\": [1], \"b\": [\"a\"], \"c\": [dt.time(1, 2, 3)], \"d\": [[2]]}\n&gt;&gt;&gt; native = pa.table(data).schema\n&gt;&gt;&gt;\n&gt;&gt;&gt; nw.Schema.from_native(native)\nSchema({'a': Int64, 'b': String, 'c': Time, 'd': List(Int64)})\n</code></pre>"},{"location":"api-reference/schema/#narwhals.schema.Schema.from_pandas_like","title":"from_pandas_like  <code>classmethod</code>","text":"<pre><code>from_pandas_like(schema: IntoPandasSchema) -&gt; Self\n</code></pre> <p>Construct a Schema from a pandas-like schema representation.</p> <p>Parameters:</p> Name Type Description Default <code>schema</code> <code>IntoPandasSchema</code> <p>A mapping of column names to pandas-like data types.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; data = {\"a\": [1], \"b\": [\"a\"], \"c\": [False], \"d\": [9.2]}\n&gt;&gt;&gt; native = pd.DataFrame(data).convert_dtypes().dtypes.to_dict()\n&gt;&gt;&gt;\n&gt;&gt;&gt; nw.Schema.from_pandas_like(native)\nSchema({'a': Int64, 'b': String, 'c': Boolean, 'd': Float64})\n&gt;&gt;&gt;\n&gt;&gt;&gt; mapping = {\n...     \"a\": pd.DatetimeTZDtype(\"us\", \"UTC\"),\n...     \"b\": pd.ArrowDtype(pa.date32()),\n...     \"c\": pd.StringDtype(\"python\"),\n...     \"d\": np.dtype(\"uint8\"),\n... }\n&gt;&gt;&gt;\n&gt;&gt;&gt; nw.Schema.from_pandas_like(mapping)\nSchema({'a': Datetime(time_unit='us', time_zone='UTC'), 'b': Date, 'c': String, 'd': UInt8})\n</code></pre>"},{"location":"api-reference/schema/#narwhals.schema.Schema.from_polars","title":"from_polars  <code>classmethod</code>","text":"<pre><code>from_polars(schema: IntoPolarsSchema) -&gt; Self\n</code></pre> <p>Construct a Schema from a polars Schema.</p> <p>Parameters:</p> Name Type Description Default <code>schema</code> <code>IntoPolarsSchema</code> <p>A polars Schema or mapping of column names to instantiated polars data types.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; mapping = {\n...     \"a\": pl.Datetime(time_zone=\"UTC\"),\n...     \"b\": pl.Date(),\n...     \"c\": pl.String(),\n...     \"d\": pl.UInt8(),\n... }\n&gt;&gt;&gt; native = pl.Schema(mapping)\n&gt;&gt;&gt;\n&gt;&gt;&gt; nw.Schema.from_polars(native)\nSchema({'a': Datetime(time_unit='us', time_zone='UTC'), 'b': Date, 'c': String, 'd': UInt8})\n</code></pre> <pre><code>&gt;&gt;&gt; nw.Schema.from_polars(mapping) == nw.Schema.from_polars(native)\nTrue\n</code></pre>"},{"location":"api-reference/schema/#narwhals.schema.Schema.len","title":"len","text":"<pre><code>len() -&gt; int\n</code></pre> <p>Get the number of columns in the schema.</p>"},{"location":"api-reference/schema/#narwhals.schema.Schema.names","title":"names","text":"<pre><code>names() -&gt; list[str]\n</code></pre> <p>Get the column names of the schema.</p>"},{"location":"api-reference/schema/#narwhals.schema.Schema.to_arrow","title":"to_arrow","text":"<pre><code>to_arrow() -&gt; pa.Schema\n</code></pre> <p>Convert Schema to a pyarrow Schema.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; schema = nw.Schema({\"a\": nw.Int64(), \"b\": nw.Datetime(\"ns\")})\n&gt;&gt;&gt; schema.to_arrow()\na: int64\nb: timestamp[ns]\n</code></pre>"},{"location":"api-reference/schema/#narwhals.schema.Schema.to_pandas","title":"to_pandas","text":"<pre><code>to_pandas(\n    dtype_backend: (\n        DTypeBackend | Iterable[DTypeBackend]\n    ) = None,\n) -&gt; dict[str, Any]\n</code></pre> <p>Convert Schema to an ordered mapping of column names to their pandas data type.</p> <p>Parameters:</p> Name Type Description Default <code>dtype_backend</code> <code>DTypeBackend | Iterable[DTypeBackend]</code> <p>Backend(s) used for the native types. When providing more than one, the length of the iterable must be equal to the length of the schema.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; schema = nw.Schema({\"a\": nw.Int64(), \"b\": nw.Datetime(\"ns\")})\n&gt;&gt;&gt; schema.to_pandas()\n{'a': 'int64', 'b': 'datetime64[ns]'}\n</code></pre> <pre><code>&gt;&gt;&gt; schema.to_pandas(\"pyarrow\")\n{'a': 'Int64[pyarrow]', 'b': 'timestamp[ns][pyarrow]'}\n</code></pre>"},{"location":"api-reference/schema/#narwhals.schema.Schema.to_polars","title":"to_polars","text":"<pre><code>to_polars() -&gt; pl.Schema\n</code></pre> <p>Convert Schema to a polars Schema.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; schema = nw.Schema({\"a\": nw.Int64(), \"b\": nw.Datetime(\"ns\")})\n&gt;&gt;&gt; schema.to_polars()\nSchema({'a': Int64, 'b': Datetime(time_unit='ns', time_zone=None)})\n</code></pre>"},{"location":"api-reference/selectors/","title":"<code>narwhals.selectors</code>","text":"<p>The following selectors are all supported. In addition, just like in Polars, the following set operations are supported:</p> <ul> <li>set intersection: <code>&amp;</code></li> <li>set union: <code>|</code></li> <li>set difference: <code>-</code></li> <li>complement: <code>~</code></li> </ul>"},{"location":"api-reference/selectors/#narwhals.selectors.boolean","title":"boolean","text":"<pre><code>boolean() -&gt; Selector\n</code></pre> <p>Select boolean columns.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import narwhals.selectors as ncs\n&gt;&gt;&gt; df_native = pl.DataFrame({\"a\": [1, 2], \"b\": [\"x\", \"y\"], \"c\": [False, True]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n</code></pre> <p>Let's select boolean dtypes:</p> <pre><code>&gt;&gt;&gt; df.select(ncs.boolean())\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|  shape: (2, 1)   |\n|  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510       |\n|  \u2502 c     \u2502       |\n|  \u2502 ---   \u2502       |\n|  \u2502 bool  \u2502       |\n|  \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561       |\n|  \u2502 false \u2502       |\n|  \u2502 true  \u2502       |\n|  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518       |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/selectors/#narwhals.selectors.by_dtype","title":"by_dtype","text":"<pre><code>by_dtype(\n    *dtypes: DType\n    | type[DType]\n    | Iterable[DType | type[DType]],\n) -&gt; Selector\n</code></pre> <p>Select columns based on their dtype.</p> <p>Parameters:</p> Name Type Description Default <code>dtypes</code> <code>DType | type[DType] | Iterable[DType | type[DType]]</code> <p>one or data types to select</p> <code>()</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import narwhals.selectors as ncs\n&gt;&gt;&gt; df_native = pa.table({\"a\": [1, 2], \"b\": [\"x\", \"y\"], \"c\": [4.1, 2.3]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n</code></pre> <p>Let's select int64 and float64  dtypes and multiply each value by 2:</p> <pre><code>&gt;&gt;&gt; df.select(ncs.by_dtype(nw.Int64, nw.Float64) * 2).to_native()\npyarrow.Table\na: int64\nc: double\n----\na: [[2,4]]\nc: [[8.2,4.6]]\n</code></pre>"},{"location":"api-reference/selectors/#narwhals.selectors.categorical","title":"categorical","text":"<pre><code>categorical() -&gt; Selector\n</code></pre> <p>Select categorical columns.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import narwhals.selectors as ncs\n&gt;&gt;&gt; df_native = pl.DataFrame({\"a\": [1, 2], \"b\": [\"x\", \"y\"], \"c\": [False, True]})\n</code></pre> <p>Let's convert column \"b\" to categorical, and then select categorical dtypes:</p> <pre><code>&gt;&gt;&gt; df = nw.from_native(df_native).with_columns(\n...     b=nw.col(\"b\").cast(nw.Categorical())\n... )\n&gt;&gt;&gt; df.select(ncs.categorical()).to_native()\nshape: (2, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 b   \u2502\n\u2502 --- \u2502\n\u2502 cat \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 x   \u2502\n\u2502 y   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/selectors/#narwhals.selectors.datetime","title":"datetime","text":"<pre><code>datetime(\n    time_unit: TimeUnit | Iterable[TimeUnit] | None = None,\n    time_zone: (\n        str\n        | timezone\n        | Iterable[str | timezone | None]\n        | None\n    ) = (\"*\", None),\n) -&gt; Selector\n</code></pre> <p>Select all datetime columns, optionally filtering by time unit/zone.</p> <p>Parameters:</p> Name Type Description Default <code>time_unit</code> <code>TimeUnit | Iterable[TimeUnit] | None</code> <p>One (or more) of the allowed timeunit precision strings, \"ms\", \"us\", \"ns\" and \"s\". Omit to select columns with any valid timeunit.</p> <code>None</code> <code>time_zone</code> <code>str | timezone | Iterable[str | timezone | None] | None</code> <p>Specify which timezone(s) to select</p> <ul> <li>One or more timezone strings, as defined in zoneinfo (to see valid options     run <code>import zoneinfo; zoneinfo.available_timezones()</code> for a full list).</li> <li>Set <code>None</code> to select Datetime columns that do not have a timezone.</li> <li>Set <code>\"*\"</code> to select Datetime columns that have any timezone.</li> </ul> <code>('*', None)</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime, timezone\n&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import narwhals.selectors as ncs\n&gt;&gt;&gt;\n&gt;&gt;&gt; utc_tz = timezone.utc\n&gt;&gt;&gt; data = {\n...     \"tstamp_utc\": [\n...         datetime(2023, 4, 10, 12, 14, 16, 999000, tzinfo=utc_tz),\n...         datetime(2025, 8, 25, 14, 18, 22, 666000, tzinfo=utc_tz),\n...     ],\n...     \"tstamp\": [\n...         datetime(2000, 11, 20, 18, 12, 16, 600000),\n...         datetime(2020, 10, 30, 10, 20, 25, 123000),\n...     ],\n...     \"numeric\": [3.14, 6.28],\n... }\n&gt;&gt;&gt; df_native = pa.table(data)\n&gt;&gt;&gt; df_nw = nw.from_native(df_native)\n&gt;&gt;&gt; df_nw.select(ncs.datetime()).to_native()\npyarrow.Table\ntstamp_utc: timestamp[us, tz=UTC]\ntstamp: timestamp[us]\n----\ntstamp_utc: [[2023-04-10 12:14:16.999000Z,2025-08-25 14:18:22.666000Z]]\ntstamp: [[2000-11-20 18:12:16.600000,2020-10-30 10:20:25.123000]]\n</code></pre> <p>Select only datetime columns that have any time_zone specification:</p> <pre><code>&gt;&gt;&gt; df_nw.select(ncs.datetime(time_zone=\"*\")).to_native()\npyarrow.Table\ntstamp_utc: timestamp[us, tz=UTC]\n----\ntstamp_utc: [[2023-04-10 12:14:16.999000Z,2025-08-25 14:18:22.666000Z]]\n</code></pre>"},{"location":"api-reference/selectors/#narwhals.selectors.matches","title":"matches","text":"<pre><code>matches(pattern: str) -&gt; Selector\n</code></pre> <p>Select all columns that match the given regex pattern.</p> <p>Parameters:</p> Name Type Description Default <code>pattern</code> <code>str</code> <p>A valid regular expression pattern.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import narwhals.selectors as ncs\n&gt;&gt;&gt; df_native = pd.DataFrame(\n...     {\"bar\": [123, 456], \"baz\": [2.0, 5.5], \"zap\": [0, 1]}\n... )\n&gt;&gt;&gt; df = nw.from_native(df_native)\n</code></pre> <p>Let's select column names containing an 'a', preceded by a character that is not 'z':</p> <pre><code>&gt;&gt;&gt; df.select(ncs.matches(\"[^z]a\")).to_native()\n   bar  baz\n0  123  2.0\n1  456  5.5\n</code></pre>"},{"location":"api-reference/selectors/#narwhals.selectors.numeric","title":"numeric","text":"<pre><code>numeric() -&gt; Selector\n</code></pre> <p>Select numeric columns.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import narwhals.selectors as ncs\n&gt;&gt;&gt; df_native = pl.DataFrame({\"a\": [1, 2], \"b\": [\"x\", \"y\"], \"c\": [4.1, 2.3]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n</code></pre> <p>Let's select numeric dtypes and multiply each value by 2:</p> <pre><code>&gt;&gt;&gt; df.select(ncs.numeric() * 2).to_native()\nshape: (2, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 c   \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 i64 \u2506 f64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2   \u2506 8.2 \u2502\n\u2502 4   \u2506 4.6 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/selectors/#narwhals.selectors.string","title":"string","text":"<pre><code>string() -&gt; Selector\n</code></pre> <p>Select string columns.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import narwhals.selectors as ncs\n&gt;&gt;&gt; df_native = pl.DataFrame({\"a\": [1, 2], \"b\": [\"x\", \"y\"], \"c\": [False, True]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n</code></pre> <p>Let's select string dtypes:</p> <pre><code>&gt;&gt;&gt; df.select(ncs.string()).to_native()\nshape: (2, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 b   \u2502\n\u2502 --- \u2502\n\u2502 str \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 x   \u2502\n\u2502 y   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/series/","title":"<code>narwhals.Series</code>","text":"<p>Narwhals Series, backed by a native series.</p> Warning <p>This class is not meant to be instantiated directly - instead:</p> <ul> <li> <p>If the native object is a series from one of the supported backend (e.g.     pandas.Series, polars.Series, pyarrow.ChunkedArray), you can use     <code>narwhals.from_native</code>:     <pre><code>narwhals.from_native(native_series, allow_series=True)\nnarwhals.from_native(native_series, series_only=True)\n</code></pre></p> </li> <li> <p>If the object is a generic sequence (e.g. a list or a tuple of values), you can     create a series via <code>narwhals.new_series</code>, e.g.:     <pre><code>narwhals.new_series(name=\"price\", values=[10.5, 9.4, 1.2], backend=\"pandas\")\n</code></pre></p> </li> </ul>"},{"location":"api-reference/series/#narwhals.series.Series.dtype","title":"dtype  <code>property</code>","text":"<pre><code>dtype: DType\n</code></pre> <p>Get the data type of the Series.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pd.Series([1, 2, 3])\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).dtype\nInt64\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.implementation","title":"implementation  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>implementation: _Implementation = _Implementation()\n</code></pre> <p>Return <code>narwhals.Implementation</code> of native Series.</p> <p>This can be useful when you need to use special-casing for features outside of Narwhals' scope - for example, when dealing with pandas' Period Dtype.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; s_native = pd.Series([1, 2, 3])\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.implementation\n&lt;Implementation.PANDAS: 'pandas'&gt;\n&gt;&gt;&gt; s.implementation.is_pandas()\nTrue\n&gt;&gt;&gt; s.implementation.is_pandas_like()\nTrue\n&gt;&gt;&gt; s.implementation.is_polars()\nFalse\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>Get the name of the Series.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pl.Series(\"foo\", [1, 2, 3])\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).name\n'foo'\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.shape","title":"shape  <code>property</code>","text":"<pre><code>shape: tuple[int]\n</code></pre> <p>Get the shape of the Series.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pd.Series([1, 2, 3])\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).shape\n(3,)\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.__arrow_c_stream__","title":"__arrow_c_stream__","text":"<pre><code>__arrow_c_stream__(\n    requested_schema: object | None = None,\n) -&gt; object\n</code></pre> <p>Export a Series via the Arrow PyCapsule Interface.</p> <p>Narwhals doesn't implement anything itself here:</p> <ul> <li>if the underlying series implements the interface, it'll return that</li> <li>else, it'll call <code>to_arrow</code> and then defer to PyArrow's implementation</li> </ul> <p>See PyCapsule Interface for more.</p>"},{"location":"api-reference/series/#narwhals.series.Series.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(idx: SingleIndexSelector) -&gt; Any\n</code></pre><pre><code>__getitem__(idx: MultiIndexSelector) -&gt; Self\n</code></pre> <pre><code>__getitem__(\n    idx: SingleIndexSelector | MultiIndexSelector,\n) -&gt; Any | Self\n</code></pre> <p>Retrieve elements from the object using integer indexing or slicing.</p> <p>Parameters:</p> Name Type Description Default <code>idx</code> <code>SingleIndexSelector | MultiIndexSelector</code> <p>The index, slice, or sequence of indices to retrieve.</p> <ul> <li>If <code>idx</code> is an integer, a single element is returned.</li> <li>If <code>idx</code> is a slice, a sequence of integers, or another Series     (with integer values) a subset of the Series is returned.</li> </ul> required <p>Returns:</p> Type Description <code>Any | Self</code> <p>A single element if <code>idx</code> is an integer, else a subset of the Series.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pa.chunked_array([[1, 2, 3]])\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True)[0]\n1\n</code></pre> <pre><code>&gt;&gt;&gt; nw.from_native(s_native, series_only=True)[\n...     :2\n... ].to_native()\n&lt;pyarrow.lib.ChunkedArray object at ...&gt;\n[\n  [\n    1,\n    2\n  ]\n]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.__iter__","title":"__iter__","text":"<pre><code>__iter__() -&gt; Iterator[Any]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.abs","title":"abs","text":"<pre><code>abs() -&gt; Self\n</code></pre> <p>Calculate the absolute value of each element.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pa.chunked_array([[2, -4, 3]])\n&gt;&gt;&gt; nw.from_native(\n...     s_native, series_only=True\n... ).abs().to_native()\n&lt;pyarrow.lib.ChunkedArray object at ...&gt;\n[\n  [\n    2,\n    4,\n    3\n  ]\n]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.alias","title":"alias","text":"<pre><code>alias(name: str) -&gt; Self\n</code></pre> <p>Rename the Series.</p> Notes <p>This method is very cheap, but does not guarantee that data will be copied. For example:</p> <pre><code>s1: nw.Series\ns2 = s1.alias(\"foo\")\narr = s2.to_numpy()\narr[0] = 999\n</code></pre> <p>may (depending on the backend, and on the version) result in <code>s1</code>'s data being modified. We recommend:</p> <pre><code>- if you need to alias an object and don't need the original\n  one around any more, just use `alias` without worrying about it.\n- if you were expecting `alias` to copy data, then explicitly call\n  `.clone` before calling `alias`.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The new name.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pd.Series([1, 2, 3], name=\"foo\")\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).alias(\"bar\").to_native()\n0    1\n1    2\n2    3\nName: bar, dtype: int64\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.all","title":"all","text":"<pre><code>all() -&gt; bool\n</code></pre> <p>Return whether all values in the Series are True.</p> <p>If there are no non-null elements, the result is <code>True</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pa.chunked_array([[False, True, False]])\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).all()\nFalse\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.any","title":"any","text":"<pre><code>any() -&gt; bool\n</code></pre> <p>Return whether any of the values in the Series are True.</p> <p>If there are no non-null elements, the result is <code>False</code>.</p> Notes <p>Only works on Series of data type Boolean.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pd.Series([False, True, False])\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).any()\nnp.True_\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.arg_max","title":"arg_max","text":"<pre><code>arg_max() -&gt; int\n</code></pre> <p>Returns the index of the maximum value.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pl.Series([1, 2, 3])\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).arg_max()\n2\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.arg_min","title":"arg_min","text":"<pre><code>arg_min() -&gt; int\n</code></pre> <p>Returns the index of the minimum value.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pa.chunked_array([[1, 2, 3]])\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).arg_min()\n0\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.arg_true","title":"arg_true","text":"<pre><code>arg_true() -&gt; Self\n</code></pre> <p>Find elements where boolean Series is True.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pl.Series([1, None, None, 2])\n&gt;&gt;&gt; nw.from_native(\n...     s_native, series_only=True\n... ).is_null().arg_true().to_native()\nshape: (2,)\nSeries: '' [u32]\n[\n   1\n   2\n]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.cast","title":"cast","text":"<pre><code>cast(dtype: IntoDType) -&gt; Self\n</code></pre> <p>Cast between data types.</p> <p>Parameters:</p> Name Type Description Default <code>dtype</code> <code>IntoDType</code> <p>Data type that the object will be cast into.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pa.chunked_array([[True, False, True]])\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).cast(nw.Int64).to_native()\n&lt;pyarrow.lib.ChunkedArray object at ...&gt;\n[\n  [\n    1,\n    0,\n    1\n  ]\n]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.ceil","title":"ceil","text":"<pre><code>ceil() -&gt; Self\n</code></pre> <p>Compute the numerical ceiling.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pa.chunked_array([[1.1, 4.3, -1.3]])\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.ceil().to_native()\n&lt;pyarrow.lib.ChunkedArray object at ...&gt;\n[\n  [\n    2,\n    5,\n    -1\n  ]\n]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.clip","title":"clip","text":"<pre><code>clip(\n    lower_bound: (\n        Self | NumericLiteral | TemporalLiteral | None\n    ) = None,\n    upper_bound: (\n        Self | NumericLiteral | TemporalLiteral | None\n    ) = None,\n) -&gt; Self\n</code></pre> <p>Clip values in the Series.</p> <p>Parameters:</p> Name Type Description Default <code>lower_bound</code> <code>Self | NumericLiteral | TemporalLiteral | None</code> <p>Lower bound value.</p> <code>None</code> <code>upper_bound</code> <code>Self | NumericLiteral | TemporalLiteral | None</code> <p>Upper bound value.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pd.Series([-1, 1, -3, 3, -5, 5])\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).clip(-1, 3).to_native()\n0   -1\n1    1\n2   -1\n3    3\n4   -1\n5    3\ndtype: int64\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.count","title":"count","text":"<pre><code>count() -&gt; int\n</code></pre> <p>Returns the number of non-null elements in the Series.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pa.chunked_array([[1, 2, None]])\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).count()\n2\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.cum_count","title":"cum_count","text":"<pre><code>cum_count(*, reverse: bool = False) -&gt; Self\n</code></pre> <p>Return the cumulative count of the non-null values in the series.</p> <p>Parameters:</p> Name Type Description Default <code>reverse</code> <code>bool</code> <p>reverse the operation</p> <code>False</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pl.Series([\"x\", \"k\", None, \"d\"])\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).cum_count(\n...     reverse=True\n... ).to_native()\nshape: (4,)\nSeries: '' [u32]\n[\n    3\n    2\n    1\n    1\n]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.cum_max","title":"cum_max","text":"<pre><code>cum_max(*, reverse: bool = False) -&gt; Self\n</code></pre> <p>Return the cumulative max of the non-null values in the series.</p> <p>Parameters:</p> Name Type Description Default <code>reverse</code> <code>bool</code> <p>reverse the operation</p> <code>False</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pa.chunked_array([[1, 3, None, 2]])\n&gt;&gt;&gt; nw.from_native(\n...     s_native, series_only=True\n... ).cum_max().to_native()\n&lt;pyarrow.lib.ChunkedArray object at ...&gt;\n[\n  [\n    1,\n    3,\n    null,\n    3\n  ]\n]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.cum_min","title":"cum_min","text":"<pre><code>cum_min(*, reverse: bool = False) -&gt; Self\n</code></pre> <p>Return the cumulative min of the non-null values in the series.</p> <p>Parameters:</p> Name Type Description Default <code>reverse</code> <code>bool</code> <p>reverse the operation</p> <code>False</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pd.Series([3, 1, None, 2])\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).cum_min().to_native()\n0    3.0\n1    1.0\n2    NaN\n3    1.0\ndtype: float64\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.cum_prod","title":"cum_prod","text":"<pre><code>cum_prod(*, reverse: bool = False) -&gt; Self\n</code></pre> <p>Return the cumulative product of the non-null values in the series.</p> <p>Parameters:</p> Name Type Description Default <code>reverse</code> <code>bool</code> <p>reverse the operation</p> <code>False</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pl.Series([1, 3, None, 2])\n&gt;&gt;&gt; nw.from_native(\n...     s_native, series_only=True\n... ).cum_prod().to_native()\nshape: (4,)\nSeries: '' [i64]\n[\n   1\n   3\n   null\n   6\n]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.cum_sum","title":"cum_sum","text":"<pre><code>cum_sum(*, reverse: bool = False) -&gt; Self\n</code></pre> <p>Calculate the cumulative sum.</p> <p>Parameters:</p> Name Type Description Default <code>reverse</code> <code>bool</code> <p>reverse the operation</p> <code>False</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pd.Series([2, 4, 3])\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).cum_sum().to_native()\n0    2\n1    6\n2    9\ndtype: int64\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.diff","title":"diff","text":"<pre><code>diff() -&gt; Self\n</code></pre> <p>Calculate the difference with the previous element, for each element.</p> Notes <p>pandas may change the dtype here, for example when introducing missing values in an integer column. To ensure, that the dtype doesn't change, you may want to use <code>fill_null</code> and <code>cast</code>. For example, to calculate the diff and fill missing values with <code>0</code> in a Int64 column, you could do:</p> <pre><code>s.diff().fill_null(0).cast(nw.Int64)\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pa.chunked_array([[2, 4, 3]])\n&gt;&gt;&gt; nw.from_native(\n...     s_native, series_only=True\n... ).diff().to_native()\n&lt;pyarrow.lib.ChunkedArray object at ...&gt;\n[\n  [\n    null,\n    2,\n    -1\n  ]\n]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.drop_nulls","title":"drop_nulls","text":"<pre><code>drop_nulls() -&gt; Self\n</code></pre> <p>Drop null values.</p> Notes <p>pandas handles null values differently from Polars and PyArrow. See null_handling for reference.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pd.Series([2, 4, None, 3, 5])\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).drop_nulls().to_native()\n0    2.0\n1    4.0\n3    3.0\n4    5.0\ndtype: float64\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.ewm_mean","title":"ewm_mean","text":"<pre><code>ewm_mean(\n    *,\n    com: float | None = None,\n    span: float | None = None,\n    half_life: float | None = None,\n    alpha: float | None = None,\n    adjust: bool = True,\n    min_samples: int = 1,\n    ignore_nulls: bool = False\n) -&gt; Self\n</code></pre> <p>Compute exponentially-weighted moving average.</p> <p>Parameters:</p> Name Type Description Default <code>com</code> <code>float | None</code> <p>Specify decay in terms of center of mass, \\(\\gamma\\), with  \\(\\alpha = \\frac{1}{1+\\gamma}\\forall\\gamma\\geq0\\)</p> <code>None</code> <code>span</code> <code>float | None</code> <p>Specify decay in terms of span, \\(\\theta\\), with  \\(\\alpha = \\frac{2}{\\theta + 1} \\forall \\theta \\geq 1\\)</p> <code>None</code> <code>half_life</code> <code>float | None</code> <p>Specify decay in terms of half-life, \\(\\tau\\), with  \\(\\alpha = 1 - \\exp \\left\\{ \\frac{ -\\ln(2) }{ \\tau } \\right\\} \\forall \\tau &gt; 0\\)</p> <code>None</code> <code>alpha</code> <code>float | None</code> <p>Specify smoothing factor alpha directly, \\(0 &lt; \\alpha \\leq 1\\).</p> <code>None</code> <code>adjust</code> <code>bool</code> <p>Divide by decaying adjustment factor in beginning periods to account for imbalance in relative weightings</p> <ul> <li>When <code>adjust=True</code> (the default) the EW function is calculated   using weights \\(w_i = (1 - \\alpha)^i\\)</li> <li>When <code>adjust=False</code> the EW function is calculated recursively by   $$   y_0=x_0   $$   $$   y_t = (1 - \\alpha)y_{t - 1} + \\alpha x_t   $$</li> </ul> <code>True</code> <code>min_samples</code> <code>int</code> <p>Minimum number of observations in window required to have a value (otherwise result is null).</p> <code>1</code> <code>ignore_nulls</code> <code>bool</code> <p>Ignore missing values when calculating weights.</p> <ul> <li>When <code>ignore_nulls=False</code> (default), weights are based on absolute   positions.   For example, the weights of \\(x_0\\) and \\(x_2\\) used in   calculating the final weighted average of \\([x_0, None, x_2]\\) are   \\((1-\\alpha)^2\\) and \\(1\\) if <code>adjust=True</code>, and   \\((1-\\alpha)^2\\) and \\(\\alpha\\) if <code>adjust=False</code>.</li> <li>When <code>ignore_nulls=True</code>, weights are based   on relative positions. For example, the weights of   \\(x_0\\) and \\(x_2\\) used in calculating the final weighted   average of \\([x_0, None, x_2]\\) are   \\(1-\\alpha\\) and \\(1\\) if <code>adjust=True</code>,   and \\(1-\\alpha\\) and \\(\\alpha\\) if <code>adjust=False</code>.</li> </ul> <code>False</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pd.Series(name=\"a\", data=[1, 2, 3])\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).ewm_mean(\n...     com=1, ignore_nulls=False\n... ).to_native()\n0    1.000000\n1    1.666667\n2    2.428571\nName: a, dtype: float64\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.exp","title":"exp","text":"<pre><code>exp() -&gt; Self\n</code></pre> <p>Compute the exponent.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pd.Series([-1, 0, 1], name=\"a\")\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.exp()\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|    Narwhals Series    |\n|-----------------------|\n|0    0.367879          |\n|1    1.000000          |\n|2    2.718282          |\n|Name: a, dtype: float64|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.fill_nan","title":"fill_nan","text":"<pre><code>fill_nan(value: float | None) -&gt; Self\n</code></pre> <p>Fill floating point NaN values with given value.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float | None</code> <p>Value used to fill NaN values.</p> required Notes <p>This function only fills <code>'NaN'</code> values, not null ones, except for pandas which doesn't distinguish between them. See null_handling for reference.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pl.Series([1.0, 2.0, float(\"nan\"), None])\n&gt;&gt;&gt; result = nw.from_native(s_native, series_only=True).fill_nan(0)\n&gt;&gt;&gt; result.to_native()\nshape: (4,)\nSeries: '' [f64]\n[\n   1.0\n   2.0\n   0.0\n   null\n]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.fill_null","title":"fill_null","text":"<pre><code>fill_null(\n    value: Self | NonNestedLiteral = None,\n    strategy: FillNullStrategy | None = None,\n    limit: int | None = None,\n) -&gt; Self\n</code></pre> <p>Fill null values using the specified value.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Self | NonNestedLiteral</code> <p>Value used to fill null values.</p> <code>None</code> <code>strategy</code> <code>FillNullStrategy | None</code> <p>Strategy used to fill null values.</p> <code>None</code> <code>limit</code> <code>int | None</code> <p>Number of consecutive null values to fill when using the 'forward' or 'backward' strategy.</p> <code>None</code> Notes <ul> <li>pandas handles null values differently from other libraries.   See null_handling   for reference.</li> <li>For pandas Series of <code>object</code> dtype, <code>fill_null</code> will not automatically change the   Series' dtype as pandas used to do. Explicitly call <code>cast</code> if you want the dtype to change.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pd.Series([1, 2, None])\n&gt;&gt;&gt;\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).fill_null(5).to_native()\n0    1.0\n1    2.0\n2    5.0\ndtype: float64\n</code></pre> <p>Or using a strategy:</p> <pre><code>&gt;&gt;&gt; nw.from_native(s_native, series_only=True).fill_null(\n...     strategy=\"forward\", limit=1\n... ).to_native()\n0    1.0\n1    2.0\n2    2.0\ndtype: float64\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.filter","title":"filter","text":"<pre><code>filter(predicate: Any) -&gt; Self\n</code></pre> <p>Filter elements in the Series based on a condition.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pd.Series([4, 10, 15, 34, 50])\n&gt;&gt;&gt; s_nw = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s_nw.filter(s_nw &gt; 10).to_native()\n2    15\n3    34\n4    50\ndtype: int64\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.first","title":"first","text":"<pre><code>first() -&gt; PythonLiteral\n</code></pre> <p>Get the first element of the Series.</p> <p>Returns:</p> Type Description <code>PythonLiteral</code> <p>A scalar value or <code>None</code> if the Series is empty.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pl.Series([1, 2, 3])\n&gt;&gt;&gt; s_nw = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s_nw.first()\n1\n&gt;&gt;&gt; s_nw.filter(s_nw &gt; 5).first() is None\nTrue\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.floor","title":"floor","text":"<pre><code>floor() -&gt; Self\n</code></pre> <p>Compute the numerical floor.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pa.chunked_array([[1.1, 4.3, -1.3]])\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.floor().to_native()\n&lt;pyarrow.lib.ChunkedArray object at ...&gt;\n[\n  [\n    1,\n    4,\n    -2\n  ]\n]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.from_iterable","title":"from_iterable  <code>classmethod</code>","text":"<pre><code>from_iterable(\n    name: str,\n    values: Iterable[Any],\n    dtype: IntoDType | None = None,\n    *,\n    backend: IntoBackend[EagerAllowed]\n) -&gt; Series[Any]\n</code></pre> <p>Construct a Series from an iterable.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of resulting Series.</p> required <code>values</code> <code>Iterable[Any]</code> <p>One-dimensional data represented as an iterable.</p> required <code>dtype</code> <code>IntoDType | None</code> <p>(Narwhals) dtype. If not provided, the native library may auto-infer it from <code>values</code>.</p> <code>None</code> <code>backend</code> <code>IntoBackend[EagerAllowed]</code> <p>specifies which eager backend instantiate to.</p> <p><code>backend</code> can be specified in various ways</p> <ul> <li>As <code>Implementation.&lt;BACKEND&gt;</code> with <code>BACKEND</code> being <code>PANDAS</code>, <code>PYARROW</code>,     <code>POLARS</code>, <code>MODIN</code> or <code>CUDF</code>.</li> <li>As a string: <code>\"pandas\"</code>, <code>\"pyarrow\"</code>, <code>\"polars\"</code>, <code>\"modin\"</code> or <code>\"cudf\"</code>.</li> <li>Directly as a module <code>pandas</code>, <code>pyarrow</code>, <code>polars</code>, <code>modin</code> or <code>cudf</code>.</li> </ul> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; values = [4, 1, 3, 2]\n&gt;&gt;&gt; nw.Series.from_iterable(\"a\", values, dtype=nw.UInt32, backend=\"pandas\")\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|   Narwhals Series    |\n|----------------------|\n|0    4                |\n|1    1                |\n|2    3                |\n|3    2                |\n|Name: a, dtype: uint32|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.from_numpy","title":"from_numpy  <code>classmethod</code>","text":"<pre><code>from_numpy(\n    name: str,\n    values: _1DArray,\n    dtype: IntoDType | None = None,\n    *,\n    backend: IntoBackend[EagerAllowed]\n) -&gt; Series[Any]\n</code></pre> <p>Construct a Series from a NumPy ndarray.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of resulting Series.</p> required <code>values</code> <code>_1DArray</code> <p>One-dimensional data represented as a NumPy ndarray.</p> required <code>dtype</code> <code>IntoDType | None</code> <p>(Narwhals) dtype. If not provided, the native library may auto-infer it from <code>values</code>.</p> <code>None</code> <code>backend</code> <code>IntoBackend[EagerAllowed]</code> <p>specifies which eager backend instantiate to.</p> <p><code>backend</code> can be specified in various ways</p> <ul> <li>As <code>Implementation.&lt;BACKEND&gt;</code> with <code>BACKEND</code> being <code>PANDAS</code>, <code>PYARROW</code>,     <code>POLARS</code>, <code>MODIN</code> or <code>CUDF</code>.</li> <li>As a string: <code>\"pandas\"</code>, <code>\"pyarrow\"</code>, <code>\"polars\"</code>, <code>\"modin\"</code> or <code>\"cudf\"</code>.</li> <li>Directly as a module <code>pandas</code>, <code>pyarrow</code>, <code>polars</code>, <code>modin</code> or <code>cudf</code>.</li> </ul> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; arr = np.arange(5, 10)\n&gt;&gt;&gt; nw.Series.from_numpy(\"arr\", arr, dtype=nw.Int8, backend=\"polars\")\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n| Narwhals Series  |\n|------------------|\n|shape: (5,)       |\n|Series: 'arr' [i8]|\n|[                 |\n|        5         |\n|        6         |\n|        7         |\n|        8         |\n|        9         |\n|]                 |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.gather_every","title":"gather_every","text":"<pre><code>gather_every(n: int, offset: int = 0) -&gt; Self\n</code></pre> <p>Take every nth value in the Series and return as new Series.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Gather every n-th row.</p> required <code>offset</code> <code>int</code> <p>Starting index.</p> <code>0</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pa.chunked_array([[1, 2, 3, 4]])\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).gather_every(\n...     n=2, offset=1\n... ).to_native()\n&lt;pyarrow.lib.ChunkedArray object at ...&gt;\n[\n  [\n    2,\n    4\n  ]\n]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.head","title":"head","text":"<pre><code>head(n: int = 10) -&gt; Self\n</code></pre> <p>Get the first <code>n</code> rows.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Number of rows to return.</p> <code>10</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pd.Series(list(range(10)))\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).head(3).to_native()\n0    0\n1    1\n2    2\ndtype: int64\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.hist","title":"hist","text":"<pre><code>hist(\n    bins: list[float] | None = None,\n    *,\n    bin_count: int | None = None,\n    include_breakpoint: bool = True\n) -&gt; DataFrame[Any]\n</code></pre> <p>Bin values into buckets and count their occurrences.</p> Warning <p>This functionality is considered unstable. It may be changed at any point without it being considered a breaking change.</p> <p>Parameters:</p> Name Type Description Default <code>bins</code> <code>list[float] | None</code> <p>A monotonically increasing sequence of values.</p> <code>None</code> <code>bin_count</code> <code>int | None</code> <p>If no bins provided, this will be used to determine the distance of the bins.</p> <code>None</code> <code>include_breakpoint</code> <code>bool</code> <p>Include a column that shows the intervals as categories.</p> <code>True</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pd.Series([1, 3, 8, 8, 2, 1, 3], name=\"a\")\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).hist(bin_count=4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n| Narwhals DataFrame |\n|--------------------|\n|   breakpoint  count|\n|0        2.75      3|\n|1        4.50      2|\n|2        6.25      0|\n|3        8.00      2|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.is_between","title":"is_between","text":"<pre><code>is_between(\n    lower_bound: Any | Self,\n    upper_bound: Any | Self,\n    closed: ClosedInterval = \"both\",\n) -&gt; Self\n</code></pre> <p>Get a boolean mask of the values that are between the given lower/upper bounds.</p> <p>Parameters:</p> Name Type Description Default <code>lower_bound</code> <code>Any | Self</code> <p>Lower bound value.</p> required <code>upper_bound</code> <code>Any | Self</code> <p>Upper bound value.</p> required <code>closed</code> <code>ClosedInterval</code> <p>Define which sides of the interval are closed (inclusive).</p> <code>'both'</code> Notes <p>If the value of the <code>lower_bound</code> is greater than that of the <code>upper_bound</code>, then the values will be False, as no value can satisfy the condition.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pa.chunked_array([[1, 2, 3, 4, 5]])\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.is_between(2, 4, \"right\").to_native()\n&lt;pyarrow.lib.ChunkedArray object at ...&gt;\n[\n  [\n    false,\n    false,\n    true,\n    true,\n    false\n  ]\n]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.is_close","title":"is_close","text":"<pre><code>is_close(\n    other: Self | NumericLiteral,\n    *,\n    abs_tol: float = 0.0,\n    rel_tol: float = 1e-09,\n    nans_equal: bool = False\n) -&gt; Self\n</code></pre> <p>Get a boolean mask of the values being close to the other values.</p> <p>Two values <code>a</code> and <code>b</code> are considered close if the following condition holds:</p> \\[ |a-b| \\le max \\{ \\text{rel\\_tol} \\cdot max \\{ |a|, |b| \\}, \\text{abs\\_tol} \\} \\] <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Self | NumericLiteral</code> <p>Values to compare with.</p> required <code>abs_tol</code> <code>float</code> <p>Absolute tolerance. This is the maximum allowed absolute difference between two values. Must be non-negative.</p> <code>0.0</code> <code>rel_tol</code> <code>float</code> <p>Relative tolerance. This is the maximum allowed difference between two values, relative to the larger absolute value. Must be in the range [0, 1).</p> <code>1e-09</code> <code>nans_equal</code> <code>bool</code> <p>Whether NaN values should be considered equal.</p> <code>False</code> Notes <p>The implementation of this method is symmetric and mirrors the behavior of <code>math.isclose</code>. Specifically note that this behavior is different to <code>numpy.isclose</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; data = [1.0, float(\"inf\"), 1.41, None, float(\"nan\")]\n&gt;&gt;&gt; s_native = pa.chunked_array([data])\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.is_close(1.4, abs_tol=0.1).to_native()\n&lt;pyarrow.lib.ChunkedArray object at ...&gt;\n[\n  [\n    false,\n    false,\n    true,\n    null,\n    false\n  ]\n]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.is_duplicated","title":"is_duplicated","text":"<pre><code>is_duplicated() -&gt; Self\n</code></pre> <p>Get a mask of all duplicated rows in the Series.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pa.chunked_array([[1, 2, 3, 1]])\n&gt;&gt;&gt; nw.from_native(\n...     s_native, series_only=True\n... ).is_duplicated().to_native()\n&lt;pyarrow.lib.ChunkedArray object at ...&gt;\n[\n  [\n    true,\n    false,\n    false,\n    true\n  ]\n]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.is_empty","title":"is_empty","text":"<pre><code>is_empty() -&gt; bool\n</code></pre> <p>Check if the series is empty.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pl.Series([1, 2, 3])\n&gt;&gt;&gt; s_nw = nw.from_native(s_native, series_only=True)\n</code></pre> <pre><code>&gt;&gt;&gt; s_nw.is_empty()\nFalse\n&gt;&gt;&gt; s_nw.filter(s_nw &gt; 10).is_empty()\nTrue\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.is_finite","title":"is_finite","text":"<pre><code>is_finite() -&gt; Self\n</code></pre> <p>Returns a boolean Series indicating which values are finite.</p> Warning <p>Different backend handle null values differently. <code>is_finite</code> will return False for NaN and Null's in the Dask and pandas non-nullable backend, while for Polars, PyArrow and pandas nullable backends null values are kept as such.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pa.chunked_array([[float(\"nan\"), float(\"inf\"), 2.0, None]])\n&gt;&gt;&gt; nw.from_native(\n...     s_native, series_only=True\n... ).is_finite().to_native()\n&lt;pyarrow.lib.ChunkedArray object at ...&gt;\n[\n  [\n    false,\n    false,\n    true,\n    null\n  ]\n]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.is_first_distinct","title":"is_first_distinct","text":"<pre><code>is_first_distinct() -&gt; Self\n</code></pre> <p>Return a boolean mask indicating the first occurrence of each distinct value.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pl.Series([1, 1, 2, 3, 2])\n&gt;&gt;&gt; nw.from_native(\n...     s_native, series_only=True\n... ).is_first_distinct().to_native()\nshape: (5,)\nSeries: '' [bool]\n[\n    true\n    false\n    true\n    true\n    false\n]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.is_in","title":"is_in","text":"<pre><code>is_in(other: Any) -&gt; Self\n</code></pre> <p>Check if the elements of this Series are in the other sequence.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>Sequence of primitive type.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pa.chunked_array([[1, 2, 3]])\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.is_in([3, 2, 8]).to_native()\n&lt;pyarrow.lib.ChunkedArray object at ...&gt;\n[\n  [\n    false,\n    true,\n    true\n  ]\n]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.is_last_distinct","title":"is_last_distinct","text":"<pre><code>is_last_distinct() -&gt; Self\n</code></pre> <p>Return a boolean mask indicating the last occurrence of each distinct value.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pd.Series([1, 1, 2, 3, 2])\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).is_last_distinct().to_native()\n0    False\n1     True\n2    False\n3     True\n4     True\ndtype: bool\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.is_nan","title":"is_nan","text":"<pre><code>is_nan() -&gt; Self\n</code></pre> <p>Returns a boolean Series indicating which values are NaN.</p> Notes <p>pandas handles null values differently from Polars and PyArrow. See null_handling for reference.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pd.Series([0.0, None, 2.0], dtype=\"Float64\")\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).is_nan().to_native()\n0    False\n1     &lt;NA&gt;\n2    False\ndtype: boolean\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.is_null","title":"is_null","text":"<pre><code>is_null() -&gt; Self\n</code></pre> <p>Returns a boolean Series indicating which values are null.</p> Notes <p>pandas handles null values differently from Polars and PyArrow. See null_handling for reference.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pa.chunked_array([[1, 2, None]])\n&gt;&gt;&gt; nw.from_native(\n...     s_native, series_only=True\n... ).is_null().to_native()\n&lt;pyarrow.lib.ChunkedArray object at ...&gt;\n[\n  [\n    false,\n    false,\n    true\n  ]\n]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.is_sorted","title":"is_sorted","text":"<pre><code>is_sorted(*, descending: bool = False) -&gt; bool\n</code></pre> <p>Check if the Series is sorted.</p> <p>Parameters:</p> Name Type Description Default <code>descending</code> <code>bool</code> <p>Check if the Series is sorted in descending order.</p> <code>False</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pa.chunked_array([[3, 2, 1]])\n&gt;&gt;&gt; s_nw = nw.from_native(s_native, series_only=True)\n</code></pre> <pre><code>&gt;&gt;&gt; s_nw.is_sorted(descending=False)\nFalse\n</code></pre> <pre><code>&gt;&gt;&gt; s_nw.is_sorted(descending=True)\nTrue\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.is_unique","title":"is_unique","text":"<pre><code>is_unique() -&gt; Self\n</code></pre> <p>Get a mask of all unique rows in the Series.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pd.Series([1, 2, 3, 1])\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).is_unique().to_native()\n0    False\n1     True\n2     True\n3    False\ndtype: bool\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.item","title":"item","text":"<pre><code>item(index: int | None = None) -&gt; Any\n</code></pre> <p>Return the Series as a scalar, or return the element at the given index.</p> <p>If no index is provided, this is equivalent to <code>s[0]</code>, with a check that the shape is (1,). With an index, this is equivalent to <code>s[index]</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; nw.from_native(pl.Series(\"a\", [1]), series_only=True).item()\n1\n</code></pre> <pre><code>&gt;&gt;&gt; nw.from_native(pl.Series(\"a\", [9, 8, 7]), series_only=True).item(-1)\n7\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.kurtosis","title":"kurtosis","text":"<pre><code>kurtosis() -&gt; float | None\n</code></pre> <p>Compute the kurtosis (Fisher's definition) without bias correction.</p> <p>Kurtosis is the fourth central moment divided by the square of the variance. The Fisher's definition is used where 3.0 is subtracted from the result to give 0.0 for a normal distribution.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pl.Series([1, 1, 2, 10, 100])\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).kurtosis()\n0.2106571340718002\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.last","title":"last","text":"<pre><code>last() -&gt; PythonLiteral\n</code></pre> <p>Get the last element of the Series.</p> <p>Returns:</p> Type Description <code>PythonLiteral</code> <p>A scalar value or <code>None</code> if the Series is empty.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pa.chunked_array([[1, 2, 3]])\n&gt;&gt;&gt; s_nw = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s_nw.last()\n3\n&gt;&gt;&gt; s_nw.filter(s_nw &gt; 5).last() is None\nTrue\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.len","title":"len","text":"<pre><code>len() -&gt; int\n</code></pre> <p>Return the number of elements in the Series.</p> <p>Null values count towards the total.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pa.chunked_array([[1, 2, None]])\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).len()\n3\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.log","title":"log","text":"<pre><code>log(base: float = math.e) -&gt; Self\n</code></pre> <p>Compute the logarithm to a given base.</p> <p>Parameters:</p> Name Type Description Default <code>base</code> <code>float</code> <p>Given base, defaults to <code>e</code></p> <code>e</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pd.Series([1, 2, 4], name=\"a\")\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.log(base=2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|    Narwhals Series    |\n|-----------------------|\n|0    0.0               |\n|1    1.0               |\n|2    2.0               |\n|Name: a, dtype: float64|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.max","title":"max","text":"<pre><code>max() -&gt; Any\n</code></pre> <p>Get the maximum value in this Series.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pd.Series([1, 2, 3])\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).max()\nnp.int64(3)\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.mean","title":"mean","text":"<pre><code>mean() -&gt; float\n</code></pre> <p>Reduce this Series to the mean value.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pd.Series([1.2, 4.2])\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).mean()\nnp.float64(2.7)\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.median","title":"median","text":"<pre><code>median() -&gt; float\n</code></pre> <p>Reduce this Series to the median value.</p> Notes <p>Results might slightly differ across backends due to differences in the underlying algorithms used to compute the median.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pa.chunked_array([[5, 3, 8]])\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).median()\n5.0\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.min","title":"min","text":"<pre><code>min() -&gt; Any\n</code></pre> <p>Get the minimal value in this Series.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pl.Series([1, 2, 3])\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).min()\n1\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.mode","title":"mode","text":"<pre><code>mode(*, keep: Literal['all'] = 'all') -&gt; Self\n</code></pre><pre><code>mode(*, keep: Literal['any']) -&gt; NonNestedLiteral\n</code></pre> <pre><code>mode(\n    *, keep: ModeKeepStrategy = \"all\"\n) -&gt; Self | NonNestedLiteral\n</code></pre> <p>Compute the most occurring value(s).</p> <p>Can return multiple values.</p> Note <p>For <code>keep=\"any\"</code> a scalar is returned, while for <code>keep=\"all\"</code> a Series in returned even in the case of unimodal values.</p> <p>Parameters:</p> Name Type Description Default <code>keep</code> <code>ModeKeepStrategy</code> <p>Whether to keep all modes or any mode found. Remark that <code>keep='any'</code> is not deterministic for multimodal values.</p> <code>'all'</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pd.Series([1, 1, 2, 2, 3])\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).mode().sort().to_native()\n0    1\n1    2\ndtype: int64\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.n_unique","title":"n_unique","text":"<pre><code>n_unique() -&gt; int\n</code></pre> <p>Count the number of unique values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pl.Series([1, 2, 2, 3])\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).n_unique()\n3\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.null_count","title":"null_count","text":"<pre><code>null_count() -&gt; int\n</code></pre> <p>Count the number of null values.</p> Notes <p>pandas handles null values differently from Polars and PyArrow. See null_handling for reference.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pa.chunked_array([[1, None, None]])\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).null_count()\n2\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.pipe","title":"pipe","text":"<pre><code>pipe(\n    function: Callable[[Any], Self],\n    *args: Any,\n    **kwargs: Any\n) -&gt; Self\n</code></pre> <p>Pipe function call.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pl.Series([1, 2, 3])\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.pipe(lambda x: x + 2).to_native()\nshape: (3,)\nSeries: '' [i64]\n[\n    3\n    4\n    5\n]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.quantile","title":"quantile","text":"<pre><code>quantile(\n    quantile: float,\n    interpolation: RollingInterpolationMethod,\n) -&gt; float\n</code></pre> <p>Get quantile value of the series.</p> Note <p>pandas and Polars may have implementation differences for a given interpolation method.</p> <p>Parameters:</p> Name Type Description Default <code>quantile</code> <code>float</code> <p>Quantile between 0.0 and 1.0.</p> required <code>interpolation</code> <code>RollingInterpolationMethod</code> <p>Interpolation method.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pl.Series(list(range(50)))\n&gt;&gt;&gt; s_nw = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; [\n...     s_nw.quantile(quantile=q, interpolation=\"nearest\")\n...     for q in (0.1, 0.25, 0.5, 0.75, 0.9)\n... ]\n[5.0, 12.0, 25.0, 37.0, 44.0]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.rank","title":"rank","text":"<pre><code>rank(\n    method: RankMethod = \"average\",\n    *,\n    descending: bool = False\n) -&gt; Self\n</code></pre> <p>Assign ranks to data, dealing with ties appropriately.</p> Notes <p>The resulting dtype may differ between backends.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>RankMethod</code> <p>The method used to assign ranks to tied elements. The following methods are available (default is 'average')</p> <ul> <li>\"average\": The average of the ranks that would have been assigned to     all the tied values is assigned to each value.</li> <li>\"min\": The minimum of the ranks that would have been assigned to all     the tied values is assigned to each value. (This is also referred to     as \"competition\" ranking.)</li> <li>\"max\": The maximum of the ranks that would have been assigned to all     the tied values is assigned to each value.</li> <li>\"dense\": Like \"min\", but the rank of the next highest element is     assigned the rank immediately after those assigned to the tied elements.</li> <li>\"ordinal\": All values are given a distinct rank, corresponding to the     order that the values occur in the Series.</li> </ul> <code>'average'</code> <code>descending</code> <code>bool</code> <p>Rank in descending order.</p> <code>False</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pa.chunked_array([[3, 6, 1, 1, 6]])\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).rank(\n...     method=\"dense\"\n... ).to_native()\n&lt;pyarrow.lib.ChunkedArray object at ...&gt;\n[\n  [\n    2,\n    3,\n    1,\n    1,\n    3\n  ]\n]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.rename","title":"rename","text":"<pre><code>rename(name: str) -&gt; Self\n</code></pre> <p>Rename the Series.</p> <p>Alias for <code>Series.alias()</code>.</p> Notes <p>This method is very cheap, but does not guarantee that data will be copied. For example:</p> <pre><code>s1: nw.Series\ns2 = s1.rename(\"foo\")\narr = s2.to_numpy()\narr[0] = 999\n</code></pre> <p>may (depending on the backend, and on the version) result in <code>s1</code>'s data being modified. We recommend:</p> <pre><code>- if you need to rename an object and don't need the original\n  one around any more, just use `rename` without worrying about it.\n- if you were expecting `rename` to copy data, then explicitly call\n  `.clone` before calling `rename`.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The new name.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pl.Series(\"foo\", [1, 2, 3])\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.rename(\"bar\").to_native()\nshape: (3,)\nSeries: 'bar' [i64]\n[\n   1\n   2\n   3\n]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.replace_strict","title":"replace_strict","text":"<pre><code>replace_strict(\n    old: Sequence[Any] | Mapping[Any, Any],\n    new: Sequence[Any] | None = None,\n    *,\n    return_dtype: IntoDType | None = None\n) -&gt; Self\n</code></pre> <p>Replace all values by different values.</p> <p>This function must replace all non-null input values (else it raises an error).</p> <p>Parameters:</p> Name Type Description Default <code>old</code> <code>Sequence[Any] | Mapping[Any, Any]</code> <p>Sequence of values to replace. It also accepts a mapping of values to their replacement as syntactic sugar for <code>replace_strict(old=list(mapping.keys()), new=list(mapping.values()))</code>.</p> required <code>new</code> <code>Sequence[Any] | None</code> <p>Sequence of values to replace by. Length must match the length of <code>old</code>.</p> <code>None</code> <code>return_dtype</code> <code>IntoDType | None</code> <p>The data type of the resulting expression. If set to <code>None</code> (default), the data type is determined automatically based on the other inputs.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pd.Series([3, 0, 1, 2], name=\"a\")\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).replace_strict(\n...     [0, 1, 2, 3], [\"zero\", \"one\", \"two\", \"three\"], return_dtype=nw.String\n... ).to_native()\n0    three\n1     zero\n2      one\n3      two\nName: a, dtype: object\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.rolling_mean","title":"rolling_mean","text":"<pre><code>rolling_mean(\n    window_size: int,\n    *,\n    min_samples: int | None = None,\n    center: bool = False\n) -&gt; Self\n</code></pre> <p>Apply a rolling mean (moving mean) over the values.</p> <p>A window of length <code>window_size</code> will traverse the values. The resulting values will be aggregated to their mean.</p> <p>The window at a given row will include the row itself and the <code>window_size - 1</code> elements before it.</p> <p>Parameters:</p> Name Type Description Default <code>window_size</code> <code>int</code> <p>The length of the window in number of elements. It must be a strictly positive integer.</p> required <code>min_samples</code> <code>int | None</code> <p>The number of values in the window that should be non-null before computing a result. If set to <code>None</code> (default), it will be set equal to <code>window_size</code>. If provided, it must be a strictly positive integer, and less than or equal to <code>window_size</code></p> <code>None</code> <code>center</code> <code>bool</code> <p>Set the labels at the center of the window.</p> <code>False</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pa.chunked_array([[1.0, 2.0, 3.0, 4.0]])\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).rolling_mean(\n...     window_size=2\n... ).to_native()\n&lt;pyarrow.lib.ChunkedArray object at ...&gt;\n[\n  [\n    null,\n    1.5,\n    2.5,\n    3.5\n  ]\n]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.rolling_std","title":"rolling_std","text":"<pre><code>rolling_std(\n    window_size: int,\n    *,\n    min_samples: int | None = None,\n    center: bool = False,\n    ddof: int = 1\n) -&gt; Self\n</code></pre> <p>Apply a rolling standard deviation (moving standard deviation) over the values.</p> <p>A window of length <code>window_size</code> will traverse the values. The resulting values will be aggregated to their standard deviation.</p> <p>The window at a given row will include the row itself and the <code>window_size - 1</code> elements before it.</p> <p>Parameters:</p> Name Type Description Default <code>window_size</code> <code>int</code> <p>The length of the window in number of elements. It must be a strictly positive integer.</p> required <code>min_samples</code> <code>int | None</code> <p>The number of values in the window that should be non-null before computing a result. If set to <code>None</code> (default), it will be set equal to <code>window_size</code>. If provided, it must be a strictly positive integer, and less than or equal to <code>window_size</code>.</p> <code>None</code> <code>center</code> <code>bool</code> <p>Set the labels at the center of the window.</p> <code>False</code> <code>ddof</code> <code>int</code> <p>Delta Degrees of Freedom; the divisor for a length N window is N - ddof.</p> <code>1</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pd.Series([1.0, 3.0, 1.0, 4.0])\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).rolling_std(\n...     window_size=2, min_samples=1\n... ).to_native()\n0         NaN\n1    1.414214\n2    1.414214\n3    2.121320\ndtype: float64\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.rolling_sum","title":"rolling_sum","text":"<pre><code>rolling_sum(\n    window_size: int,\n    *,\n    min_samples: int | None = None,\n    center: bool = False\n) -&gt; Self\n</code></pre> <p>Apply a rolling sum (moving sum) over the values.</p> <p>A window of length <code>window_size</code> will traverse the values. The resulting values will be aggregated to their sum.</p> <p>The window at a given row will include the row itself and the <code>window_size - 1</code> elements before it.</p> <p>Parameters:</p> Name Type Description Default <code>window_size</code> <code>int</code> <p>The length of the window in number of elements. It must be a strictly positive integer.</p> required <code>min_samples</code> <code>int | None</code> <p>The number of values in the window that should be non-null before computing a result. If set to <code>None</code> (default), it will be set equal to <code>window_size</code>. If provided, it must be a strictly positive integer, and less than or equal to <code>window_size</code></p> <code>None</code> <code>center</code> <code>bool</code> <p>Set the labels at the center of the window.</p> <code>False</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pd.Series([1.0, 2.0, 3.0, 4.0])\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).rolling_sum(\n...     window_size=2\n... ).to_native()\n0    NaN\n1    3.0\n2    5.0\n3    7.0\ndtype: float64\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.rolling_var","title":"rolling_var","text":"<pre><code>rolling_var(\n    window_size: int,\n    *,\n    min_samples: int | None = None,\n    center: bool = False,\n    ddof: int = 1\n) -&gt; Self\n</code></pre> <p>Apply a rolling variance (moving variance) over the values.</p> <p>A window of length <code>window_size</code> will traverse the values. The resulting values will be aggregated to their variance.</p> <p>The window at a given row will include the row itself and the <code>window_size - 1</code> elements before it.</p> <p>Parameters:</p> Name Type Description Default <code>window_size</code> <code>int</code> <p>The length of the window in number of elements. It must be a strictly positive integer.</p> required <code>min_samples</code> <code>int | None</code> <p>The number of values in the window that should be non-null before computing a result. If set to <code>None</code> (default), it will be set equal to <code>window_size</code>. If provided, it must be a strictly positive integer, and less than or equal to <code>window_size</code>.</p> <code>None</code> <code>center</code> <code>bool</code> <p>Set the labels at the center of the window.</p> <code>False</code> <code>ddof</code> <code>int</code> <p>Delta Degrees of Freedom; the divisor for a length N window is N - ddof.</p> <code>1</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pl.Series([1.0, 3.0, 1.0, 4.0])\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).rolling_var(\n...     window_size=2, min_samples=1\n... ).to_native()\nshape: (4,)\nSeries: '' [f64]\n[\n   null\n   2.0\n   2.0\n   4.5\n]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.round","title":"round","text":"<pre><code>round(decimals: int = 0) -&gt; Self\n</code></pre> <p>Round underlying floating point data by <code>decimals</code> digits.</p> <p>Parameters:</p> Name Type Description Default <code>decimals</code> <code>int</code> <p>Number of decimals to round by.</p> <code>0</code> Notes <p>For values exactly halfway between rounded decimal values pandas behaves differently than Polars and Arrow.</p> <p>pandas rounds to the nearest even value (e.g. -0.5 and 0.5 round to 0.0, 1.5 and 2.5 round to 2.0, 3.5 and 4.5 to 4.0, etc..).</p> <p>Polars and Arrow round away from 0 (e.g. -0.5 to -1.0, 0.5 to 1.0, 1.5 to 2.0, 2.5 to 3.0, etc..).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pl.Series([1.12345, 2.56789, 3.901234])\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.round(1).to_native()\nshape: (3,)\nSeries: '' [f64]\n[\n   1.1\n   2.6\n   3.9\n]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.sample","title":"sample","text":"<pre><code>sample(\n    n: int | None = None,\n    *,\n    fraction: float | None = None,\n    with_replacement: bool = False,\n    seed: int | None = None\n) -&gt; Self\n</code></pre> <p>Sample randomly from this Series.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int | None</code> <p>Number of items to return. Cannot be used with fraction.</p> <code>None</code> <code>fraction</code> <code>float | None</code> <p>Fraction of items to return. Cannot be used with n.</p> <code>None</code> <code>with_replacement</code> <code>bool</code> <p>Allow values to be sampled more than once.</p> <code>False</code> <code>seed</code> <code>int | None</code> <p>Seed for the random number generator. If set to None (default), a random seed is generated for each sample operation.</p> <code>None</code> Notes <p>The <code>sample</code> method returns a Series with a specified number of randomly selected items chosen from this Series. The results are not consistent across libraries.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pl.Series([1, 2, 3, 4])\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.sample(\n...     fraction=1.0, with_replacement=True\n... ).to_native()\nshape: (4,)\nSeries: '' [i64]\n[\n   1\n   4\n   3\n   4\n]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.scatter","title":"scatter","text":"<pre><code>scatter(indices: int | Sequence[int], values: Any) -&gt; Self\n</code></pre> <p>Set value(s) at given position(s).</p> <p>Parameters:</p> Name Type Description Default <code>indices</code> <code>int | Sequence[int]</code> <p>Position(s) to set items at.</p> required <code>values</code> <code>Any</code> <p>Values to set.</p> required Note <p>This method always returns a new Series, without modifying the original one. Using this function in a for-loop is an anti-pattern, we recommend building up your positions and values beforehand and doing an update in one go.</p> <p>For example, instead of</p> <pre><code>for i in [1, 3, 2]:\n    value = some_function(i)\n    s = s.scatter(i, value)\n</code></pre> <p>prefer</p> <pre><code>positions = [1, 3, 2]\nvalues = [some_function(x) for x in positions]\ns = s.scatter(positions, values)\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; df_native = pa.table({\"a\": [1, 2, 3], \"b\": [4, 5, 6]})\n&gt;&gt;&gt; df_nw = nw.from_native(df_native)\n&gt;&gt;&gt; df_nw.with_columns(df_nw[\"a\"].scatter([0, 1], [999, 888])).to_native()\npyarrow.Table\na: int64\nb: int64\n----\na: [[999,888,3]]\nb: [[4,5,6]]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.shift","title":"shift","text":"<pre><code>shift(n: int) -&gt; Self\n</code></pre> <p>Shift values by <code>n</code> positions.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Number of indices to shift forward. If a negative value is passed, values are shifted in the opposite direction instead.</p> required Notes <p>pandas may change the dtype here, for example when introducing missing values in an integer column. To ensure, that the dtype doesn't change, you may want to use <code>fill_null</code> and <code>cast</code>. For example, to shift and fill missing values with <code>0</code> in a Int64 column, you could do:</p> <pre><code>s.shift(1).fill_null(0).cast(nw.Int64)\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pd.Series([2, 4, 3])\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).shift(1).to_native()\n0    NaN\n1    2.0\n2    4.0\ndtype: float64\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.skew","title":"skew","text":"<pre><code>skew() -&gt; float | None\n</code></pre> <p>Calculate the sample skewness of the Series.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pl.Series([1, 1, 2, 10, 100])\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).skew()\n1.4724267269058975\n</code></pre> Notes <p>The skewness is a measure of the asymmetry of the probability distribution. A perfectly symmetric distribution has a skewness of 0.</p>"},{"location":"api-reference/series/#narwhals.series.Series.sort","title":"sort","text":"<pre><code>sort(\n    *, descending: bool = False, nulls_last: bool = False\n) -&gt; Self\n</code></pre> <p>Sort this Series. Place null values first.</p> <p>Parameters:</p> Name Type Description Default <code>descending</code> <code>bool</code> <p>Sort in descending order.</p> <code>False</code> <code>nulls_last</code> <code>bool</code> <p>Place null values last instead of first.</p> <code>False</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pl.Series([5, None, 1, 2])\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.sort(descending=True).to_native()\nshape: (4,)\nSeries: '' [i64]\n[\n   null\n   5\n   2\n   1\n]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.sqrt","title":"sqrt","text":"<pre><code>sqrt() -&gt; Self\n</code></pre> <p>Compute the square root.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pd.Series([1, 4, 9], name=\"a\")\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.sqrt()\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|    Narwhals Series    |\n|-----------------------|\n|0    1.0               |\n|1    2.0               |\n|2    3.0               |\n|Name: a, dtype: float64|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.std","title":"std","text":"<pre><code>std(*, ddof: int = 1) -&gt; float\n</code></pre> <p>Get the standard deviation of this Series.</p> <p>Parameters:</p> Name Type Description Default <code>ddof</code> <code>int</code> <p>\"Delta Degrees of Freedom\": the divisor used in the calculation is N - ddof,     where N represents the number of elements.</p> <code>1</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pl.Series([1, 2, 3])\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).std()\n1.0\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.sum","title":"sum","text":"<pre><code>sum() -&gt; float\n</code></pre> <p>Reduce this Series to the sum value.</p> <p>If there are no non-null elements, the result is zero.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pa.chunked_array([[1, 2, 3]])\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).sum()\n6\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.tail","title":"tail","text":"<pre><code>tail(n: int = 10) -&gt; Self\n</code></pre> <p>Get the last <code>n</code> rows.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Number of rows to return.</p> <code>10</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pa.chunked_array([list(range(10))])\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.tail(3).to_native()\n&lt;pyarrow.lib.ChunkedArray object at ...&gt;\n[\n  [\n    7,\n    8,\n    9\n  ]\n]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.to_arrow","title":"to_arrow","text":"<pre><code>to_arrow() -&gt; pa.Array[Any]\n</code></pre> <p>Convert to arrow.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pl.Series([1, 2, 3, 4])\n&gt;&gt;&gt; nw.from_native(\n...     s_native, series_only=True\n... ).to_arrow()\n&lt;pyarrow.lib.Int64Array object at ...&gt;\n[\n    1,\n    2,\n    3,\n    4\n]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.to_dummies","title":"to_dummies","text":"<pre><code>to_dummies(\n    *, separator: str = \"_\", drop_first: bool = False\n) -&gt; DataFrame[Any]\n</code></pre> <p>Get dummy/indicator variables.</p> <p>Parameters:</p> Name Type Description Default <code>separator</code> <code>str</code> <p>Separator/delimiter used when generating column names.</p> <code>'_'</code> <code>drop_first</code> <code>bool</code> <p>Remove the first category from the variable being encoded.</p> <code>False</code> Notes <p>pandas and Polars handle null values differently. Polars distinguishes between NaN and Null, whereas pandas doesn't.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pd.Series([1, 2, 3], name=\"a\")\n&gt;&gt;&gt; s_nw = nw.from_native(s_native, series_only=True)\n</code></pre> <pre><code>&gt;&gt;&gt; s_nw.to_dummies(drop_first=False).to_native()\n   a_1  a_2  a_3\n0    1    0    0\n1    0    1    0\n2    0    0    1\n</code></pre> <pre><code>&gt;&gt;&gt; s_nw.to_dummies(drop_first=True).to_native()\n   a_2  a_3\n0    0    0\n1    1    0\n2    0    1\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.to_frame","title":"to_frame","text":"<pre><code>to_frame() -&gt; DataFrame[Any]\n</code></pre> <p>Convert to dataframe.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pl.Series(\"a\", [1, 2])\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).to_frame().to_native()\nshape: (2, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2502\n\u2502 --- \u2502\n\u2502 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2502\n\u2502 2   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.to_list","title":"to_list","text":"<pre><code>to_list() -&gt; list[Any]\n</code></pre> <p>Convert to list.</p> Notes <p>This function converts to Python scalars. It's typically more efficient to keep your data in the format native to your original dataframe, so we recommend only calling this when you absolutely need to.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pa.chunked_array([[1, 2, 3]])\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).to_list()\n[1, 2, 3]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.to_native","title":"to_native","text":"<pre><code>to_native() -&gt; IntoSeriesT\n</code></pre> <p>Convert Narwhals series to native series.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pl.Series([1, 2])\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.to_native()\nshape: (2,)\nSeries: '' [i64]\n[\n  1\n  2\n]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.to_numpy","title":"to_numpy","text":"<pre><code>to_numpy() -&gt; _1DArray\n</code></pre> <p>Convert to numpy.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pd.Series([1, 2, 3], name=\"a\")\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).to_numpy()\narray([1, 2, 3]...)\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.to_pandas","title":"to_pandas","text":"<pre><code>to_pandas() -&gt; pd.Series[Any]\n</code></pre> <p>Convert to pandas Series.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pl.Series(\"a\", [1, 2, 3])\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).to_pandas()\n0    1\n1    2\n2    3\nName: a, dtype: int64\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.to_polars","title":"to_polars","text":"<pre><code>to_polars() -&gt; pl.Series\n</code></pre> <p>Convert to polars Series.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pa.chunked_array([[1, 2, 3]])\n&gt;&gt;&gt; nw.from_native(\n...     s_native, series_only=True\n... ).to_polars()\nshape: (3,)\nSeries: '' [i64]\n[\n    1\n    2\n    3\n]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.unique","title":"unique","text":"<pre><code>unique(*, maintain_order: bool = False) -&gt; Self\n</code></pre> <p>Returns unique values of the series.</p> <p>Parameters:</p> Name Type Description Default <code>maintain_order</code> <code>bool</code> <p>Keep the same order as the original series. This may be more expensive to compute. Settings this to <code>True</code> blocks the possibility to run on the streaming engine for Polars.</p> <code>False</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pl.Series([2, 4, 4, 6])\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.unique(\n...     maintain_order=True\n... ).to_native()\nshape: (3,)\nSeries: '' [i64]\n[\n   2\n   4\n   6\n]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.value_counts","title":"value_counts","text":"<pre><code>value_counts(\n    *,\n    sort: bool = False,\n    parallel: bool = False,\n    name: str | None = None,\n    normalize: bool = False\n) -&gt; DataFrame[Any]\n</code></pre> <p>Count the occurrences of unique values.</p> <p>Parameters:</p> Name Type Description Default <code>sort</code> <code>bool</code> <p>Sort the output by count in descending order. If set to False (default), the order of the output is random.</p> <code>False</code> <code>parallel</code> <code>bool</code> <p>Execute the computation in parallel. Used for Polars only.</p> <code>False</code> <code>name</code> <code>str | None</code> <p>Give the resulting count column a specific name; if <code>normalize</code> is True defaults to \"proportion\", otherwise defaults to \"count\".</p> <code>None</code> <code>normalize</code> <code>bool</code> <p>If true gives relative frequencies of the unique values</p> <ul> <li>The original values as first column</li> <li>Either count or proportion as second column, depending on normalize parameter.</li> </ul> <code>False</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pd.Series([1, 1, 2, 3, 2], name=\"s\")\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).value_counts(\n...     sort=True\n... ).to_native()\n   s  count\n0  1      2\n1  2      2\n2  3      1\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.var","title":"var","text":"<pre><code>var(*, ddof: int = 1) -&gt; float\n</code></pre> <p>Get the variance of this Series.</p> <p>Parameters:</p> Name Type Description Default <code>ddof</code> <code>int</code> <p>\"Delta Degrees of Freedom\": the divisor used in the calculation is N - ddof,     where N represents the number of elements.</p> <code>1</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pa.chunked_array([[1, 2, 3]])\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).var()\n1.0\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.zip_with","title":"zip_with","text":"<pre><code>zip_with(mask: Self, other: Self) -&gt; Self\n</code></pre> <p>Take values from self or other based on the given mask.</p> <p>Where mask evaluates true, take values from self. Where mask evaluates false, take values from other.</p> <p>Parameters:</p> Name Type Description Default <code>mask</code> <code>Self</code> <p>Boolean Series</p> required <code>other</code> <code>Self</code> <p>Series of same type.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data_native = pa.chunked_array([[1, 2, 3, 4, 5]])\n&gt;&gt;&gt; other_native = pa.chunked_array([[5, 4, 3, 2, 1]])\n&gt;&gt;&gt; mask_native = pa.chunked_array([[True, False, True, False, True]])\n&gt;&gt;&gt;\n&gt;&gt;&gt; data_nw = nw.from_native(data_native, series_only=True)\n&gt;&gt;&gt; other_nw = nw.from_native(other_native, series_only=True)\n&gt;&gt;&gt; mask_nw = nw.from_native(mask_native, series_only=True)\n&gt;&gt;&gt;\n&gt;&gt;&gt; data_nw.zip_with(mask_nw, other_nw).to_native()\n&lt;pyarrow.lib.ChunkedArray object at ...&gt;\n[\n  [\n    1,\n    4,\n    3,\n    2,\n    5\n  ]\n]\n</code></pre>"},{"location":"api-reference/series_cat/","title":"<code>narwhals.Series.cat</code>","text":""},{"location":"api-reference/series_cat/#narwhals.series.SeriesCatNamespace.get_categories","title":"get_categories","text":"<pre><code>get_categories() -&gt; SeriesT\n</code></pre> <p>Get unique categories from column.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pd.Series([\"apple\", \"mango\", \"mango\"], dtype=\"category\")\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.cat.get_categories().to_native()\n0    apple\n1    mango\ndtype: object\n</code></pre>"},{"location":"api-reference/series_dt/","title":"<code>narwhals.Series.dt</code>","text":""},{"location":"api-reference/series_dt/#narwhals.series.SeriesDateTimeNamespace.convert_time_zone","title":"convert_time_zone","text":"<pre><code>convert_time_zone(time_zone: str) -&gt; SeriesT\n</code></pre> <p>Convert time zone.</p> <p>If converting from a time-zone-naive column, then conversion happens as if converting from UTC.</p> <p>Parameters:</p> Name Type Description Default <code>time_zone</code> <code>str</code> <p>Target time zone.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime, timezone\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pd.Series(\n...     [\n...         datetime(2024, 1, 1, tzinfo=timezone.utc),\n...         datetime(2024, 1, 2, tzinfo=timezone.utc),\n...     ]\n... )\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.dt.convert_time_zone(\"Asia/Kathmandu\").to_native()\n0   2024-01-01 05:45:00+05:45\n1   2024-01-02 05:45:00+05:45\ndtype: datetime64[ns, Asia/Kathmandu]\n</code></pre>"},{"location":"api-reference/series_dt/#narwhals.series.SeriesDateTimeNamespace.date","title":"date","text":"<pre><code>date() -&gt; SeriesT\n</code></pre> <p>Get the date in a datetime series.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If pandas default backend is being used.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pd.Series(\n...     [datetime(2012, 1, 7, 10, 20), datetime(2023, 3, 10, 11, 32)]\n... ).convert_dtypes(dtype_backend=\"pyarrow\")\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.dt.date().to_native()\n0    2012-01-07\n1    2023-03-10\ndtype: date32[day][pyarrow]\n</code></pre>"},{"location":"api-reference/series_dt/#narwhals.series.SeriesDateTimeNamespace.day","title":"day","text":"<pre><code>day() -&gt; SeriesT\n</code></pre> <p>Extracts the day in a datetime series.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pa.chunked_array(\n...     [[datetime(2022, 1, 1), datetime(2022, 1, 5)]]\n... )\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.dt.day().to_native()\n&lt;pyarrow.lib.ChunkedArray object at ...&gt;\n[\n  [\n    1,\n    5\n  ]\n]\n</code></pre>"},{"location":"api-reference/series_dt/#narwhals.series.SeriesDateTimeNamespace.hour","title":"hour","text":"<pre><code>hour() -&gt; SeriesT\n</code></pre> <p>Extracts the hour in a datetime series.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pa.chunked_array(\n...     [[datetime(2022, 1, 1, 5, 3), datetime(2022, 1, 5, 9, 12)]]\n... )\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.dt.hour().to_native()\n&lt;pyarrow.lib.ChunkedArray object at ...&gt;\n[\n  [\n    5,\n    9\n  ]\n]\n</code></pre>"},{"location":"api-reference/series_dt/#narwhals.series.SeriesDateTimeNamespace.microsecond","title":"microsecond","text":"<pre><code>microsecond() -&gt; SeriesT\n</code></pre> <p>Extracts the microseconds in a datetime series.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pd.Series(\n...     [\n...         datetime(2022, 1, 1, 5, 3, 7, 400000),\n...         datetime(2022, 1, 1, 5, 3, 7, 0),\n...     ]\n... )\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.dt.microsecond().alias(\"datetime\").to_native()\n0    400000\n1         0\nName: datetime, dtype: int32\n</code></pre>"},{"location":"api-reference/series_dt/#narwhals.series.SeriesDateTimeNamespace.millisecond","title":"millisecond","text":"<pre><code>millisecond() -&gt; SeriesT\n</code></pre> <p>Extracts the milliseconds in a datetime series.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pd.Series(\n...     [\n...         datetime(2022, 1, 1, 5, 3, 7, 400000),\n...         datetime(2022, 1, 1, 5, 3, 7, 0),\n...     ]\n... )\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.dt.millisecond().alias(\"datetime\").to_native()\n0    400\n1      0\nName: datetime, dtype: int32\n</code></pre>"},{"location":"api-reference/series_dt/#narwhals.series.SeriesDateTimeNamespace.minute","title":"minute","text":"<pre><code>minute() -&gt; SeriesT\n</code></pre> <p>Extracts the minute in a datetime series.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pd.Series(\n...     [datetime(2022, 1, 1, 5, 3), datetime(2022, 1, 5, 9, 12)]\n... )\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.dt.minute().to_native()\n0     3\n1    12\ndtype: int32\n</code></pre>"},{"location":"api-reference/series_dt/#narwhals.series.SeriesDateTimeNamespace.month","title":"month","text":"<pre><code>month() -&gt; SeriesT\n</code></pre> <p>Gets the month in a datetime series.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pl.Series([datetime(2012, 1, 7), datetime(2023, 3, 10)])\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.dt.month().to_native()\nshape: (2,)\nSeries: '' [i8]\n[\n        1\n        3\n]\n</code></pre>"},{"location":"api-reference/series_dt/#narwhals.series.SeriesDateTimeNamespace.nanosecond","title":"nanosecond","text":"<pre><code>nanosecond() -&gt; SeriesT\n</code></pre> <p>Extract the nanoseconds in a date series.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pd.Series(\n...     [\n...         datetime(2022, 1, 1, 5, 3, 7, 400000),\n...         datetime(2022, 1, 1, 5, 3, 7, 0),\n...     ]\n... )\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.dt.nanosecond().alias(\"datetime\").to_native()\n0    400000000\n1            0\nName: datetime, dtype: int32\n</code></pre>"},{"location":"api-reference/series_dt/#narwhals.series.SeriesDateTimeNamespace.offset_by","title":"offset_by","text":"<pre><code>offset_by(by: str) -&gt; SeriesT\n</code></pre> <p>Offset this date by a relative time offset.</p> <p>Parameters:</p> Name Type Description Default <code>by</code> <code>str</code> <p>The offset. Must be of form <code>&lt;multiple&gt;&lt;unit&gt;</code>, where <code>multiple</code> is a positive integer and <code>unit</code> is one of</p> <ul> <li>'ns': nanosecond.</li> <li>'us': microsecond.</li> <li>'ms': millisecond.</li> <li>'s': second.</li> <li>'m': minute.</li> <li>'h': hour.</li> <li>'d': day.</li> <li>'mo': month.</li> <li>'q': quarter.</li> <li>'y': year.</li> </ul> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pd.Series([datetime(2021, 3, 1, 12, 34)])\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.dt.offset_by(\"1h\").to_native()\n0   2021-03-01 13:34:00\ndtype: datetime64[ns]\n</code></pre>"},{"location":"api-reference/series_dt/#narwhals.series.SeriesDateTimeNamespace.ordinal_day","title":"ordinal_day","text":"<pre><code>ordinal_day() -&gt; SeriesT\n</code></pre> <p>Get ordinal day.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pa.chunked_array(\n...     [[datetime(2020, 1, 1), datetime(2020, 8, 3)]]\n... )\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.dt.ordinal_day().to_native()\n&lt;pyarrow.lib.ChunkedArray object at ...&gt;\n[\n  [\n    1,\n    216\n  ]\n]\n</code></pre>"},{"location":"api-reference/series_dt/#narwhals.series.SeriesDateTimeNamespace.replace_time_zone","title":"replace_time_zone","text":"<pre><code>replace_time_zone(time_zone: str | None) -&gt; SeriesT\n</code></pre> <p>Replace time zone.</p> <p>Parameters:</p> Name Type Description Default <code>time_zone</code> <code>str | None</code> <p>Target time zone.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime, timezone\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pl.Series(\n...     [\n...         datetime(2024, 1, 1, tzinfo=timezone.utc),\n...         datetime(2024, 1, 2, tzinfo=timezone.utc),\n...     ]\n... )\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.dt.replace_time_zone(\n...     \"Asia/Kathmandu\"\n... ).to_native()\nshape: (2,)\nSeries: '' [datetime[\u03bcs, Asia/Kathmandu]]\n[\n        2024-01-01 00:00:00 +0545\n        2024-01-02 00:00:00 +0545\n]\n</code></pre>"},{"location":"api-reference/series_dt/#narwhals.series.SeriesDateTimeNamespace.second","title":"second","text":"<pre><code>second() -&gt; SeriesT\n</code></pre> <p>Extracts the seconds in a datetime series.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pd.Series(\n...     [datetime(2022, 1, 1, 5, 3, 10), datetime(2022, 1, 5, 9, 12, 4)]\n... )\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.dt.second().to_native()\n0    10\n1     4\ndtype: int32\n</code></pre>"},{"location":"api-reference/series_dt/#narwhals.series.SeriesDateTimeNamespace.timestamp","title":"timestamp","text":"<pre><code>timestamp(time_unit: TimeUnit) -&gt; SeriesT\n</code></pre> <p>Return a timestamp in the given time unit.</p> <p>Parameters:</p> Name Type Description Default <code>time_unit</code> <code>TimeUnit</code> <p>One of - 'ns': nanosecond. - 'us': microsecond. - 'ms': millisecond.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import date\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pd.Series(\n...     [date(2001, 1, 1), None, date(2001, 1, 3)], dtype=\"datetime64[ns]\"\n... )\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.dt.timestamp(\"ms\").to_native()\n0    9.783072e+11\n1             NaN\n2    9.784800e+11\ndtype: float64\n</code></pre>"},{"location":"api-reference/series_dt/#narwhals.series.SeriesDateTimeNamespace.to_string","title":"to_string","text":"<pre><code>to_string(format: str) -&gt; SeriesT\n</code></pre> <p>Convert a Date/Time/Datetime series into a String series with the given format.</p> <p>Parameters:</p> Name Type Description Default <code>format</code> <code>str</code> <p>Format string for converting the datetime to string.</p> required Notes <p>Unfortunately, different libraries interpret format directives a bit differently.</p> <ul> <li>Chrono, the library used by Polars, uses <code>\"%.f\"</code> for fractional seconds,   whereas pandas and Python stdlib use <code>\".%f\"</code>.</li> <li>PyArrow interprets <code>\"%S\"</code> as \"seconds, including fractional seconds\"   whereas most other tools interpret it as \"just seconds, as 2 digits\".</li> </ul> <p>Therefore, we make the following adjustments.</p> <ul> <li>for pandas-like libraries, we replace <code>\"%S.%f\"</code> with <code>\"%S%.f\"</code>.</li> <li>for PyArrow, we replace <code>\"%S.%f\"</code> with <code>\"%S\"</code>.</li> </ul> <p>Workarounds like these don't make us happy, and we try to avoid them as much as possible, but here we feel like it's the best compromise.</p> <p>If you just want to format a date/datetime Series as a local datetime string, and have it work as consistently as possible across libraries, we suggest using:</p> <ul> <li><code>\"%Y-%m-%dT%H:%M:%S%.f\"</code> for datetimes</li> <li><code>\"%Y-%m-%d\"</code> for dates</li> </ul> <p>Though note that, even then, different tools may return a different number of trailing zeros. Nonetheless, this is probably consistent enough for most applications.</p> <p>If you have an application where this is not enough, please open an issue and let us know.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pd.Series([datetime(2020, 3, 1), datetime(2020, 4, 1)])\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.dt.to_string(\"%Y/%m/%d\")\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals Series|\n|---------------|\n|0    2020/03/01|\n|1    2020/04/01|\n|dtype: object  |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/series_dt/#narwhals.series.SeriesDateTimeNamespace.total_microseconds","title":"total_microseconds","text":"<pre><code>total_microseconds() -&gt; SeriesT\n</code></pre> <p>Get total microseconds.</p> Notes <p>The function outputs the total microseconds in the int dtype by default, however, pandas may change the dtype to float when there are missing values, consider using <code>fill_null()</code> in this case.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import timedelta\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pl.Series(\n...     [\n...         timedelta(microseconds=10),\n...         timedelta(milliseconds=1, microseconds=200),\n...     ]\n... )\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.dt.total_microseconds().to_native()\nshape: (2,)\nSeries: '' [i64]\n[\n        10\n        1200\n]\n</code></pre>"},{"location":"api-reference/series_dt/#narwhals.series.SeriesDateTimeNamespace.total_milliseconds","title":"total_milliseconds","text":"<pre><code>total_milliseconds() -&gt; SeriesT\n</code></pre> <p>Get total milliseconds.</p> Notes <p>The function outputs the total milliseconds in the int dtype by default, however, pandas may change the dtype to float when there are missing values, consider using <code>fill_null()</code> in this case.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import timedelta\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pl.Series(\n...     [\n...         timedelta(milliseconds=10),\n...         timedelta(milliseconds=20, microseconds=40),\n...     ]\n... )\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.dt.total_milliseconds().to_native()\nshape: (2,)\nSeries: '' [i64]\n[\n        10\n        20\n]\n</code></pre>"},{"location":"api-reference/series_dt/#narwhals.series.SeriesDateTimeNamespace.total_minutes","title":"total_minutes","text":"<pre><code>total_minutes() -&gt; SeriesT\n</code></pre> <p>Get total minutes.</p> Notes <p>The function outputs the total minutes in the int dtype by default, however, pandas may change the dtype to float when there are missing values, consider using <code>fill_null()</code> in this case.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import timedelta\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pl.Series(\n...     [timedelta(minutes=10), timedelta(minutes=20, seconds=40)]\n... )\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.dt.total_minutes().to_native()\nshape: (2,)\nSeries: '' [i64]\n[\n        10\n        20\n]\n</code></pre>"},{"location":"api-reference/series_dt/#narwhals.series.SeriesDateTimeNamespace.total_nanoseconds","title":"total_nanoseconds","text":"<pre><code>total_nanoseconds() -&gt; SeriesT\n</code></pre> <p>Get total nanoseconds.</p> Notes <p>The function outputs the total nanoseconds in the int dtype by default, however, pandas may change the dtype to float when there are missing values, consider using <code>fill_null()</code> in this case.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pl.Series(\n...     [\"2024-01-01 00:00:00.000000001\", \"2024-01-01 00:00:00.000000002\"]\n... ).str.to_datetime(time_unit=\"ns\")\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.diff().dt.total_nanoseconds().to_native()\nshape: (2,)\nSeries: '' [i64]\n[\n        null\n        1\n]\n</code></pre>"},{"location":"api-reference/series_dt/#narwhals.series.SeriesDateTimeNamespace.total_seconds","title":"total_seconds","text":"<pre><code>total_seconds() -&gt; SeriesT\n</code></pre> <p>Get total seconds.</p> Notes <p>The function outputs the total seconds in the int dtype by default, however, pandas may change the dtype to float when there are missing values, consider using <code>fill_null()</code> in this case.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import timedelta\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pl.Series(\n...     [timedelta(minutes=10), timedelta(minutes=20, seconds=40)]\n... )\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.dt.total_seconds().to_native()\nshape: (2,)\nSeries: '' [i64]\n[\n        600\n        1240\n]\n</code></pre>"},{"location":"api-reference/series_dt/#narwhals.series.SeriesDateTimeNamespace.truncate","title":"truncate","text":"<pre><code>truncate(every: str) -&gt; SeriesT\n</code></pre> <p>Divide the date/datetime range into buckets.</p> <p>Parameters:</p> Name Type Description Default <code>every</code> <code>str</code> <p>Length of bucket. Must be of form <code>&lt;multiple&gt;&lt;unit&gt;</code>, where <code>multiple</code> is a positive integer and <code>unit</code> is one of</p> <ul> <li>'ns': nanosecond.</li> <li>'us': microsecond.</li> <li>'ms': millisecond.</li> <li>'s': second.</li> <li>'m': minute.</li> <li>'h': hour.</li> <li>'d': day.</li> <li>'mo': month.</li> <li>'q': quarter.</li> <li>'y': year.</li> </ul> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pd.Series([datetime(2021, 3, 1, 12, 34)])\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.dt.truncate(\"1h\").to_native()\n0   2021-03-01 12:00:00\ndtype: datetime64[ns]\n</code></pre>"},{"location":"api-reference/series_dt/#narwhals.series.SeriesDateTimeNamespace.weekday","title":"weekday","text":"<pre><code>weekday() -&gt; SeriesT\n</code></pre> <p>Extract the week day in a datetime series.</p> <p>Note that Monday = 1 and Sunday = 7.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pa.chunked_array(\n...     [[datetime(2020, 1, 1), datetime(2020, 8, 3)]]\n... )\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.dt.weekday().to_native()\n&lt;pyarrow.lib.ChunkedArray object at ...&gt;\n[\n  [\n    3,\n    1\n  ]\n]\n</code></pre>"},{"location":"api-reference/series_dt/#narwhals.series.SeriesDateTimeNamespace.year","title":"year","text":"<pre><code>year() -&gt; SeriesT\n</code></pre> <p>Get the year in a datetime series.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pl.Series([datetime(2012, 1, 7), datetime(2023, 3, 10)])\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.dt.year().to_native()\nshape: (2,)\nSeries: '' [i32]\n[\n        2012\n        2023\n]\n</code></pre>"},{"location":"api-reference/series_list/","title":"<code>narwhals.Series.list</code>","text":""},{"location":"api-reference/series_list/#narwhals.series.SeriesListNamespace.contains","title":"contains","text":"<pre><code>contains(item: NonNestedLiteral) -&gt; SeriesT\n</code></pre> <p>Check if sublists contain the given item.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>NonNestedLiteral</code> <p>Item that will be checked for membership.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pl.Series([[1, 2], None, []])\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.list.contains(1).to_native()\nshape: (3,)\nSeries: '' [bool]\n[\n        true\n        null\n        false\n]\n</code></pre>"},{"location":"api-reference/series_list/#narwhals.series.SeriesListNamespace.get","title":"get","text":"<pre><code>get(index: int) -&gt; SeriesT\n</code></pre> <p>Return the value by index in each list.</p> <p>Negative indices are not accepted.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pl.Series([[1, 2], [3, 4, None], [None, 5]])\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.list.get(1).to_native()\nshape: (3,)\nSeries: '' [i64]\n[\n        2\n        4\n        5\n]\n</code></pre>"},{"location":"api-reference/series_list/#narwhals.series.SeriesListNamespace.len","title":"len","text":"<pre><code>len() -&gt; SeriesT\n</code></pre> <p>Return the number of elements in each list.</p> <p>Null values count towards the total.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pa.chunked_array([[[1, 2], [3, 4, None], None, []]])\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.list.len().to_native()\n&lt;pyarrow.lib.ChunkedArray object at ...&gt;\n[\n  [\n    2,\n    3,\n    null,\n    0\n  ]\n]\n</code></pre>"},{"location":"api-reference/series_list/#narwhals.series.SeriesListNamespace.unique","title":"unique","text":"<pre><code>unique() -&gt; SeriesT\n</code></pre> <p>Get the unique/distinct values in the list.</p> <p>Null values are included in the result. The order of unique values is not guaranteed.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pl.Series([[1, 1, 2], [3, 3, None], None, []])\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.list.unique().to_native()\nshape: (4,)\nSeries: '' [list[i64]]\n[\n   [1, 2]\n   [null, 3]\n   null\n   []\n]\n</code></pre>"},{"location":"api-reference/series_str/","title":"<code>narwhals.Series.str</code>","text":""},{"location":"api-reference/series_str/#narwhals.series.SeriesStringNamespace.contains","title":"contains","text":"<pre><code>contains(pattern: str, *, literal: bool = False) -&gt; SeriesT\n</code></pre> <p>Check if string contains a substring that matches a pattern.</p> <p>Parameters:</p> Name Type Description Default <code>pattern</code> <code>str</code> <p>A Character sequence or valid regular expression pattern.</p> required <code>literal</code> <code>bool</code> <p>If True, treats the pattern as a literal string.      If False, assumes the pattern is a regular expression.</p> <code>False</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pa.chunked_array([[\"cat\", \"dog\", \"rabbit and parrot\"]])\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.str.contains(\"cat|parrot\").to_native()\n&lt;pyarrow.lib.ChunkedArray object at ...&gt;\n[\n  [\n    true,\n    false,\n    true\n  ]\n]\n</code></pre>"},{"location":"api-reference/series_str/#narwhals.series.SeriesStringNamespace.ends_with","title":"ends_with","text":"<pre><code>ends_with(suffix: str) -&gt; SeriesT\n</code></pre> <p>Check if string values end with a substring.</p> <p>Parameters:</p> Name Type Description Default <code>suffix</code> <code>str</code> <p>suffix substring</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pd.Series([\"apple\", \"mango\", None])\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.str.ends_with(\"ngo\").to_native()\n0    False\n1     True\n2     None\ndtype: object\n</code></pre>"},{"location":"api-reference/series_str/#narwhals.series.SeriesStringNamespace.head","title":"head","text":"<pre><code>head(n: int = 5) -&gt; SeriesT\n</code></pre> <p>Take the first n elements of each string.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Number of elements to take. Negative indexing is supported (see note (1.))</p> <code>5</code> Notes <ol> <li>When the <code>n</code> input is negative, <code>head</code> returns characters up to the n-th from the end of the string. For example, if <code>n = -3</code>, then all characters except the last three are returned.</li> <li>If the length of the string has fewer than <code>n</code> characters, the full string is returned.</li> </ol> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pa.chunked_array([[\"taata\", \"taatatata\", \"zukkyun\"]])\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.str.head().to_native()\n&lt;pyarrow.lib.ChunkedArray object at ...&gt;\n[\n  [\n    \"taata\",\n    \"taata\",\n    \"zukky\"\n  ]\n]\n</code></pre>"},{"location":"api-reference/series_str/#narwhals.series.SeriesStringNamespace.len_chars","title":"len_chars","text":"<pre><code>len_chars() -&gt; SeriesT\n</code></pre> <p>Return the length of each string as the number of characters.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pl.Series([\"foo\", \"345\", None])\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.str.len_chars().to_native()\nshape: (3,)\nSeries: '' [u32]\n[\n        3\n        3\n        null\n]\n</code></pre>"},{"location":"api-reference/series_str/#narwhals.series.SeriesStringNamespace.replace","title":"replace","text":"<pre><code>replace(\n    pattern: str,\n    value: str | SeriesT,\n    *,\n    literal: bool = False,\n    n: int = 1\n) -&gt; SeriesT\n</code></pre> <p>Replace first matching regex/literal substring with a new string value.</p> <p>Parameters:</p> Name Type Description Default <code>pattern</code> <code>str</code> <p>A valid regular expression pattern.</p> required <code>value</code> <code>str | SeriesT</code> <p>String that will replace the matched substring.</p> required <code>literal</code> <code>bool</code> <p>Treat <code>pattern</code> as a literal string.</p> <code>False</code> <code>n</code> <code>int</code> <p>Number of matches to replace.</p> <code>1</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pd.Series([\"123abc\", \"abc abc123\"])\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.str.replace(\"abc\", \"\").to_native()\n0        123\n1     abc123\ndtype: object\n</code></pre>"},{"location":"api-reference/series_str/#narwhals.series.SeriesStringNamespace.replace_all","title":"replace_all","text":"<pre><code>replace_all(\n    pattern: str,\n    value: str | SeriesT,\n    *,\n    literal: bool = False\n) -&gt; SeriesT\n</code></pre> <p>Replace all matching regex/literal substring with a new string value.</p> <p>Parameters:</p> Name Type Description Default <code>pattern</code> <code>str</code> <p>A valid regular expression pattern.</p> required <code>value</code> <code>str | SeriesT</code> <p>String that will replace the matched substring.</p> required <code>literal</code> <code>bool</code> <p>Treat <code>pattern</code> as a literal string.</p> <code>False</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pd.Series([\"123abc\", \"abc abc123\"])\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.str.replace_all(\"abc\", \"\").to_native()\n0     123\n1     123\ndtype: object\n</code></pre>"},{"location":"api-reference/series_str/#narwhals.series.SeriesStringNamespace.slice","title":"slice","text":"<pre><code>slice(offset: int, length: int | None = None) -&gt; SeriesT\n</code></pre> <p>Create subslices of the string values of a Series.</p> <p>Parameters:</p> Name Type Description Default <code>offset</code> <code>int</code> <p>Start index. Negative indexing is supported.</p> required <code>length</code> <code>int | None</code> <p>Length of the slice. If set to <code>None</code> (default), the slice is taken to the end of the string.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pd.Series([\"pear\", None, \"papaya\"])\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.str.slice(4, 3).to_native()\n0\n1    None\n2      ya\ndtype: object\n</code></pre>"},{"location":"api-reference/series_str/#narwhals.series.SeriesStringNamespace.split","title":"split","text":"<pre><code>split(by: str) -&gt; SeriesT\n</code></pre> <p>Split the string values of a Series by a substring.</p> <p>Parameters:</p> Name Type Description Default <code>by</code> <code>str</code> <p>Substring to split by.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pl.Series([\"foo bar\", \"foo_bar\"])\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.str.split(\"_\").to_native()\nshape: (2,)\nSeries: '' [list[str]]\n[\n        [\"foo bar\"]\n        [\"foo\", \"bar\"]\n]\n</code></pre>"},{"location":"api-reference/series_str/#narwhals.series.SeriesStringNamespace.starts_with","title":"starts_with","text":"<pre><code>starts_with(prefix: str) -&gt; SeriesT\n</code></pre> <p>Check if string values start with a substring.</p> <p>Parameters:</p> Name Type Description Default <code>prefix</code> <code>str</code> <p>prefix substring</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pd.Series([\"apple\", \"mango\", None])\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.str.starts_with(\"app\").to_native()\n0     True\n1    False\n2     None\ndtype: object\n</code></pre>"},{"location":"api-reference/series_str/#narwhals.series.SeriesStringNamespace.strip_chars","title":"strip_chars","text":"<pre><code>strip_chars(characters: str | None = None) -&gt; SeriesT\n</code></pre> <p>Remove leading and trailing characters.</p> <p>Parameters:</p> Name Type Description Default <code>characters</code> <code>str | None</code> <p>The set of characters to be removed. All combinations of this set of characters will be stripped from the start and end of the string. If set to None (default), all leading and trailing whitespace is removed instead.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pl.Series([\"apple\", \"\\nmango\"])\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.str.strip_chars().to_native()\nshape: (2,)\nSeries: '' [str]\n[\n        \"apple\"\n        \"mango\"\n]\n</code></pre>"},{"location":"api-reference/series_str/#narwhals.series.SeriesStringNamespace.tail","title":"tail","text":"<pre><code>tail(n: int = 5) -&gt; SeriesT\n</code></pre> <p>Take the last n elements of each string.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Number of elements to take. Negative indexing is supported (see note (1.))</p> <code>5</code> Notes <ol> <li>When the <code>n</code> input is negative, <code>tail</code> returns characters starting from the n-th from the beginning of the string. For example, if <code>n = -3</code>, then all characters except the first three are returned.</li> <li>If the length of the string has fewer than <code>n</code> characters, the full string is returned.</li> </ol> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pa.chunked_array([[\"taata\", \"taatatata\", \"zukkyun\"]])\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.str.tail().to_native()\n&lt;pyarrow.lib.ChunkedArray object at ...&gt;\n[\n  [\n    \"taata\",\n    \"atata\",\n    \"kkyun\"\n  ]\n]\n</code></pre>"},{"location":"api-reference/series_str/#narwhals.series.SeriesStringNamespace.to_date","title":"to_date","text":"<pre><code>to_date(format: str | None = None) -&gt; SeriesT\n</code></pre> <p>Convert to date dtype.</p> Warning <p>As different backends auto-infer format in different ways, if <code>format=None</code> there is no guarantee that the result will be equal.</p> <p>Parameters:</p> Name Type Description Default <code>format</code> <code>str | None</code> <p>Format to use for conversion. If set to None (default), the format is inferred from the data.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pa.chunked_array([[\"2020-01-01\", \"2020-01-02\"]])\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.str.to_date(format=\"%Y-%m-%d\").to_native()\n&lt;pyarrow.lib.ChunkedArray object at ...&gt;\n[\n  [\n    2020-01-01,\n    2020-01-02\n  ]\n]\n</code></pre>"},{"location":"api-reference/series_str/#narwhals.series.SeriesStringNamespace.to_datetime","title":"to_datetime","text":"<pre><code>to_datetime(format: str | None = None) -&gt; SeriesT\n</code></pre> <p>Parse Series with strings to a Series with Datetime dtype.</p> Notes <ul> <li>pandas defaults to nanosecond time unit, Polars to microsecond.   Prior to pandas 2.0, nanoseconds were the only time unit supported   in pandas, with no ability to set any other one. The ability to   set the time unit in pandas, if the version permits, will arrive.</li> <li>timezone-aware strings are all converted to and parsed as UTC.</li> </ul> Warning <p>As different backends auto-infer format in different ways, if <code>format=None</code> there is no guarantee that the result will be equal.</p> <p>Parameters:</p> Name Type Description Default <code>format</code> <code>str | None</code> <p>Format to use for conversion. If set to None (default), the format is inferred from the data.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pl.Series([\"2020-01-01\", \"2020-01-02\"])\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.str.to_datetime(\n...     format=\"%Y-%m-%d\"\n... ).to_native()\nshape: (2,)\nSeries: '' [datetime[\u03bcs]]\n[\n        2020-01-01 00:00:00\n        2020-01-02 00:00:00\n]\n</code></pre>"},{"location":"api-reference/series_str/#narwhals.series.SeriesStringNamespace.to_lowercase","title":"to_lowercase","text":"<pre><code>to_lowercase() -&gt; SeriesT\n</code></pre> <p>Transform string to lowercase variant.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pd.Series([\"APPLE\", None])\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.str.to_lowercase().to_native()\n0    apple\n1     None\ndtype: object\n</code></pre>"},{"location":"api-reference/series_str/#narwhals.series.SeriesStringNamespace.to_titlecase","title":"to_titlecase","text":"<pre><code>to_titlecase() -&gt; SeriesT\n</code></pre> <p>Modify strings to their titlecase equivalent.</p> Notes <p>This is a form of case transform where the first letter of each word is capitalized, with the rest of the word in lowercase.</p> <p>Word boundaries are defined by non-alphabetic characters, matching the behavior of <code>str.title</code></p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pa.chunked_array(\n...     [\n...         [\n...             \"'e.t. phone home'\",\n...             \"you talkin' to me?\",\n...             \"to infinity,and BEYOND!\",\n...         ]\n...     ]\n... )\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.str.to_titlecase().to_native()\n&lt;pyarrow.lib.ChunkedArray object at ...&gt;\n[\n  [\n    \"'E.T. Phone Home'\",\n    \"You Talkin' To Me?\",\n    \"To Infinity,And Beyond!\"\n  ]\n]\n</code></pre>"},{"location":"api-reference/series_str/#narwhals.series.SeriesStringNamespace.to_uppercase","title":"to_uppercase","text":"<pre><code>to_uppercase() -&gt; SeriesT\n</code></pre> <p>Transform string to uppercase variant.</p> Notes <p>The PyArrow backend will convert '\u00df' to '\u1e9e' instead of 'SS'. For more info see: https://github.com/apache/arrow/issues/34599 There may be other unicode-edge-case-related variations across implementations.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pd.Series([\"apple\", None])\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.str.to_uppercase().to_native()\n0    APPLE\n1     None\ndtype: object\n</code></pre>"},{"location":"api-reference/series_str/#narwhals.series.SeriesStringNamespace.zfill","title":"zfill","text":"<pre><code>zfill(width: int) -&gt; SeriesT\n</code></pre> <p>Pad strings with zeros on the left.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>The target width of the string. If the string is shorter than this width, it will be padded with zeros on the left.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pd.Series([\"+1\", \"-23\", \"456\", \"123456\"])\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.str.zfill(5).to_native()\n0     +0001\n1     -0023\n2     00456\n3    123456\ndtype: object\n</code></pre>"},{"location":"api-reference/series_struct/","title":"<code>narwhals.Series.struct</code>","text":""},{"location":"api-reference/series_struct/#narwhals.series.SeriesStructNamespace.field","title":"field","text":"<pre><code>field(name: str) -&gt; SeriesT\n</code></pre> <p>Retrieve a Struct field as a new expression.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the struct field to retrieve.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pl.Series(\n...     [{\"id\": \"0\", \"name\": \"john\"}, {\"id\": \"1\", \"name\": \"jane\"}]\n... )\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.struct.field(\"name\").to_list()\n['john', 'jane']\n</code></pre>"},{"location":"api-reference/testing/","title":"<code>narwhals.testing</code>","text":""},{"location":"api-reference/testing/#narwhals.testing.assert_series_equal","title":"assert_series_equal","text":"<pre><code>assert_series_equal(\n    left: Series[IntoSeriesT],\n    right: Series[IntoSeriesT],\n    *,\n    check_dtypes: bool = True,\n    check_names: bool = True,\n    check_order: bool = True,\n    check_exact: bool = False,\n    rel_tol: float = 1e-05,\n    abs_tol: float = 1e-08,\n    categorical_as_str: bool = False\n) -&gt; None\n</code></pre> <p>Assert that the left and right Series are equal.</p> <p>Raises a detailed <code>AssertionError</code> if the Series differ. This function is intended for use in unit tests.</p> <p>Parameters:</p> Name Type Description Default <code>left</code> <code>Series[IntoSeriesT]</code> <p>The first Series to compare.</p> required <code>right</code> <code>Series[IntoSeriesT]</code> <p>The second Series to compare.</p> required <code>check_dtypes</code> <code>bool</code> <p>Requires data types to match.</p> <code>True</code> <code>check_names</code> <code>bool</code> <p>Requires names to match.</p> <code>True</code> <code>check_order</code> <code>bool</code> <p>Requires elements to appear in the same order.</p> <code>True</code> <code>check_exact</code> <code>bool</code> <p>Requires float values to match exactly. If set to <code>False</code>, values are considered equal when within tolerance of each other (see <code>rel_tol</code> and <code>abs_tol</code>). Only affects columns with a Float data type.</p> <code>False</code> <code>rel_tol</code> <code>float</code> <p>Relative tolerance for inexact checking, given as a fraction of the values in <code>right</code>.</p> <code>1e-05</code> <code>abs_tol</code> <code>float</code> <p>Absolute tolerance for inexact checking.</p> <code>1e-08</code> <code>categorical_as_str</code> <code>bool</code> <p>Cast categorical columns to string before comparing. Enabling this helps compare columns that do not share the same string cache.</p> <code>False</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; from narwhals.testing import assert_series_equal\n&gt;&gt;&gt; s1 = nw.from_native(pd.Series([1, 2, 3]), series_only=True)\n&gt;&gt;&gt; s2 = nw.from_native(pd.Series([1, 5, 3]), series_only=True)\n&gt;&gt;&gt; assert_series_equal(s1, s2)\nTraceback (most recent call last):\n...\nAssertionError: Series are different (exact value mismatch)\n[left]:\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals Series|\n|---------------|\n| 0    1        |\n| 1    2        |\n| 2    3        |\n| dtype: int64  |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n[right]:\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals Series|\n|---------------|\n| 0    1        |\n| 1    5        |\n| 2    3        |\n| dtype: int64  |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>narwhals/testing/asserts/series.py</code> <pre><code>def assert_series_equal(\n    left: Series[IntoSeriesT],\n    right: Series[IntoSeriesT],\n    *,\n    check_dtypes: bool = True,\n    check_names: bool = True,\n    check_order: bool = True,\n    check_exact: bool = False,\n    rel_tol: float = 1e-05,\n    abs_tol: float = 1e-08,\n    categorical_as_str: bool = False,\n) -&gt; None:\n    \"\"\"Assert that the left and right Series are equal.\n\n    Raises a detailed `AssertionError` if the Series differ.\n    This function is intended for use in unit tests.\n\n    Arguments:\n        left: The first Series to compare.\n        right: The second Series to compare.\n        check_dtypes: Requires data types to match.\n        check_names: Requires names to match.\n        check_order: Requires elements to appear in the same order.\n        check_exact: Requires float values to match exactly. If set to `False`, values are\n            considered equal when within tolerance of each other (see `rel_tol` and\n            `abs_tol`). Only affects columns with a Float data type.\n        rel_tol: Relative tolerance for inexact checking, given as a fraction of the\n            values in `right`.\n        abs_tol: Absolute tolerance for inexact checking.\n        categorical_as_str: Cast categorical columns to string before comparing.\n            Enabling this helps compare columns that do not share the same string cache.\n\n    Examples:\n        &gt;&gt;&gt; import pandas as pd\n        &gt;&gt;&gt; import narwhals as nw\n        &gt;&gt;&gt; from narwhals.testing import assert_series_equal\n        &gt;&gt;&gt; s1 = nw.from_native(pd.Series([1, 2, 3]), series_only=True)\n        &gt;&gt;&gt; s2 = nw.from_native(pd.Series([1, 5, 3]), series_only=True)\n        &gt;&gt;&gt; assert_series_equal(s1, s2)  # doctest: +ELLIPSIS\n        Traceback (most recent call last):\n        ...\n        AssertionError: Series are different (exact value mismatch)\n        [left]:\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        |Narwhals Series|\n        |---------------|\n        | 0    1        |\n        | 1    2        |\n        | 2    3        |\n        | dtype: int64  |\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        [right]:\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        |Narwhals Series|\n        |---------------|\n        | 0    1        |\n        | 1    5        |\n        | 2    3        |\n        | dtype: int64  |\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"\n    __tracebackhide__ = True\n\n    if any(not is_narwhals_series(obj) for obj in (left, right)):\n        msg = (\n            \"Expected `narwhals.Series` instance, found:\\n\"\n            f\"[left]: {qualified_type_name(type(left))}\\n\"\n            f\"[right]: {qualified_type_name(type(right))}\\n\\n\"\n            \"Hint: Use `nw.from_native(obj, series_only=True) to convert each native \"\n            \"object into a `narwhals.Series` first.\"\n        )\n        raise TypeError(msg)\n\n    _check_metadata(left, right, check_dtypes=check_dtypes, check_names=check_names)\n\n    if not check_order:\n        if left.dtype.is_nested():\n            msg = \"`check_order=False` is not supported (yet) with nested data type.\"\n            raise NotImplementedError(msg)\n        left, right = left.sort(), right.sort()\n\n    left_vals, right_vals = _check_null_values(left, right)\n\n    if check_exact or not left.dtype.is_float():\n        _check_exact_values(\n            left_vals,\n            right_vals,\n            check_dtypes=check_dtypes,\n            check_exact=check_exact,\n            rel_tol=rel_tol,\n            abs_tol=abs_tol,\n            categorical_as_str=categorical_as_str,\n        )\n    else:\n        _check_approximate_values(left_vals, right_vals, rel_tol=rel_tol, abs_tol=abs_tol)\n</code></pre>"},{"location":"api-reference/typing/","title":"<code>narwhals.typing</code>","text":"<p>Narwhals comes fully statically typed. In addition to <code>nw.DataFrame</code>, <code>nw.Expr</code>, <code>nw.Series</code>, <code>nw.LazyFrame</code>, we also provide the following type hints:</p>"},{"location":"api-reference/typing/#narwhals.typing.DataFrameT","title":"DataFrameT  <code>module-attribute</code>","text":"<pre><code>DataFrameT = TypeVar('DataFrameT', bound='DataFrame[Any]')\n</code></pre> <p>TypeVar bound to Narwhals DataFrame.</p> <p>Use this if your function can accept a Narwhals DataFrame and returns a Narwhals DataFrame backed by the same backend.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; from narwhals.typing import DataFrameT\n&gt;&gt;&gt; @nw.narwhalify\n&gt;&gt;&gt; def func(df: DataFrameT) -&gt; DataFrameT:\n...     return df.with_columns(c=df[\"a\"] + 1)\n</code></pre>"},{"location":"api-reference/typing/#narwhals.typing.Frame","title":"Frame  <code>module-attribute</code>","text":"<pre><code>Frame: TypeAlias = Union[\"DataFrame[Any]\", \"LazyFrame[Any]\"]\n</code></pre> <p>Narwhals DataFrame or Narwhals LazyFrame.</p> <p>Use this if your function can work with either and your function doesn't care about its backend.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; from narwhals.typing import Frame\n&gt;&gt;&gt; @nw.narwhalify\n... def agnostic_columns(df: Frame) -&gt; list[str]:\n...     return df.columns\n</code></pre>"},{"location":"api-reference/typing/#narwhals.typing.FrameT","title":"FrameT  <code>module-attribute</code>","text":"<pre><code>FrameT = TypeVar(\n    \"FrameT\", \"DataFrame[Any]\", \"LazyFrame[Any]\"\n)\n</code></pre> <p>TypeVar bound to Narwhals DataFrame or Narwhals LazyFrame.</p> <p>Use this if your function accepts either <code>nw.DataFrame</code> or <code>nw.LazyFrame</code> and returns an object of the same kind.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; from narwhals.typing import FrameT\n&gt;&gt;&gt; @nw.narwhalify\n... def agnostic_func(df: FrameT) -&gt; FrameT:\n...     return df.with_columns(c=nw.col(\"a\") + 1)\n</code></pre>"},{"location":"api-reference/typing/#narwhals.typing.IntoDataFrame","title":"IntoDataFrame  <code>module-attribute</code>","text":"<pre><code>IntoDataFrame: TypeAlias = NativeDataFrame\n</code></pre> <p>Anything which can be converted to a Narwhals DataFrame.</p> <p>Use this if your function accepts a narwhalifiable object but doesn't care about its backend.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; from narwhals.typing import IntoDataFrame\n&gt;&gt;&gt; def agnostic_shape(df_native: IntoDataFrame) -&gt; tuple[int, int]:\n...     df = nw.from_native(df_native, eager_only=True)\n...     return df.shape\n</code></pre>"},{"location":"api-reference/typing/#narwhals.typing.IntoDataFrameT","title":"IntoDataFrameT  <code>module-attribute</code>","text":"<pre><code>IntoDataFrameT = TypeVar(\n    \"IntoDataFrameT\", bound=IntoDataFrame\n)\n</code></pre> <p>TypeVar bound to object convertible to Narwhals DataFrame.</p> <p>Use this if your function accepts an object which can be converted to <code>nw.DataFrame</code> and returns an object of the same class.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; from narwhals.typing import IntoDataFrameT\n&gt;&gt;&gt; def agnostic_func(df_native: IntoDataFrameT) -&gt; IntoDataFrameT:\n...     df = nw.from_native(df_native, eager_only=True)\n...     return df.with_columns(c=df[\"a\"] + 1).to_native()\n</code></pre>"},{"location":"api-reference/typing/#narwhals.typing.IntoExpr","title":"IntoExpr  <code>module-attribute</code>","text":"<pre><code>IntoExpr: TypeAlias = Union[\n    \"Expr\", str, \"Series[Any]\", _1DArray\n]\n</code></pre> <p>Anything which can be converted to an expression.</p> <p>Use this to mean \"either a Narwhals expression, or something which can be converted into one\". For example, <code>exprs</code> in <code>DataFrame.select</code> is typed to accept <code>IntoExpr</code>, as it can either accept a <code>nw.Expr</code> (e.g. <code>df.select(nw.col('a'))</code>) or a string which will be interpreted as a <code>nw.Expr</code>, e.g. <code>df.select('a')</code>.</p>"},{"location":"api-reference/typing/#narwhals.typing.IntoFrame","title":"IntoFrame  <code>module-attribute</code>","text":"<pre><code>IntoFrame: TypeAlias = Union[IntoDataFrame, IntoLazyFrame]\n</code></pre> <p>Anything which can be converted to a Narwhals DataFrame or LazyFrame.</p> <p>Use this if your function can accept an object which can be converted to either <code>nw.DataFrame</code> or <code>nw.LazyFrame</code> and it doesn't care about its backend.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; from narwhals.typing import IntoFrame\n&gt;&gt;&gt; def agnostic_columns(df_native: IntoFrame) -&gt; list[str]:\n...     df = nw.from_native(df_native)\n...     return df.collect_schema().names()\n</code></pre>"},{"location":"api-reference/typing/#narwhals.typing.IntoFrameT","title":"IntoFrameT  <code>module-attribute</code>","text":"<pre><code>IntoFrameT = TypeVar('IntoFrameT', bound=IntoFrame)\n</code></pre> <p>TypeVar bound to object convertible to Narwhals DataFrame or Narwhals LazyFrame.</p> <p>Use this if your function accepts an object which is convertible to <code>nw.DataFrame</code> or <code>nw.LazyFrame</code> and returns an object of the same type.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; from narwhals.typing import IntoFrameT\n&gt;&gt;&gt; def agnostic_func(df_native: IntoFrameT) -&gt; IntoFrameT:\n...     df = nw.from_native(df_native)\n...     return df.with_columns(c=nw.col(\"a\") + 1).to_native()\n</code></pre>"},{"location":"api-reference/typing/#narwhals.typing.IntoSeries","title":"IntoSeries  <code>module-attribute</code>","text":"<pre><code>IntoSeries: TypeAlias = NativeSeries\n</code></pre> <p>Anything which can be converted to a Narwhals Series.</p> <p>Use this if your function can accept an object which can be converted to <code>nw.Series</code> and it doesn't care about its backend.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from typing import Any\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; from narwhals.typing import IntoSeries\n&gt;&gt;&gt; def agnostic_to_list(s_native: IntoSeries) -&gt; list[Any]:\n...     s = nw.from_native(s_native)\n...     return s.to_list()\n</code></pre>"},{"location":"api-reference/typing/#narwhals.typing.IntoSeriesT","title":"IntoSeriesT  <code>module-attribute</code>","text":"<pre><code>IntoSeriesT = TypeVar('IntoSeriesT', bound=IntoSeries)\n</code></pre> <p>TypeVar bound to object convertible to Narwhals Series.</p> <p>Use this if your function accepts an object which can be converted to <code>nw.Series</code> and returns an object of the same class.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; from narwhals.typing import IntoSeriesT\n&gt;&gt;&gt; def agnostic_abs(s_native: IntoSeriesT) -&gt; IntoSeriesT:\n...     s = nw.from_native(s_native, series_only=True)\n...     return s.abs().to_native()\n</code></pre>"},{"location":"api-reference/typing/#narwhals.typing.IntoBackend","title":"IntoBackend  <code>module-attribute</code>","text":"<pre><code>IntoBackend: TypeAlias = Union[BackendT, ModuleType]\n</code></pre> <p>Anything that can be converted into a <code>narwhals.Implementation</code>.</p> <p><code>backend</code> can be specified in three ways.</p> <p>Examples:</p> <p>A string backend name, such as: <code>\"pandas\"</code>, <code>\"pyarrow\"</code>, <code>\"modin\"</code>, <code>\"cudf\"</code></p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; data = {\"c\": [5, 2], \"d\": [1, 4]}\n&gt;&gt;&gt; nw.DataFrame.from_dict(data, backend=\"pandas\")\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|        c  d      |\n|     0  5  1      |\n|     1  2  4      |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>An Implementation, such as: <code>Implementation.POLARS</code>, <code>Implementation.DUCKDB</code>, <code>Implementation.PYSPARK</code></p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; nw.read_parquet(\"file.parquet\", backend=nw.Implementation.PYARROW)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|  pyarrow.Table   |\n|  a: int64        |\n|  b: int64        |\n|  ----            |\n|  a: [[1,2]]      |\n|  b: [[4,5]]      |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>A python module, such as <code>dask</code>, <code>ibis</code>, <code>sqlframe</code></p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; arr = np.arange(5, 10)\n&gt;&gt;&gt; nw.Series.from_numpy(\"arr\", arr, dtype=nw.Int8, backend=pl)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n| Narwhals Series  |\n|------------------|\n|shape: (5,)       |\n|Series: 'arr' [i8]|\n|[                 |\n|        5         |\n|        6         |\n|        7         |\n|        8         |\n|        9         |\n|]                 |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/typing/#narwhals.typing.Backend","title":"Backend  <code>module-attribute</code>","text":"<pre><code>Backend: TypeAlias = Literal[EagerAllowed, LazyAllowed]\n</code></pre> <p>A string name or <code>narwhals.Implementation</code> of a supported backend (either eager or lazy).</p> <ul> <li>A string name, such as: <code>\"duckdb\"</code>, <code>\"ibis\"</code>, <code>\"pandas\"</code>, <code>\"pyarrow\"</code>, <code>\"polars\"</code>, ...</li> <li>An Implementation, such as: <code>Implementation.DASK</code>, <code>Implementation.PYSPARK</code>, ...</li> </ul>"},{"location":"api-reference/typing/#narwhals.typing.EagerAllowed","title":"EagerAllowed  <code>module-attribute</code>","text":"<pre><code>EagerAllowed: TypeAlias = Literal[EagerOnly, Polars]\n</code></pre> <p>A string name or <code>narwhals.Implementation</code> of an eager backend.</p> <ul> <li>A string name, one of: <code>\"cudf\"</code>, <code>\"modin\"</code>, <code>\"pandas\"</code>, <code>\"pyarrow\"</code>, <code>\"polars\"</code>.</li> <li>An Implementation, such as: <code>Implementation.CUDF</code>, <code>Implementation.MODIN</code>, ...</li> </ul>"},{"location":"api-reference/typing/#narwhals.typing.LazyAllowed","title":"LazyAllowed  <code>module-attribute</code>","text":"<pre><code>LazyAllowed: TypeAlias = Literal[LazyOnly, Polars]\n</code></pre> <p>A string name or <code>narwhals.Implementation</code> of a lazy backend.</p> <ul> <li>A string name, such as: <code>\"duckdb\"</code>, <code>\"ibis\"</code>, <code>\"dask\"</code>, <code>\"sqlframe\"</code>, ...</li> <li>An Implementation, such as: <code>Implementation.POLARS</code>, <code>Implementation.PYSPARK</code>, ...</li> </ul>"},{"location":"api-reference/typing/#narwhals.typing.IntoDType","title":"IntoDType  <code>module-attribute</code>","text":"<pre><code>IntoDType: TypeAlias = \"dtypes.DType | type[NonNestedDType]\"\n</code></pre> <p>Anything that can be converted into a Narwhals DType.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pl.DataFrame({\"a\": [1, 2, 3], \"b\": [4.0, 5.0, 6.0]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.select(\n...     nw.col(\"a\").cast(nw.Int32),\n...     nw.col(\"b\").cast(nw.String()).str.split(\".\").cast(nw.List(nw.Int8)),\n... )\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|shape: (3, 2)     |\n|\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510|\n|\u2502 a   \u2506 b        \u2502|\n|\u2502 --- \u2506 ---      \u2502|\n|\u2502 i32 \u2506 list[i8] \u2502|\n|\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561|\n|\u2502 1   \u2506 [4, 0]   \u2502|\n|\u2502 2   \u2506 [5, 0]   \u2502|\n|\u2502 3   \u2506 [6, 0]   \u2502|\n|\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/typing/#narwhals.typing.IntoSchema","title":"IntoSchema  <code>module-attribute</code>","text":"<pre><code>IntoSchema: TypeAlias = (\n    \"Mapping[str, dtypes.DType] | Schema\"\n)\n</code></pre> <p>Anything that can be converted into a Narwhals Schema.</p> <p>Defined by column names and their associated instantiated Narwhals DType.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; data = {\"a\": [1, 2, 3], \"b\": [None, \"hi\", \"howdy\"], \"c\": [2.1, 2.0, None]}\n&gt;&gt;&gt; nw.DataFrame.from_dict(\n...     data,\n...     schema={\"a\": nw.UInt8(), \"b\": nw.String(), \"c\": nw.Float32()},\n...     backend=\"pyarrow\",\n... )\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|   Narwhals DataFrame   |\n|------------------------|\n|pyarrow.Table           |\n|a: uint8                |\n|b: string               |\n|c: float                |\n|----                    |\n|a: [[1,2,3]]            |\n|b: [[null,\"hi\",\"howdy\"]]|\n|c: [[2.1,2,null]]       |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/typing/#narwhals.typing.SizeUnit","title":"SizeUnit  <code>module-attribute</code>","text":"<pre><code>SizeUnit: TypeAlias = Literal[\n    \"b\",\n    \"kb\",\n    \"mb\",\n    \"gb\",\n    \"tb\",\n    \"bytes\",\n    \"kilobytes\",\n    \"megabytes\",\n    \"gigabytes\",\n    \"terabytes\",\n]\n</code></pre>"},{"location":"api-reference/typing/#narwhals.typing.TimeUnit","title":"TimeUnit  <code>module-attribute</code>","text":"<pre><code>TimeUnit: TypeAlias = Literal['ns', 'us', 'ms', 's']\n</code></pre>"},{"location":"api-reference/typing/#narwhals.typing.AsofJoinStrategy","title":"AsofJoinStrategy  <code>module-attribute</code>","text":"<pre><code>AsofJoinStrategy: TypeAlias = Literal[\n    \"backward\", \"forward\", \"nearest\"\n]\n</code></pre> <p>Join strategy.</p> <ul> <li>\"backward\": Selects the last row in the right DataFrame whose <code>on</code> key     is less than or equal to the left's key.</li> <li>\"forward\": Selects the first row in the right DataFrame whose <code>on</code> key     is greater than or equal to the left's key.</li> <li>\"nearest\": Search selects the last row in the right DataFrame whose value     is nearest to the left's key.</li> </ul>"},{"location":"api-reference/typing/#narwhals.typing.ClosedInterval","title":"ClosedInterval  <code>module-attribute</code>","text":"<pre><code>ClosedInterval: TypeAlias = Literal[\n    \"left\", \"right\", \"none\", \"both\"\n]\n</code></pre> <p>Define which sides of the interval are closed (inclusive).</p>"},{"location":"api-reference/typing/#narwhals.typing.ConcatMethod","title":"ConcatMethod  <code>module-attribute</code>","text":"<pre><code>ConcatMethod: TypeAlias = Literal[\n    \"horizontal\", \"vertical\", \"diagonal\"\n]\n</code></pre> <p>Concatenating strategy.</p> <ul> <li>\"vertical\": Concatenate vertically. Column names must match.</li> <li>\"horizontal\": Concatenate horizontally. If lengths don't match, then     missing rows are filled with null values.</li> <li>\"diagonal\": Finds a union between the column schemas and fills missing     column values with null.</li> </ul>"},{"location":"api-reference/typing/#narwhals.typing.FillNullStrategy","title":"FillNullStrategy  <code>module-attribute</code>","text":"<pre><code>FillNullStrategy: TypeAlias = Literal[\"forward\", \"backward\"]\n</code></pre> <p>Strategy used to fill null values.</p>"},{"location":"api-reference/typing/#narwhals.typing.JoinStrategy","title":"JoinStrategy  <code>module-attribute</code>","text":"<pre><code>JoinStrategy: TypeAlias = Literal[\n    \"inner\", \"left\", \"full\", \"cross\", \"semi\", \"anti\"\n]\n</code></pre> <p>Join strategy.</p> <ul> <li>\"inner\": Returns rows that have matching values in both tables.</li> <li>\"left\": Returns all rows from the left table, and the matched rows from     the right table.</li> <li>\"full\": Returns all rows in both dataframes, with the <code>suffix</code> appended to     the right join keys.</li> <li>\"cross\": Returns the Cartesian product of rows from both tables.</li> <li>\"semi\": Filter rows that have a match in the right table.</li> <li>\"anti\": Filter rows that do not have a match in the right table.</li> </ul>"},{"location":"api-reference/typing/#narwhals.typing.ModeKeepStrategy","title":"ModeKeepStrategy  <code>module-attribute</code>","text":"<pre><code>ModeKeepStrategy: TypeAlias = Literal['any', 'all']\n</code></pre> <p>Which of the mode's to keep.</p> <ul> <li>\"any\": Does not give any guarantee of which mode is kept.</li> <li>\"all\": Keeps all the mode's.</li> </ul>"},{"location":"api-reference/typing/#narwhals.typing.PivotAgg","title":"PivotAgg  <code>module-attribute</code>","text":"<pre><code>PivotAgg: TypeAlias = Literal[\n    \"min\",\n    \"max\",\n    \"first\",\n    \"last\",\n    \"sum\",\n    \"mean\",\n    \"median\",\n    \"len\",\n]\n</code></pre> <p>A predefined aggregate function string.</p>"},{"location":"api-reference/typing/#narwhals.typing.RankMethod","title":"RankMethod  <code>module-attribute</code>","text":"<pre><code>RankMethod: TypeAlias = Literal[\n    \"average\", \"min\", \"max\", \"dense\", \"ordinal\"\n]\n</code></pre> <p>The method used to assign ranks to tied elements.</p> <ul> <li>\"average\": The average of the ranks that would have been assigned to     all the tied values is assigned to each value.</li> <li>\"min\": The minimum of the ranks that would have been assigned to all     the tied values is assigned to each value. (This is also referred to     as \"competition\" ranking.)</li> <li>\"max\": The maximum of the ranks that would have been assigned to all     the tied values is assigned to each value.</li> <li>\"dense\": Like \"min\", but the rank of the next highest element is     assigned the rank immediately after those assigned to the tied elements.</li> <li>\"ordinal\": All values are given a distinct rank, corresponding to the     order that the values occur in the Series.</li> </ul>"},{"location":"api-reference/typing/#narwhals.typing.RollingInterpolationMethod","title":"RollingInterpolationMethod  <code>module-attribute</code>","text":"<pre><code>RollingInterpolationMethod: TypeAlias = Literal[\n    \"nearest\", \"higher\", \"lower\", \"midpoint\", \"linear\"\n]\n</code></pre> <p>Interpolation method.</p>"},{"location":"api-reference/typing/#narwhals.typing.UniqueKeepStrategy","title":"UniqueKeepStrategy  <code>module-attribute</code>","text":"<pre><code>UniqueKeepStrategy: TypeAlias = Literal[\n    \"any\", \"first\", \"last\", \"none\"\n]\n</code></pre> <p>Which of the duplicate rows to keep.</p> <ul> <li>\"any\": Does not give any guarantee of which row is kept.     This allows more optimizations.</li> <li>\"none\": Don't keep duplicate rows.</li> <li>\"first\": Keep first unique row.</li> <li>\"last\": Keep last unique row.</li> </ul>"},{"location":"api-reference/typing/#nwnarwhalify-or-nwfrom_native","title":"<code>nw.narwhalify</code>, or <code>nw.from_native</code>?","text":"<p>Although some people find the former more readable, the latter is better at preserving type hints.</p> <p>Here's an example: <pre><code>import polars as pl\nimport narwhals as nw\nfrom narwhals.typing import IntoDataFrameT, DataFrameT\n\ndf = pl.DataFrame({\"a\": [1, 2, 3]})\n\n\ndef func(df_native: IntoDataFrameT) -&gt; IntoDataFrameT:\n    df = nw.from_native(df_native, eager_only=True)\n    return df.select(b=nw.col(\"a\")).to_native()\n\n\nreveal_type(func(df))\n\n\n@nw.narwhalify(strict=True)\ndef func_2(df: DataFrameT) -&gt; DataFrameT:\n    return df.select(b=nw.col(\"a\"))\n\n\nreveal_type(func_2(df))\n</code></pre></p> <p>Running <code>mypy</code> on it gives: <pre><code>$ mypy t.py \nt.py:13: note: Revealed type is \"polars.dataframe.frame.DataFrame\"\nt.py:21: note: Revealed type is \"Any\"\nSuccess: no issues found in 1 source file\n</code></pre></p> <p>In the first case, mypy can infer that <code>df</code> is a <code>polars.DataFrame</code>. In the second case, it can't.</p> <p>If you want to make the most out of type hints and preserve them as much as possible, we recommend <code>nw.from_native</code> and <code>nw.to_native</code>. Type hints will still be respected inside the function body if you type the arguments.</p>"},{"location":"api-reference/utils/","title":"<code>narwhals.utils</code>","text":""},{"location":"api-reference/utils/#narwhals.utils.Implementation","title":"Implementation","text":"<p>Implementation of native object (pandas, Polars, PyArrow, ...).</p>"},{"location":"api-reference/utils/#narwhals.utils.Implementation.CUDF","title":"CUDF  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CUDF = 'cudf'\n</code></pre> <p>cuDF implementation.</p>"},{"location":"api-reference/utils/#narwhals.utils.Implementation.DASK","title":"DASK  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DASK = 'dask'\n</code></pre> <p>Dask implementation.</p>"},{"location":"api-reference/utils/#narwhals.utils.Implementation.DUCKDB","title":"DUCKDB  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DUCKDB = 'duckdb'\n</code></pre> <p>DuckDB implementation.</p>"},{"location":"api-reference/utils/#narwhals.utils.Implementation.IBIS","title":"IBIS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>IBIS = 'ibis'\n</code></pre> <p>Ibis implementation.</p>"},{"location":"api-reference/utils/#narwhals.utils.Implementation.MODIN","title":"MODIN  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MODIN = 'modin'\n</code></pre> <p>Modin implementation.</p>"},{"location":"api-reference/utils/#narwhals.utils.Implementation.PANDAS","title":"PANDAS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PANDAS = 'pandas'\n</code></pre> <p>pandas implementation.</p>"},{"location":"api-reference/utils/#narwhals.utils.Implementation.POLARS","title":"POLARS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>POLARS = 'polars'\n</code></pre> <p>Polars implementation.</p>"},{"location":"api-reference/utils/#narwhals.utils.Implementation.PYARROW","title":"PYARROW  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PYARROW = 'pyarrow'\n</code></pre> <p>PyArrow implementation.</p>"},{"location":"api-reference/utils/#narwhals.utils.Implementation.PYSPARK","title":"PYSPARK  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PYSPARK = 'pyspark'\n</code></pre> <p>PySpark implementation.</p>"},{"location":"api-reference/utils/#narwhals.utils.Implementation.PYSPARK_CONNECT","title":"PYSPARK_CONNECT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PYSPARK_CONNECT = 'pyspark[connect]'\n</code></pre> <p>PySpark Connect implementation.</p>"},{"location":"api-reference/utils/#narwhals.utils.Implementation.SQLFRAME","title":"SQLFRAME  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SQLFRAME = 'sqlframe'\n</code></pre> <p>SQLFrame implementation.</p>"},{"location":"api-reference/utils/#narwhals.utils.Implementation.UNKNOWN","title":"UNKNOWN  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UNKNOWN = 'unknown'\n</code></pre> <p>Unknown implementation.</p>"},{"location":"api-reference/utils/#narwhals.utils.Implementation.from_backend","title":"from_backend  <code>classmethod</code>","text":"<pre><code>from_backend(\n    backend: IntoBackend[Backend] | UnknownBackendName,\n) -&gt; Implementation\n</code></pre> <p>Instantiate from native namespace module, string, or Implementation.</p> <p>Parameters:</p> Name Type Description Default <code>backend</code> <code>IntoBackend[Backend] | UnknownBackendName</code> <p>Backend to instantiate Implementation from.</p> required"},{"location":"api-reference/utils/#narwhals.utils.Implementation.from_native_namespace","title":"from_native_namespace  <code>classmethod</code>","text":"<pre><code>from_native_namespace(\n    native_namespace: ModuleType,\n) -&gt; Implementation\n</code></pre> <p>Instantiate Implementation object from a native namespace module.</p> <p>Parameters:</p> Name Type Description Default <code>native_namespace</code> <code>ModuleType</code> <p>Native namespace.</p> required"},{"location":"api-reference/utils/#narwhals.utils.Implementation.from_string","title":"from_string  <code>classmethod</code>","text":"<pre><code>from_string(backend_name: str) -&gt; Implementation\n</code></pre> <p>Instantiate Implementation object from a native namespace module.</p> <p>Parameters:</p> Name Type Description Default <code>backend_name</code> <code>str</code> <p>Name of backend, expressed as string.</p> required"},{"location":"api-reference/utils/#narwhals.utils.Implementation.is_cudf","title":"is_cudf","text":"<pre><code>is_cudf() -&gt; bool\n</code></pre> <p>Return whether implementation is cuDF.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pl.DataFrame({\"a\": [1, 2, 3]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.implementation.is_cudf()\nFalse\n</code></pre>"},{"location":"api-reference/utils/#narwhals.utils.Implementation.is_dask","title":"is_dask","text":"<pre><code>is_dask() -&gt; bool\n</code></pre> <p>Return whether implementation is Dask.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pl.DataFrame({\"a\": [1, 2, 3]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.implementation.is_dask()\nFalse\n</code></pre>"},{"location":"api-reference/utils/#narwhals.utils.Implementation.is_duckdb","title":"is_duckdb","text":"<pre><code>is_duckdb() -&gt; bool\n</code></pre> <p>Return whether implementation is DuckDB.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pl.DataFrame({\"a\": [1, 2, 3]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.implementation.is_duckdb()\nFalse\n</code></pre>"},{"location":"api-reference/utils/#narwhals.utils.Implementation.is_ibis","title":"is_ibis","text":"<pre><code>is_ibis() -&gt; bool\n</code></pre> <p>Return whether implementation is Ibis.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pl.DataFrame({\"a\": [1, 2, 3]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.implementation.is_ibis()\nFalse\n</code></pre>"},{"location":"api-reference/utils/#narwhals.utils.Implementation.is_modin","title":"is_modin","text":"<pre><code>is_modin() -&gt; bool\n</code></pre> <p>Return whether implementation is Modin.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pl.DataFrame({\"a\": [1, 2, 3]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.implementation.is_modin()\nFalse\n</code></pre>"},{"location":"api-reference/utils/#narwhals.utils.Implementation.is_pandas","title":"is_pandas","text":"<pre><code>is_pandas() -&gt; bool\n</code></pre> <p>Return whether implementation is pandas.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [1, 2, 3]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.implementation.is_pandas()\nTrue\n</code></pre>"},{"location":"api-reference/utils/#narwhals.utils.Implementation.is_pandas_like","title":"is_pandas_like","text":"<pre><code>is_pandas_like() -&gt; bool\n</code></pre> <p>Return whether implementation is pandas, Modin, or cuDF.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [1, 2, 3]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.implementation.is_pandas_like()\nTrue\n</code></pre>"},{"location":"api-reference/utils/#narwhals.utils.Implementation.is_polars","title":"is_polars","text":"<pre><code>is_polars() -&gt; bool\n</code></pre> <p>Return whether implementation is Polars.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pl.DataFrame({\"a\": [1, 2, 3]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.implementation.is_polars()\nTrue\n</code></pre>"},{"location":"api-reference/utils/#narwhals.utils.Implementation.is_pyarrow","title":"is_pyarrow","text":"<pre><code>is_pyarrow() -&gt; bool\n</code></pre> <p>Return whether implementation is PyArrow.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pl.DataFrame({\"a\": [1, 2, 3]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.implementation.is_pyarrow()\nFalse\n</code></pre>"},{"location":"api-reference/utils/#narwhals.utils.Implementation.is_pyspark","title":"is_pyspark","text":"<pre><code>is_pyspark() -&gt; bool\n</code></pre> <p>Return whether implementation is PySpark.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pl.DataFrame({\"a\": [1, 2, 3]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.implementation.is_pyspark()\nFalse\n</code></pre>"},{"location":"api-reference/utils/#narwhals.utils.Implementation.is_pyspark_connect","title":"is_pyspark_connect","text":"<pre><code>is_pyspark_connect() -&gt; bool\n</code></pre> <p>Return whether implementation is PySpark.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pl.DataFrame({\"a\": [1, 2, 3]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.implementation.is_pyspark_connect()\nFalse\n</code></pre>"},{"location":"api-reference/utils/#narwhals.utils.Implementation.is_spark_like","title":"is_spark_like","text":"<pre><code>is_spark_like() -&gt; bool\n</code></pre> <p>Return whether implementation is pyspark or sqlframe.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [1, 2, 3]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.implementation.is_spark_like()\nFalse\n</code></pre>"},{"location":"api-reference/utils/#narwhals.utils.Implementation.is_sqlframe","title":"is_sqlframe","text":"<pre><code>is_sqlframe() -&gt; bool\n</code></pre> <p>Return whether implementation is SQLFrame.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pl.DataFrame({\"a\": [1, 2, 3]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.implementation.is_sqlframe()\nFalse\n</code></pre>"},{"location":"api-reference/utils/#narwhals.utils.Implementation.to_native_namespace","title":"to_native_namespace","text":"<pre><code>to_native_namespace() -&gt; ModuleType\n</code></pre> <p>Return the native namespace module corresponding to Implementation.</p>"},{"location":"api-reference/utils/#narwhals.utils.parse_version","title":"parse_version","text":"<pre><code>parse_version(\n    version: str | ModuleType | _SupportsVersion,\n) -&gt; tuple[int, ...]\n</code></pre> <p>Simple version parser; split into a tuple of ints for comparison.</p> <p>Parameters:</p> Name Type Description Default <code>version</code> <code>str | ModuleType | _SupportsVersion</code> <p>Version string, or object with one, to parse.</p> required"},{"location":"basics/complete_example/","title":"Complete example","text":"<p>We're going to write a dataframe-agnostic \"Standard Scaler\". This class will have <code>fit</code> and <code>transform</code> methods (like <code>scikit-learn</code> transformers), and will work agnostically for pandas and Polars.</p> <p>We'll need to write two methods:</p> <ul> <li><code>fit</code>: find the mean and standard deviation for each column from a given training set;</li> <li><code>transform</code>: scale a given dataset with the mean and standard deviations calculated   during <code>fit</code>.</li> </ul>"},{"location":"basics/complete_example/#fit-method","title":"Fit method","text":"<p>Unlike the <code>transform</code> method, which we'll write below, <code>fit</code> cannot stay lazy, as we need to compute concrete values for the means and standard deviations.</p> <p>To be able to get <code>Series</code> out of our <code>DataFrame</code>, we'll pass <code>eager_only=True</code> to <code>nw.from_native</code>. This is because Polars doesn't have a concept of lazy <code>Series</code>, and so Narwhals doesn't either.</p> <p>We can specify that in the <code>@nw.narwhalify</code> decorator by setting <code>eager_only=True</code>, and the argument will be propagated to <code>nw.from_native</code>.</p> from/to_native@narwhalify <pre><code>from typing import Self\nimport narwhals as nw\nfrom narwhals.typing import IntoDataFrameT\n\n\nclass StandardScaler:\n    def fit(self, df: IntoDataFrameT) -&gt; Self:\n        df_nw = nw.from_native(df, eager_only=True)\n        self._means = {col: df_nw[col].mean() for col in df_nw.columns}\n        self._std_devs = {col: df_nw[col].std() for col in df_nw.columns}\n        self._columns = df_nw.columns\n        return self\n</code></pre> <pre><code>from typing import Self\nimport narwhals as nw\nfrom narwhals.typing import DataFrameT\n\n\nclass StandardScaler:\n    @nw.narwhalify(eager_only=True)\n    def fit(self, df: DataFrameT) -&gt; Self:\n        self._means = {col: df[col].mean() for col in df.columns}\n        self._std_devs = {col: df[col].std() for col in df.columns}\n        self._columns = df.columns\n        return self\n</code></pre>"},{"location":"basics/complete_example/#transform-method","title":"Transform method","text":"<p>We're going to take in a dataframe, and return a dataframe of the same type:</p> from/to_native@narwhalify <pre><code>from typing import Self\nimport narwhals as nw\nfrom narwhals.typing import IntoFrameT\n\n\nclass StandardScaler:\n    ...\n\n    def transform(self, df: IntoFrameT) -&gt; IntoFrameT:\n        df_nw = nw.from_native(df)\n        return df_nw.with_columns(\n            (nw.col(col) - self._means[col]) / self._std_devs[col]\n            for col in self._columns\n        ).to_native()\n</code></pre> <pre><code>from typing import Self\nimport narwhals as nw\nfrom narwhals.typing import FrameT\n\n\nclass StandardScaler:\n    ...\n\n    @nw.narwhalify\n    def transform(self, df: FrameT) -&gt; FrameT:\n        return df.with_columns(\n            (nw.col(col) - self._means[col]) / self._std_devs[col]\n            for col in self._columns\n        )\n</code></pre> <p>Note that all the calculations here can stay lazy if the underlying library permits it, so we don't pass in any extra keyword-arguments such as <code>eager_only</code>, we just use the default <code>eager_only=False</code>.</p>"},{"location":"basics/complete_example/#putting-it-all-together","title":"Putting it all together","text":"<p>Here is our dataframe-agnostic standard scaler:</p> from/to_native@narwhalify <pre><code>from typing import Self\nimport narwhals as nw\nfrom narwhals.typing import IntoDataFrameT\nfrom narwhals.typing import IntoFrameT\n\n\nclass StandardScaler:\n    def fit(self, df: IntoDataFrameT) -&gt; Self:\n        df_nw = nw.from_native(df, eager_only=True)\n        self._means = {col: df_nw[col].mean() for col in df_nw.columns}\n        self._std_devs = {col: df_nw[col].std() for col in df_nw.columns}\n        self._columns = df_nw.columns\n        return self\n\n    def transform(self, df: IntoFrameT) -&gt; IntoFrameT:\n        df_nw = nw.from_native(df)\n        return df_nw.with_columns(\n            (nw.col(col) - self._means[col]) / self._std_devs[col]\n            for col in self._columns\n        ).to_native()\n</code></pre> <pre><code>from typing import Self\nimport narwhals as nw\nfrom narwhals.typing import DataFrameT\nfrom narwhals.typing import FrameT\n\n\nclass StandardScaler:\n    @nw.narwhalify(eager_only=True)\n    def fit(self, df: DataFrameT) -&gt; Self:\n        self._means = {col: df[col].mean() for col in df.columns}\n        self._std_devs = {col: df[col].std() for col in df.columns}\n        self._columns = df.columns\n        return self\n\n    @nw.narwhalify\n    def transform(self, df: FrameT) -&gt; FrameT:\n        return df.with_columns(\n            (nw.col(col) - self._means[col]) / self._std_devs[col]\n            for col in self._columns\n        )\n</code></pre> <p>Next, let's try running it. Notice how, as <code>transform</code> doesn't use any eager-only features, we can pass a Polars LazyFrame to it and have it stay lazy!</p> pandasPolars <pre><code>import pandas as pd\n\ndf_train = pd.DataFrame({\"a\": [1, 2, 3], \"b\": [4, 5, 7]})\ndf_test = pd.DataFrame({\"a\": [1, 2, 3], \"b\": [4, 5, 7]})\nscaler = StandardScaler()\nscaler.fit(df_train)\nprint(scaler.transform(df_test))\n</code></pre> <pre><code>     a         b\n0 -1.0 -0.872872\n1  0.0 -0.218218\n2  1.0  1.091089\n</code></pre> <pre><code>import polars as pl\n\ndf_train = pl.DataFrame({\"a\": [1, 2, 3], \"b\": [4, 5, 7]})\ndf_test = pl.LazyFrame({\"a\": [1, 2, 3], \"b\": [4, 5, 7]})\nscaler = StandardScaler()\nscaler.fit(df_train)\nprint(scaler.transform(df_test).collect())\n</code></pre> <pre><code>shape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a    \u2506 b         \u2502\n\u2502 ---  \u2506 ---       \u2502\n\u2502 f64  \u2506 f64       \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 -1.0 \u2506 -0.872872 \u2502\n\u2502 0.0  \u2506 -0.218218 \u2502\n\u2502 1.0  \u2506 1.091089  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"basics/dataframe/","title":"DataFrame","text":"<p>To write a dataframe-agnostic function, the steps you'll want to follow are:</p> <ol> <li> <p>Initialise a Narwhals DataFrame or LazyFrame by passing your dataframe to <code>nw.from_native</code>.     All the calculations stay lazy if we start with a lazy dataframe - Narwhals will never automatically trigger computation without you asking it to.</p> <p>Note: if you need eager execution, make sure to pass <code>eager_only=True</code> to <code>nw.from_native</code>.</p> </li> <li> <p>Express your logic using the subset of the Polars API supported by Narwhals.</p> </li> <li>If you need to return a dataframe to the user in its original library, call <code>nw.to_native</code>.</li> </ol> <p>Steps 1 and 3 are so common that we provide a utility <code>@nw.narwhalify</code> decorator, which allows you to only explicitly write step 2.</p> <p>Let's explore this with some simple examples.</p>"},{"location":"basics/dataframe/#example-1-descriptive-statistics","title":"Example 1: descriptive statistics","text":"<p>Just like in Polars, we can pass expressions to <code>DataFrame.select</code> or <code>LazyFrame.select</code>.</p> <p>Make a Python file with the following content:</p> from/to_native@narwhalify <pre><code>import narwhals as nw\nfrom narwhals.typing import IntoFrameT\n\n\ndef func(df: IntoFrameT) -&gt; IntoFrameT:\n    return (\n        nw.from_native(df)\n        .select(\n            a_sum=nw.col(\"a\").sum(),\n            a_mean=nw.col(\"a\").mean(),\n            a_std=nw.col(\"a\").std(),\n        )\n        .to_native()\n    )\n</code></pre> <pre><code>import narwhals as nw\nfrom narwhals.typing import FrameT\n\n\n@nw.narwhalify\ndef func(df: FrameT) -&gt; FrameT:\n    return df.select(\n        a_sum=nw.col(\"a\").sum(),\n        a_mean=nw.col(\"a\").mean(),\n        a_std=nw.col(\"a\").std(),\n    )\n</code></pre> <p>Let's try it out:</p> pandasPolars (eager)Polars (lazy)PyArrow <pre><code>import pandas as pd\n\ndf = pd.DataFrame({\"a\": [1, 1, 2]})\nprint(func(df))\n</code></pre> <pre><code>   a_sum    a_mean    a_std\n0      4  1.333333  0.57735\n</code></pre> <pre><code>import polars as pl\n\ndf = pl.DataFrame({\"a\": [1, 1, 2]})\nprint(func(df))\n</code></pre> <pre><code>shape: (1, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a_sum \u2506 a_mean   \u2506 a_std   \u2502\n\u2502 ---   \u2506 ---      \u2506 ---     \u2502\n\u2502 i64   \u2506 f64      \u2506 f64     \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 4     \u2506 1.333333 \u2506 0.57735 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <pre><code>import polars as pl\n\ndf = pl.LazyFrame({\"a\": [1, 1, 2]})\nprint(func(df).collect())\n</code></pre> <pre><code>shape: (1, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a_sum \u2506 a_mean   \u2506 a_std   \u2502\n\u2502 ---   \u2506 ---      \u2506 ---     \u2502\n\u2502 i64   \u2506 f64      \u2506 f64     \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 4     \u2506 1.333333 \u2506 0.57735 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <pre><code>import pyarrow as pa\n\ntable = pa.table({\"a\": [1, 1, 2]})\nprint(func(table))\n</code></pre> <pre><code>pyarrow.Table\na_sum: int64\na_mean: double\na_std: double\n----\na_sum: [[4]]\na_mean: [[1.3333333333333333]]\na_std: [[0.5773502691896257]]\n</code></pre>"},{"location":"basics/dataframe/#example-2-group-by-and-mean","title":"Example 2: group-by and mean","text":"<p>Just like in Polars, we can pass expressions to <code>GroupBy.agg</code>. Make a Python file with the following content:</p> from/to_native@narwhalify <pre><code>import narwhals as nw\nfrom narwhals.typing import IntoFrameT\n\n\ndef func(df: IntoFrameT) -&gt; IntoFrameT:\n    return (\n        nw.from_native(df).group_by(\"a\").agg(nw.col(\"b\").mean()).sort(\"a\").to_native()\n    )\n</code></pre> <pre><code>import narwhals as nw\nfrom narwhals.typing import FrameT\n\n\n@nw.narwhalify\ndef func(df: FrameT) -&gt; FrameT:\n    return df.group_by(\"a\").agg(nw.col(\"b\").mean()).sort(\"a\")\n</code></pre> <p>Let's try it out:</p> pandasPolars (eager)Polars (lazy)PyArrow <pre><code>import pandas as pd\n\ndf = pd.DataFrame({\"a\": [1, 1, 2], \"b\": [4, 5, 6]})\nprint(func(df))\n</code></pre> <pre><code>   a    b\n0  1  4.5\n1  2  6.0\n</code></pre> <pre><code>import polars as pl\n\ndf = pl.DataFrame({\"a\": [1, 1, 2], \"b\": [4, 5, 6]})\nprint(func(df))\n</code></pre> <pre><code>shape: (2, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 i64 \u2506 f64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 4.5 \u2502\n\u2502 2   \u2506 6.0 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <pre><code>import polars as pl\n\ndf = pl.LazyFrame({\"a\": [1, 1, 2], \"b\": [4, 5, 6]})\nprint(func(df).collect())\n</code></pre> <pre><code>shape: (2, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 i64 \u2506 f64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 4.5 \u2502\n\u2502 2   \u2506 6.0 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <pre><code>import pyarrow as pa\n\ntable = pa.table({\"a\": [1, 1, 2], \"b\": [4, 5, 6]})\nprint(func(table))\n</code></pre> <pre><code>pyarrow.Table\na: int64\nb: double\n----\na: [[1,2]]\nb: [[4.5,6]]\n</code></pre>"},{"location":"basics/dataframe/#example-3-horizontal-sum","title":"Example 3: horizontal sum","text":"<p>Expressions can be free-standing functions which accept other expressions as inputs. For example, we can compute a horizontal sum using <code>nw.sum_horizontal</code>.</p> <p>Make a Python file with the following content:</p> from/to_native@narwhalify <pre><code>import narwhals as nw\nfrom narwhals.typing import IntoFrameT\n\n\ndef func(df: IntoFrameT) -&gt; IntoFrameT:\n    return (\n        nw.from_native(df)\n        .with_columns(a_plus_b=nw.sum_horizontal(\"a\", \"b\"))\n        .to_native()\n    )\n</code></pre> <pre><code>import narwhals as nw\nfrom narwhals.typing import FrameT\n\n\n@nw.narwhalify\ndef func(df: FrameT) -&gt; FrameT:\n    return df.with_columns(a_plus_b=nw.sum_horizontal(\"a\", \"b\"))\n</code></pre> <p>Let's try it out:</p> pandasPolars (eager)Polars (lazy)PyArrow <pre><code>import pandas as pd\n\ndf = pd.DataFrame({\"a\": [1, 1, 2], \"b\": [4, 5, 6]})\nprint(func(df))\n</code></pre> <pre><code>   a  b  a_plus_b\n0  1  4         5\n1  1  5         6\n2  2  6         8\n</code></pre> <pre><code>import polars as pl\n\ndf = pl.DataFrame({\"a\": [1, 1, 2], \"b\": [4, 5, 6]})\nprint(func(df))\n</code></pre> <pre><code>shape: (3, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2506 a_plus_b \u2502\n\u2502 --- \u2506 --- \u2506 ---      \u2502\n\u2502 i64 \u2506 i64 \u2506 i64      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 4   \u2506 5        \u2502\n\u2502 1   \u2506 5   \u2506 6        \u2502\n\u2502 2   \u2506 6   \u2506 8        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <pre><code>import polars as pl\n\ndf = pl.LazyFrame({\"a\": [1, 1, 2], \"b\": [4, 5, 6]})\nprint(func(df).collect())\n</code></pre> <pre><code>shape: (3, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2506 a_plus_b \u2502\n\u2502 --- \u2506 --- \u2506 ---      \u2502\n\u2502 i64 \u2506 i64 \u2506 i64      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 4   \u2506 5        \u2502\n\u2502 1   \u2506 5   \u2506 6        \u2502\n\u2502 2   \u2506 6   \u2506 8        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <pre><code>import pyarrow as pa\n\ntable = pa.table({\"a\": [1, 1, 2], \"b\": [4, 5, 6]})\nprint(func(table))\n</code></pre> <pre><code>pyarrow.Table\na: int64\nb: int64\na_plus_b: int64\n----\na: [[1,1,2]]\nb: [[4,5,6]]\na_plus_b: [[5,6,8]]\n</code></pre>"},{"location":"basics/dataframe/#example-4-multiple-inputs","title":"Example 4: multiple inputs","text":"<p><code>nw.narwhalify</code> can be used to decorate functions that take multiple inputs as well and return a non dataframe/series-like object.</p> <p>For example, let's compute how many rows are left in a dataframe after filtering it based on a series.</p> <p>Make a Python file with the following content:</p> <pre><code>import narwhals as nw\nfrom narwhals.typing import DataFrameT\n\n\n@nw.narwhalify(eager_only=True)\ndef func(df: DataFrameT, s: nw.Series, col_name: str) -&gt; int:\n    return df.filter(nw.col(col_name).is_in(s)).shape[0]\n</code></pre> <p>We require <code>eager_only=True</code> here because lazyframe doesn't support <code>.shape</code>.</p> <p>Let's try it out:</p> pandasPolars (eager)PyArrow <pre><code>import pandas as pd\n\ndf = pd.DataFrame({\"a\": [1, 1, 2, 2, 3], \"b\": [4, 5, 6, 7, 8]})\ns = pd.Series([1, 3])\nprint(func(df, s.to_numpy(), \"a\"))\n</code></pre> <pre><code>3\n</code></pre> <pre><code>import polars as pl\n\ndf = pl.DataFrame({\"a\": [1, 1, 2, 2, 3], \"b\": [4, 5, 6, 7, 8]})\ns = pl.Series([1, 3])\nprint(func(df, s.to_numpy(), \"a\"))\n</code></pre> <pre><code>3\n</code></pre> <pre><code>import pyarrow as pa\n\ntable = pa.table({\"a\": [1, 1, 2, 2, 3], \"b\": [4, 5, 6, 7, 8]})\na = pa.array([1, 3])\nprint(func(table, a.to_numpy(), \"a\"))\n</code></pre> <pre><code>3\n</code></pre>"},{"location":"basics/dataframe_conversion/","title":"Conversion between libraries","text":"<p>Some library maintainers must apply complex dataframe operations, using methods and functions that may not (yet) be implemented in Narwhals. In such cases, Narwhals can still be highly beneficial, by allowing easy dataframe conversion.</p>"},{"location":"basics/dataframe_conversion/#dataframe-x-in-pandas-out","title":"Dataframe X in, pandas out","text":"<p>Imagine that you maintain a library with a function that operates on pandas dataframes to produce automated reports. You want to allow users to supply a dataframe in any format to that function (pandas, Polars, DuckDB, cuDF, Modin, etc.) without adding all those dependencies to your own project and without special-casing each input library's variation of <code>to_pandas</code> / <code>toPandas</code> / <code>to_pandas_df</code> / <code>df</code> ...</p> <p>One solution is to use Narwhals as a thin Dataframe ingestion layer, to convert user-supplied dataframe to the format that your library uses internally. Since Narwhals is zero-dependency, this is a much more lightweight solution than including all the dataframe libraries as dependencies, and easier to write than special casing each input library's <code>to_pandas</code> method (if it even exists!).</p> <p>To illustrate, we create dataframes in various formats:</p> <pre><code>import narwhals as nw\nfrom narwhals.typing import IntoDataFrame\nfrom typing import Any\n\nimport duckdb\nimport polars as pl\nimport pandas as pd\n\ndf_polars = pl.DataFrame(\n    {\n        \"A\": [1, 2, 3, 4, 5],\n        \"fruits\": [\"banana\", \"banana\", \"apple\", \"apple\", \"banana\"],\n        \"B\": [5, 4, 3, 2, 1],\n        \"cars\": [\"beetle\", \"audi\", \"beetle\", \"beetle\", \"beetle\"],\n    }\n)\ndf_pandas = df_polars.to_pandas()\ndf_duckdb = duckdb.sql(\"SELECT * FROM df_polars\")\n</code></pre> <p>Now, we define a function that can ingest any dataframe type supported by Narwhals, and convert it to a pandas DataFrame for internal use:</p> <pre><code>def df_to_pandas(df: IntoDataFrame) -&gt; pd.DataFrame:\n    return nw.from_native(df).to_pandas()\n\n\nprint(df_to_pandas(df_polars))\n</code></pre> <pre><code>   A  fruits  B    cars\n0  1  banana  5  beetle\n1  2  banana  4    audi\n2  3   apple  3  beetle\n3  4   apple  2  beetle\n4  5  banana  1  beetle\n</code></pre>"},{"location":"basics/dataframe_conversion/#dataframe-x-in-polars-out","title":"Dataframe X in, Polars out","text":""},{"location":"basics/dataframe_conversion/#via-pycapsule-interface","title":"Via PyCapsule Interface","text":"<p>Similarly, if your library uses Polars internally, you can convert any user-supplied dataframe which implements <code>__arrow_c_stream__</code>:</p> <pre><code>def df_to_polars(df_native: Any) -&gt; pl.DataFrame:\n    if hasattr(df_native, \"__arrow_c_stream__\"):\n        return nw.from_arrow(df_native, backend=pl).to_native()\n    msg = (\n        f\"Expected object which implements '__arrow_c_stream__' got: {type(df_native)}\"\n    )\n    raise TypeError(msg)\n\n\nprint(df_to_polars(df_duckdb))\n</code></pre> <pre><code>shape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 A   \u2506 fruits \u2506 B   \u2506 cars   \u2502\n\u2502 --- \u2506 ---    \u2506 --- \u2506 ---    \u2502\n\u2502 i64 \u2506 str    \u2506 i64 \u2506 str    \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 banana \u2506 5   \u2506 beetle \u2502\n\u2502 2   \u2506 banana \u2506 4   \u2506 audi   \u2502\n\u2502 3   \u2506 apple  \u2506 3   \u2506 beetle \u2502\n\u2502 4   \u2506 apple  \u2506 2   \u2506 beetle \u2502\n\u2502 5   \u2506 banana \u2506 1   \u2506 beetle \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>It works to pass Polars to <code>backend</code> here because Polars supports the PyCapsule Interface for import.</p>"},{"location":"basics/series/","title":"Series","text":"<p>In dataframe, you learned how to write a dataframe-agnostic function.</p> <p>We only used DataFrame methods there - but what if we need to operate on its columns? There are two ways to do this:</p> <ul> <li>Series, e.g. <code>df.with_columns(df['a']*2)</code>.</li> <li>expressions, e.g. <code>df.with_columns(nw.col('a')*2)</code>.</li> </ul> <p>Expressions are by far the preferred way:</p> <ul> <li>They're inherently lazy and allow for optimisations.</li> <li>They the most idiomatic and portable solution.</li> <li>Series is only available for eager backends.</li> </ul> <p>Nonetheless, you might need to write dataframe-agnostic code which accepts user-provided Series. In that case, you'll need to pass <code>eager_only=True</code> to <code>nw.from_native</code>.</p>"},{"location":"basics/series/#example-1-filter-based-on-a-columns-values","title":"Example 1: filter based on a column's values","text":"<p>This can stay lazy, so we just use expressions:</p> from/to_native@narwhalify <pre><code>import narwhals as nw\nfrom narwhals.typing import IntoFrameT\n\n\ndef my_func(df: IntoFrameT) -&gt; IntoFrameT:\n    return nw.from_native(df).filter(nw.col(\"a\") &gt; 0).to_native()\n</code></pre> <pre><code>import narwhals as nw\nfrom narwhals.typing import FrameT\n\n\n@nw.narwhalify\ndef my_func(df: FrameT) -&gt; FrameT:\n    return df.filter(nw.col(\"a\") &gt; 0)\n</code></pre> <p>and call it either on a eager or lazy dataframe:</p> pandasPolars (eager)Polars (lazy)PyArrow <pre><code>import pandas as pd\n\ndf = pd.DataFrame({\"a\": [-1, 1, 3], \"b\": [3, 5, -3]})\nprint(my_func(df))\n</code></pre> <pre><code>   a  b\n1  1  5\n2  3 -3\n</code></pre> <pre><code>import polars as pl\n\ndf = pl.DataFrame({\"a\": [-1, 1, 3], \"b\": [3, 5, -3]})\nprint(my_func(df))\n</code></pre> <pre><code>shape: (2, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 i64 \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 5   \u2502\n\u2502 3   \u2506 -3  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <pre><code>import polars as pl\n\ndf = pl.LazyFrame({\"a\": [-1, 1, 3], \"b\": [3, 5, -3]})\nprint(my_func(df).collect())\n</code></pre> <pre><code>shape: (2, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 i64 \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 5   \u2502\n\u2502 3   \u2506 -3  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <pre><code>import pyarrow as pa\n\ntable = pa.table({\"a\": [-1, 1, 3], \"b\": [3, 5, -3]})\nprint(my_func(table))\n</code></pre> <pre><code>pyarrow.Table\na: int64\nb: int64\n----\na: [[1,3]]\nb: [[5,-3]]\n</code></pre>"},{"location":"basics/series/#example-2-multiply-a-columns-values-by-a-constant","title":"Example 2: multiply a column's values by a constant","text":"<p>Let's write a dataframe-agnostic function which multiplies the values in column <code>'a'</code> by 2. This can also stay lazy, and can use expressions:</p> from/to_native@narwhalify <pre><code>import narwhals as nw\nfrom narwhals.typing import IntoFrameT\n\n\ndef my_func(df: IntoFrameT) -&gt; IntoFrameT:\n    return nw.from_native(df).with_columns(nw.col(\"a\") * 2).to_native()\n</code></pre> <pre><code>import narwhals as nw\nfrom narwhals.typing import FrameT\n\n\n@nw.narwhalify\ndef my_func(df: FrameT) -&gt; FrameT:\n    return df.with_columns(nw.col(\"a\") * 2)\n</code></pre> <p>and call it either on a eager or lazy dataframe:</p> pandasPolars (eager)Polars (lazy)PyArrow <pre><code>import pandas as pd\n\ndf = pd.DataFrame({\"a\": [-1, 1, 3], \"b\": [3, 5, -3]})\nprint(my_func(df))\n</code></pre> <pre><code>   a  b\n0 -2  3\n1  2  5\n2  6 -3\n</code></pre> <pre><code>import polars as pl\n\ndf = pl.DataFrame({\"a\": [-1, 1, 3], \"b\": [3, 5, -3]})\nprint(my_func(df))\n</code></pre> <pre><code>shape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 i64 \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 -2  \u2506 3   \u2502\n\u2502 2   \u2506 5   \u2502\n\u2502 6   \u2506 -3  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <pre><code>import polars as pl\n\ndf = pl.LazyFrame({\"a\": [-1, 1, 3], \"b\": [3, 5, -3]})\nprint(my_func(df).collect())\n</code></pre> <pre><code>shape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 i64 \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 -2  \u2506 3   \u2502\n\u2502 2   \u2506 5   \u2502\n\u2502 6   \u2506 -3  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <pre><code>import pyarrow as pa\n\ntable = pa.table({\"a\": [-1, 1, 3], \"b\": [3, 5, -3]})\nprint(my_func(table))\n</code></pre> <pre><code>pyarrow.Table\na: int64\nb: int64\n----\na: [[-2,2,6]]\nb: [[3,5,-3]]\n</code></pre> <p>Note that column <code>'a'</code> was overwritten. If we had wanted to add a new column called <code>'c'</code> containing column <code>'a'</code>'s values multiplied by 2, we could have used <code>Expr.alias</code>:</p> <pre><code>import narwhals as nw\nfrom narwhals.typing import FrameT\n\n\n@nw.narwhalify\ndef my_func(df: FrameT) -&gt; FrameT:\n    return df.with_columns((nw.col(\"a\") * 2).alias(\"c\"))\n</code></pre> pandasPolars (eager)Polars (lazy)PyArrow <pre><code>import pandas as pd\n\ndf = pd.DataFrame({\"a\": [-1, 1, 3], \"b\": [3, 5, -3]})\nprint(my_func(df))\n</code></pre> <pre><code>   a  b  c\n0 -1  3 -2\n1  1  5  2\n2  3 -3  6\n</code></pre> <pre><code>import polars as pl\n\ndf = pl.DataFrame({\"a\": [-1, 1, 3], \"b\": [3, 5, -3]})\nprint(my_func(df))\n</code></pre> <pre><code>shape: (3, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2506 c   \u2502\n\u2502 --- \u2506 --- \u2506 --- \u2502\n\u2502 i64 \u2506 i64 \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 -1  \u2506 3   \u2506 -2  \u2502\n\u2502 1   \u2506 5   \u2506 2   \u2502\n\u2502 3   \u2506 -3  \u2506 6   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <pre><code>import polars as pl\n\ndf = pl.LazyFrame({\"a\": [-1, 1, 3], \"b\": [3, 5, -3]})\nprint(my_func(df).collect())\n</code></pre> <pre><code>shape: (3, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2506 c   \u2502\n\u2502 --- \u2506 --- \u2506 --- \u2502\n\u2502 i64 \u2506 i64 \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 -1  \u2506 3   \u2506 -2  \u2502\n\u2502 1   \u2506 5   \u2506 2   \u2502\n\u2502 3   \u2506 -3  \u2506 6   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <pre><code>import pyarrow as pa\n\ntable = pa.table({\"a\": [-1, 1, 3], \"b\": [3, 5, -3]})\nprint(my_func(table))\n</code></pre> <pre><code>pyarrow.Table\na: int64\nb: int64\nc: int64\n----\na: [[-1,1,3]]\nb: [[3,5,-3]]\nc: [[-2,2,6]]\n</code></pre>"},{"location":"basics/series/#example-3-finding-the-mean-of-a-column-as-a-scalar","title":"Example 3: finding the mean of a column as a scalar","text":"<p>Now, we want to find the mean of column <code>'a'</code>, and we need it as a Python scalar. This means that computation cannot stay lazy - it must execute! Therefore, we'll pass <code>eager_only=True</code> to <code>nw.from_native</code> (or <code>nw.narwhalify</code>), and then, instead of using expressions, we'll extract a <code>Series</code>.</p> from/to_native@narwhalify <pre><code>import narwhals as nw\nfrom narwhals.typing import IntoDataFrameT\n\n\ndef my_func(df: IntoDataFrameT) -&gt; float | None:\n    return nw.from_native(df, eager_only=True)[\"a\"].mean()\n</code></pre> <pre><code>import narwhals as nw\nfrom narwhals.typing import DataFrameT\n\n\n@nw.narwhalify(eager_only=True)\ndef my_func(df: DataFrameT) -&gt; float | None:\n    return df[\"a\"].mean()\n</code></pre> <p>Now we can call it on a eager dataframe only:</p> pandasPolars (eager)PyArrow <pre><code>import pandas as pd\n\ndf = pd.DataFrame({\"a\": [-1, 1, 3], \"b\": [3, 5, -3]})\nprint(my_func(df))\n</code></pre> <pre><code>1.0\n</code></pre> <pre><code>import polars as pl\n\ndf = pl.DataFrame({\"a\": [-1, 1, 3], \"b\": [3, 5, -3]})\nprint(my_func(df))\n</code></pre> <pre><code>1.0\n</code></pre> <pre><code>import pyarrow as pa\n\ntable = pa.table({\"a\": [-1, 1, 3], \"b\": [3, 5, -3]})\nprint(my_func(table))\n</code></pre> <pre><code>1.0\n</code></pre> <p>Note that, even though the output of our function is not a dataframe nor a series, we can still use <code>narwhalify</code>.</p>"},{"location":"concepts/boolean/","title":"Boolean columns","text":""},{"location":"concepts/boolean/#null-preservation","title":"Null preservation","text":"<p>Generally speaking, Narwhals operations preserve null values. For example, if you do <code>nw.col('a')*2</code>, then:</p> <ul> <li>Values which were non-null get multiplied by 2.</li> <li>Null values stay null.</li> </ul> <pre><code>import narwhals as nw\nfrom narwhals.typing import IntoFrameT\n\ndata = {\"a\": [1.4, None, 4.2]}\n\n\ndef multiplication(df: IntoFrameT) -&gt; IntoFrameT:\n    return nw.from_native(df).with_columns((nw.col(\"a\") * 2).alias(\"a*2\")).to_native()\n</code></pre> pandasPolars (eager)PyArrow <pre><code>import pandas as pd\n\ndf = pd.DataFrame(data)\nprint(multiplication(df))\n</code></pre> <pre><code>     a  a*2\n0  1.4  2.8\n1  NaN  NaN\n2  4.2  8.4\n</code></pre> <pre><code>import polars as pl\n\ndf = pl.DataFrame(data)\nprint(multiplication(df))\n</code></pre> <pre><code>shape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a    \u2506 a*2  \u2502\n\u2502 ---  \u2506 ---  \u2502\n\u2502 f64  \u2506 f64  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1.4  \u2506 2.8  \u2502\n\u2502 null \u2506 null \u2502\n\u2502 4.2  \u2506 8.4  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <pre><code>import pyarrow as pa\n\ntable = pa.table(data)\nprint(multiplication(table))\n</code></pre> <pre><code>pyarrow.Table\na: double\na*2: double\n----\na: [[1.4,null,4.2]]\na*2: [[2.8,null,8.4]]\n</code></pre> <p>What do we do, however, when the result column is boolean? For example, <code>nw.col('a') &gt; 0</code>? Unfortunately, this is backend-dependent:</p> <ul> <li>for all backends except pandas, null values are preserved</li> <li>for pandas, this depends on the dtype backend:<ul> <li>for PyArrow dtypes and pandas nullable dtypes, null values are preserved</li> <li>for the classic NumPy dtypes, null values are typically filled in with <code>False</code>.</li> </ul> </li> </ul> <p>pandas is generally moving towards nullable dtypes, and they may become the default in the future, so we hope that the classical NumPy dtypes not supporting null values will just be a temporary legacy pandas issue which will eventually go away anyway.</p> <pre><code>from narwhals.typing import FrameT\n\n\ndef comparison(df: FrameT) -&gt; FrameT:\n    return nw.from_native(df).with_columns((nw.col(\"a\") &gt; 2).alias(\"a&gt;2\")).to_native()\n</code></pre> pandasPolars (eager)PyArrow <pre><code>import pandas as pd\n\ndf = pd.DataFrame(data)\nprint(comparison(df))\n</code></pre> <pre><code>     a    a&gt;2\n0  1.4  False\n1  NaN  False\n2  4.2   True\n</code></pre> <pre><code>import polars as pl\n\ndf = pl.DataFrame(data)\nprint(comparison(df))\n</code></pre> <pre><code>shape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a    \u2506 a&gt;2   \u2502\n\u2502 ---  \u2506 ---   \u2502\n\u2502 f64  \u2506 bool  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1.4  \u2506 false \u2502\n\u2502 null \u2506 null  \u2502\n\u2502 4.2  \u2506 true  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <pre><code>import pyarrow as pa\n\ntable = pa.table(data)\nprint(comparison(table))\n</code></pre> <pre><code>pyarrow.Table\na: double\na&gt;2: bool\n----\na: [[1.4,null,4.2]]\na&gt;2: [[false,null,true]]\n</code></pre>"},{"location":"concepts/boolean/#kleene-logic","title":"Kleene logic","text":"<p>Generally speaking, if we have two boolean columns <code>'a'</code> and <code>'b'</code>, then <code>nw.col('a') | nw.col('b')</code> and <code>nw.col('a') &amp; nw.col('b')</code> follow Kleene logic. That is to say:</p> <code>nw.col('a')</code> <code>nw.col('b')</code> <code>nw.col('a') | nw.col('b')</code> <code>nw.col('a') &amp; nw.col('b')</code> True True True True True False True False True None True None False True True False False False False False False None None False None True True None None False None False None None None None <p>Here, too, pandas backed by NumPy types differs, as its boolean columns cannot store null values:</p> <ul> <li>For <code>nw.col('a') | nw.col('b')</code>, pandas returns <code>True</code> if at least one column contains a <code>True</code> value, and <code>False</code> otherwise.</li> <li>For <code>nw.col('a') &amp; nw.col('b')</code>, pandas returns <code>True</code> if both columns contain <code>True</code> values, and <code>False</code> otherwise.</li> </ul> <p>In <code>any_horizontal</code> and <code>all_horizontal</code> there is an <code>ignore_nulls</code> argument, which behaves as follows:</p> <ul> <li> <p>If <code>True</code>, then null values are ignored and contribute nothing to the final result. If there are     no values, the result is:</p> <ul> <li><code>False</code> for <code>any_horizontal</code>.</li> <li><code>True</code> for <code>all_horizontal</code>.</li> <li>If <code>False</code>, then Kleene logic is followed. If using pandas backed by classical NumPy types, then this option is not supported.</li> </ul> </li> </ul>"},{"location":"concepts/column_names/","title":"Column names","text":"<p>Polars and PyArrow only allow for string column names. What about pandas?</p> <pre><code>import pandas as pd\n\ndf = pd.concat([pd.Series([1, 2], name=0), pd.Series([1, 3], name=0)], axis=1)\nprint(df)\n</code></pre> <pre><code>   0  0\n0  1  1\n1  2  3\n</code></pre> <p>Oh...not only does it let us create a dataframe with a column named <code>0</code> - it lets us create one with two such columns!</p> <p>What does Narwhals do about this?</p> <ul> <li>In general, non-string column names are supported. In some places where this might   create ambiguity (such as <code>DataFrame.__getitem__</code> or <code>DataFrame.select</code>) we may be strict and only   allow passing in column names if they're strings.</li> <li>If you have a use-case that's   failing for non-string column names, please report it to https://github.com/narwhals-dev/narwhals/issues   and we'll see if we can support it.</li> <li>Duplicate column names are \ud83d\udeab banned \ud83d\udeab.</li> </ul>"},{"location":"concepts/improve_group_by_operation/","title":"Avoiding the <code>UserWarning</code> error while using Pandas <code>group_by</code>","text":""},{"location":"concepts/improve_group_by_operation/#introduction","title":"Introduction","text":"<p>If you have ever experienced the</p> <p>UserWarning: Found complex group-by expression, which can't be expressed efficiently with the pandas API. If you can, please rewrite your query such that group-by aggregations are simple (e.g. mean, std, min, max, ...)</p> <p>message while using the narwhals <code>group_by()</code> method, this is for you. If you haven't, this is also for you as you might experience it and you need to know how to avoid it.</p> <p>Take the following two codes as an example.</p> Approach 1Approach 2 <pre><code>import narwhals as nw\nimport pandas as pd\nfrom narwhals.typing import IntoFrameT\n\ndata = {\"a\": [1, 2, 3, 4, 5], \"b\": [5, 4, 3, 2, 1], \"c\": [10, 20, 30, 40, 50]}\n\ndf_pd = pd.DataFrame(data)\n\n\ndef approach_1(df_native: IntoFrameT) -&gt; IntoFrameT:\n    df = nw.from_native(df_native)\n    df = df.group_by(\"a\").agg(d=(nw.col(\"b\") + nw.col(\"c\")).sum())\n    return df.to_native()\n\n\nprint(approach_1(df_pd))\n</code></pre> <pre><code>   a   d\n0  1  15\n1  2  24\n2  3  33\n3  4  42\n4  5  51\n</code></pre> <pre><code>import narwhals as nw\nimport pandas as pd\n\ndata = {\"a\": [1, 2, 3, 4, 5], \"b\": [5, 4, 3, 2, 1], \"c\": [10, 20, 30, 40, 50]}\n\ndf_pd = pd.DataFrame(data)\n\n\ndef approach_2(df_native: IntoFrameT) -&gt; IntoFrameT:\n    df = nw.from_native(df_native)\n    df = df.with_columns(d=nw.col(\"b\") + nw.col(\"c\")).group_by(\"a\").agg(nw.sum(\"d\"))\n    return df.to_native()\n\n\nprint(approach_2(df_pd))\n</code></pre> <pre><code>   a   d\n0  1  15\n1  2  24\n2  3  33\n3  4  42\n4  5  51\n</code></pre> <p>Both approaches shown above return the exact same result, but Approach 1 is inefficient and returns the warning message we showed at the top.</p> <p>What makes the first approach inefficient and the second approach efficient? It comes down to what the pandas API lets us express.</p>"},{"location":"concepts/improve_group_by_operation/#approach-1","title":"Approach 1","text":"<p>The literal pandas translation is:</p> <pre><code>df.groupby(\"a\").apply(\n    lambda df: pd.Series([(df[\"b\"] + df[\"c\"]).sum()], index=[\"d\"]), include_groups=False\n)\n</code></pre> <p>pandas experts immediately recognise the issue: it uses <code>apply</code>. Any time you use <code>apply</code> in pandas, that's a performance footgun - best to avoid it and use vectorised operations instead. Let's take a look at how \"approach 2\" gets translated to pandas to see the difference.</p>"},{"location":"concepts/improve_group_by_operation/#approach-2","title":"Approach 2","text":"<p>The literal pandas translation is:</p> <pre><code>df.assign(d=lambda df: df[\"b\"] + df[\"c\"]).groupby(\"a\").agg({\"d\": \"sum\"})\n</code></pre> <p>Because we're using pandas' own API, as opposed to <code>apply</code> and a custom <code>lambda</code> function, then this is going to be much more efficient! That's why it's preferred.</p>"},{"location":"concepts/improve_group_by_operation/#tips-for-avoiding-the-userwarning","title":"Tips for Avoiding the <code>UserWarning</code>","text":"<ol> <li>Decompose complex operations: break down complex transformations into simpler steps.    In this case, keep the <code>.agg</code> method simple.    Compute new columns first, then use these columns in aggregation or other operations.</li> <li>Avoid redundant computations: if an operation (like addition) is used multiple times,    compute it once and store the result in a new column.</li> </ol> <p>Happy grouping! \ud83e\udee1</p>"},{"location":"concepts/null_handling/","title":"Null/NaN handling","text":""},{"location":"concepts/null_handling/#tldr","title":"TL;DR","text":"<p>All dataframe tools, except for those which piggy-back off of pandas, make a clear distinction between NaN and null values. </p> <p>Tip</p> <p>We recommend only handling null values in applications and leaving NaN values as an  edge case resulting from users having performed undefined mathematical operations.</p>"},{"location":"concepts/null_handling/#whats-the-difference","title":"What's the difference?","text":"<p>Most data tools except pandas make a clear distinction between:</p> <ul> <li>Null values, representing missing data.</li> <li>NaN values, resulting from \"illegal\" mathematical operations like <code>0/0</code>.</li> </ul> <p>In Narwhals, this is reflected in separate methods for Null/NaN values:</p> Operation Null NaN is <code>Expr.is_null</code> <code>Expr.is_nan</code> fill <code>Expr.fill_null</code> <code>Expr.fill_nan</code> drop <code>Expr.drop_nulls</code> Not yet implemented (See discussion)<code>polars.Expr.drop_nans</code> count <code>Expr.null_count</code> No upstream equivalent <p>In pandas however the concepts are muddied, as different sentinel values represent missing depending on the data type.</p> <p>Check how different tools distinguish them (or don't) in the following example:</p> <pre><code>import narwhals as nw\nimport numpy as np\nfrom narwhals.typing import IntoFrameT\n\ndata = {\"a\": [1.0, 0.0, None]}\n\n\ndef check_null_behavior(df: IntoFrameT) -&gt; IntoFrameT:\n    return (\n        nw.from_native(df)\n        .with_columns(a=nw.col(\"a\") / nw.col(\"a\"))\n        .with_columns(\n            a_is_null=nw.col(\"a\").is_null(),\n            a_is_nan=nw.col(\"a\").is_nan(),\n        )\n    ).to_native()\n</code></pre> pandaspandas (pyarrow-backed)Polars (eager)PyArrow <pre><code>import pandas as pd\n\ndf = pd.DataFrame(data)\nprint(check_null_behavior(df))\n</code></pre> <pre><code>     a  a_is_null  a_is_nan\n0  1.0      False     False\n1  NaN       True      True\n2  NaN       True      True\n</code></pre> <pre><code>import pandas as pd\n\ndf = pd.DataFrame(data).convert_dtypes(dtype_backend=\"pyarrow\")\nprint(check_null_behavior(df))\n</code></pre> <pre><code>      a  a_is_null a_is_nan\n0   1.0      False    False\n1   NaN      False     True\n2  &lt;NA&gt;       True     &lt;NA&gt;\n</code></pre> <pre><code>import polars as pl\n\ndf = pl.DataFrame(data)\nprint(check_null_behavior(df))\n</code></pre> <pre><code>shape: (3, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a    \u2506 a_is_null \u2506 a_is_nan \u2502\n\u2502 ---  \u2506 ---       \u2506 ---      \u2502\n\u2502 f64  \u2506 bool      \u2506 bool     \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1.0  \u2506 false     \u2506 false    \u2502\n\u2502 NaN  \u2506 false     \u2506 true     \u2502\n\u2502 null \u2506 true      \u2506 null     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <pre><code>import pyarrow as pa\n\ndf = pa.table(data)\nprint(check_null_behavior(df))\n</code></pre> <pre><code>pyarrow.Table\na: double\na_is_null: bool\na_is_nan: bool\n----\na: [[1,nan,null]]\na_is_null: [[false,false,true]]\na_is_nan: [[false,true,null]]\n</code></pre> <p>Notice how the classic pandas dtypes make no distinction between the concepts, whereas the other libraries do. Note however that discussion on what PyArrow-backed pandas dataframe should do is ongoing.</p>"},{"location":"concepts/null_handling/#nan-comparisons","title":"NaN comparisons","text":"<p>According to the IEEE-754 standard, NaN should compare as not equal to itself, and cannot be compared with other floating point numbers. Python and PyArrow follow these rules:</p> <pre><code>import pyarrow as pa\nimport pyarrow.compute as pc\n\nprint(\"Python result:\")\nprint(float(\"nan\") == float(\"nan\"), 0.0 == 0.0)\nprint()\nprint(\"PyArrow result:\")\narr = pa.array([float(\"nan\"), 0.0])\nprint(pc.equal(arr, arr))\n</code></pre> <pre><code>Python result:\nFalse True\n\nPyArrow result:\n[\n  false,\n  true\n]\n</code></pre> <p>Polars and DuckDB, however, don't follow this rule, and treat NaN as equal to itself.</p> <pre><code>import polars as pl\nimport duckdb\n\nprint(\"Polars result\")\ndf = pl.DataFrame({\"a\": [float(\"nan\"), 0.0]})\nprint(df.with_columns(a_equals_a=pl.col(\"a\") == pl.col(\"a\")))\nprint()\nprint(\"DuckDB result\")\nprint(duckdb.sql(\"from df select a, a == a as a_equals_a\"))\n</code></pre> <pre><code>Polars result\nshape: (2, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 a_equals_a \u2502\n\u2502 --- \u2506 ---        \u2502\n\u2502 f64 \u2506 bool       \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 NaN \u2506 true       \u2502\n\u2502 0.0 \u2506 true       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nDuckDB result\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   a    \u2502 a_equals_a \u2502\n\u2502 double \u2502  boolean   \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502    nan \u2502 true       \u2502\n\u2502    0.0 \u2502 true       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Furthermore, Polars excludes NaN values in <code>max</code> whereas DuckDB treats them as larger than any other floating-point value.</p> <p>For all these reasons it bears reiterating that our recommendation is to only handle null values in applications, and leave NaN values as an edge case resulting from users having performed undefined mathematical operations.</p>"},{"location":"concepts/order_dependence/","title":"Order-dependence","text":"<p>Narwhals has four main public classes:</p> <ul> <li><code>Expr</code>: this is what gets created when you write <code>nw.col('a')</code>.</li> <li><code>DataFrame</code>: in-memory, eager dataframe with a well-defined row order which   is preserved across <code>with_columns</code> and <code>select</code> operations.</li> <li><code>LazyFrame</code>: a dataframe which makes no assumptions about row-ordering. This   allows it to be backed by SQL engines.</li> <li><code>Series</code>: 1-dimensional in-memory structure with a defined row order. This is   what you get if you extract a single column from a <code>DataFrame</code>.</li> </ul> <p>Row order is important to think about when performing operations which rely on it, such as:</p> <ul> <li><code>diff</code>, <code>shift</code>.</li> <li><code>cum_sum</code>, <code>cum_min</code>, ...</li> <li><code>rolling_sum</code>, <code>rolling_min</code>, ...</li> <li><code>is_first_distinct</code>, <code>is_last_distinct</code>.</li> </ul> <p>When row-order is defined, as is the case for <code>DataFrame</code>, these operations pose no issue.</p> <pre><code>import narwhals as nw\nimport pandas as pd\n\ndata = {\"a\": [1, 3, 4], \"i\": [0, 1, 2]}\ndf = nw.from_native(pd.DataFrame(data))\nprint(df.with_columns(a_cum_sum=nw.col(\"a\").cum_sum()))\n</code></pre> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|   a  i  a_cum_sum|\n|0  1  0          1|\n|1  3  1          4|\n|2  4  2          8|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>When row order is undefined however, then these operations do not have a defined result. To make them well-defined, you need to follow them with <code>over</code> in which you specify <code>order_by</code>. For example:</p> <ul> <li><code>nw.col('a').cum_sum()</code> can only be executed by a <code>DataFrame</code>.</li> <li><code>nw.col('a').cum_sum().over(order_by=\"i\")</code> can only be executed by either a <code>DataFrame</code>   or a <code>LazyFrame</code>.</li> </ul> <pre><code>import polars as pl\n\nlf = nw.from_native(pl.LazyFrame(data))\nresult = lf.with_columns(a_cum_sum=nw.col(\"a\").cum_sum().over(order_by=\"i\"))\nprint(result.collect())\n</code></pre> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|   Narwhals DataFrame    |\n|-------------------------|\n|shape: (3, 3)            |\n|\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510|\n|\u2502 a   \u2506 i   \u2506 a_cum_sum \u2502|\n|\u2502 --- \u2506 --- \u2506 ---       \u2502|\n|\u2502 i64 \u2506 i64 \u2506 i64       \u2502|\n|\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561|\n|\u2502 1   \u2506 0   \u2506 1         \u2502|\n|\u2502 3   \u2506 1   \u2506 4         \u2502|\n|\u2502 4   \u2506 2   \u2506 8         \u2502|\n|\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>When writing an order-dependent function, if you want it to be executable by <code>LazyFrame</code> (and not just <code>DataFrame</code>), make sure that all order-dependent expressions are followed by <code>over</code> with <code>order_by</code> specified. If you forget to, don't worry, Narwhals will give you a loud and clear error message.</p>"},{"location":"concepts/pandas_index/","title":"What about the pandas Index?","text":"<p>There are two types of pandas users:</p> <ul> <li>The ones who make full use of the Index's power.</li> <li>The <code>.reset_index(drop=True)</code> ones, who would rather not think about the Index.</li> </ul> <p>Narwhals aims to accommodate both!</p> <ul> <li>If you'd rather not think about the Index, then don't   worry: it's not part of the Narwhals public API, and you'll never have to worry about   resetting the index or about pandas doing funky index alignment for you.</li> <li>If you want your library to cater to Index powerusers who would be very angry if you reset   their beautiful Index on their behalf, then don't worry: Narwhals makes certain promises   with regards to the Index.</li> </ul> <p>Let's learn about what Narwhals promises.</p>"},{"location":"concepts/pandas_index/#1-narwhals-will-preserve-your-index-for-common-dataframe-operations","title":"1. Narwhals will preserve your index for common dataframe operations","text":"<pre><code>import narwhals as nw\nfrom narwhals.typing import IntoFrameT\n\n\ndef my_func(df: IntoFrameT) -&gt; IntoFrameT:\n    df = nw.from_native(df)\n    df = df.with_columns(a_plus_one=nw.col(\"a\") + 1)\n    return nw.to_native(df)\n</code></pre> <p>Let's start with a dataframe with an Index with values <code>[7, 8, 9]</code>.</p> <pre><code>import pandas as pd\n\ndf = pd.DataFrame({\"a\": [2, 1, 3], \"b\": [3, 5, -3]}, index=[7, 8, 9])\nprint(my_func(df))\n</code></pre> <pre><code>   a  b  a_plus_one\n7  2  3           3\n8  1  5           2\n9  3 -3           4\n</code></pre> <p>Note how the result still has the original index - Narwhals did not modify it. Narwhals will preserve your original index for most common dataframe operations. However, Narwhals will not preserve the original index for <code>DataFrame.group_by</code>, because there, overlapping index and column names raise errors.</p>"},{"location":"concepts/pandas_index/#2-index-alignment-follows-the-left-hand-rule","title":"2. Index alignment follows the left-hand-rule","text":"<p>pandas automatically aligns indices for users. For example:</p> <pre><code>import pandas as pd\n\ndf_pd = pd.DataFrame({\"a\": [2, 1, 3], \"b\": [4, 5, 6]})\ns_pd = df_pd[\"a\"].sort_values()\ndf_pd[\"a_sorted\"] = s_pd\n</code></pre> <p>Reading the code, you might expect that <code>'a_sorted'</code> will contain the values <code>[1, 2, 3]</code>.</p> <p>However, here's what actually happens:</p> <pre><code>print(df_pd)\n</code></pre> <pre><code>   a  b  a_sorted\n0  2  4         2\n1  1  5         1\n2  3  6         3\n</code></pre> <p>In other words, pandas' index alignment undid the <code>sort_values</code> operation!</p> <p>Narwhals, on the other hand, preserves the index of the left-hand-side argument. Everything else will be inserted positionally, just like Polars would do:</p> <pre><code>import narwhals as nw\n\ndf = nw.from_native(df_pd)\ns = nw.from_native(s_pd, allow_series=True)\ndf = df.with_columns(a_sorted=s.sort())\nprint(nw.to_native(df))\n</code></pre> <pre><code>   a  b  a_sorted\n0  2  4         1\n1  1  5         2\n2  3  6         3\n</code></pre> <p>If you keep these two rules in mind, then Narwhals will both help you avoid Index-related surprises whilst letting you preserve the Index for the subset of your users who consciously make great use of it.</p>"}]}